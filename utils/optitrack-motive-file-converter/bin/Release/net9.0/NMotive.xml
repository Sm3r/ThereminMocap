<?xml version="1.0"?>
<doc>
    <assembly>
        "NMotive"
    </assembly>
    <members>
        <member name="M:NMotive.ITakeProcessingScriptWithArgs.ValidateArguments(System.String[])">
            <summary>
Validates the arguments for the script. Arguments will by passed to
the script, via the <c>Arguments</c> property, only after they have
been validated by this function.
</summary>
            <param name="argString">The argument string to validate.</param>
            <returns>The result of the validation. If the argument string is validated
the <c>Success</c> field of the returned <c>Result</c> object should
be set to <c>true</c>. If validation fails the he <c>Success</c> field 
of the returned <c>Result</c> object should be set to <c>false</c> and
the <c>Message</c> field should indicate the nature of the error.</returns>
        </member>
        <member name="P:NMotive.ITakeProcessingScriptWithArgs.ArgumentLabel">
            <summary>
You can optionally supply a label to the Motive Batch Processor to 
display next to the text entry box where the user will enter script
arguments. Return <c>null</c> or an empty string if you do not wish
to supply a label.
</summary>
        </member>
        <member name="P:NMotive.ITakeProcessingScriptWithArgs.Arguments">
            <summary>
Set default values for script arguments. Script arguments are an array of
of strings, similar to a programs command line arguments. Script arguments
entered by the user in the Motive Batch Processor will be passed to the
script by this functions.
</summary>
            <remarks>
Arguments are passed to the script only after they are validated by the
<c>ValidateArguments</c> function.
</remarks>
        </member>
        <member name="P:NMotive.ITakeProcessingScriptWithArgs.DefaultArguments">
            <summary>
Get default values for script arguments. Script arguments are an array of
of strings, similar to a programs command line arguments. May return
<c>null</c> or an empty array if there are no default values.
</summary>
        </member>
        <member name="T:NMotive.ITakeProcessingScriptWithArgs">
            <summary>
Interface implemented by .NET scripts if they want to be run using the
Motive Batch Processor application and accept arguments input by the
user.
</summary>
        </member>
        <member name="M:NMotive.AudioExporter.Export(NMotive.Take,System.String)">
            <summary>
Exports audio from the take to a wave file.
</summary>
            <param name="take">The take to export audio from.</param>
            <param name="filePath">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.AudioExporter.Progress">
            <summary>
Gets/Sets the progress indicator used by this exporter.
</summary>
        </member>
        <member name="P:NMotive.AudioExporter.Overwrite">
            <summary>
Gets/Sets a property that is <c>true</c> The exporter will overwrite existing file contents.
</summary>
        </member>
        <member name="T:NMotive.AudioExporter">
            <summary>
Class for exporting audio track from takes which contain them.
</summary>
        </member>
        <member name="M:MotiveCore.AudioManager.ShutDown">
            <summary>Shut down the manager and release shared pointers to other managers.</summary>
        </member>
        <member name="M:MotiveCore.AudioManager.Initialize(std.shared_ptr&lt;MoCapCore.cTakeManager&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Initialize the manager.</summary>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.ErrorDialogEnabled">
            <summary>
Gets the value of the property.
Index of the audio capture device.
</summary>
            <returns>The property value.</returns>
            <summary>
Sets the value of the property.
Index of the audio capture device.
</summary>
            <param name="audioCaptureDeviceIndexValue">The new property value.</param>
            <summary>
Gets the property of the property
Index of the audio capture device.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Index of the audio capture device.
</summary>
            <returns>A const pointer to the property.</returns>
            <summary>
Gets the value of the property.
Index of the audio render device.
</summary>
            <returns>The property value.</returns>
            <summary>
Sets the value of the property.
Index of the audio render device.
</summary>
            <param name="audioRenderDeviceIndexValue">The new property value.</param>
            <summary>
Gets the property of the property
Index of the audio render device.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Index of the audio render device.
</summary>
            <returns>A const pointer to the property.</returns>
            <summary>
Gets the value of the property.
Whether to show the error dialog.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioPlaybackTakeFormatProperty">
            <summary>
Gets the property of the property
Take format of the audio playback device.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Take format of the audio playback device.
</summary>
            <returns>A const pointer to the property.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.SetAudioPlaybackTakeFormat(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Take format of the audio playback device.
</summary>
            <param name="audioCaptureDeviceIndexValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioPlaybackTakeFormat">
            <summary>
Gets the value of the property.
Take format of the audio playback device.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioPlaybackDeviceFormatProperty">
            <summary>
Gets the property of the property
Device format of the audio playback device.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Device format of the audio playback device.
</summary>
            <returns>A const pointer to the property.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.SetAudioPlaybackDeviceFormat(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Device format of the audio playback device.
</summary>
            <param name="audioCaptureDeviceIndexValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioPlaybackDeviceFormat">
            <summary>
Gets the value of the property.
Device format of the audio playback device.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioPlaybackOutputProperty">
            <summary>
Gets the property of the property
Output of the audio playback device.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Output of the audio playback device.
</summary>
            <returns>A const pointer to the property.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.SetAudioPlaybackOutput(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Output of the audio playback device.
</summary>
            <param name="audioCaptureDeviceIndexValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioPlaybackOutput">
            <summary>
Gets the value of the property.
Output of the audio playback device.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioCaptureDeviceFormatProperty">
            <summary>
Gets the property of the property
Device format of the audio capture device.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Device format of the audio capture device.
</summary>
            <returns>A const pointer to the property.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.SetAudioCaptureDeviceFormat(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Device format of the audio capture device.
</summary>
            <param name="audioCaptureDeviceIndexValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioCaptureDeviceFormat">
            <summary>
Gets the value of the property.
Device format of the audio capture device.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioCaptureInputProperty">
            <summary>
Gets the property of the property
Capture input text.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets the property of the property
Capture input text.
</summary>
            <returns>A pointer to the property.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.SetAudioCaptureInput(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Capture input text.
</summary>
            <param name="audioCaptureDeviceIndexValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.AudioCaptureInput">
            <summary>
Gets the value of the property.
Capture input text.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.EnableAudioRenderProperty">
            <summary>
Gets the property of the property
Enable/Disable audio render.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Enable/Disable audio render.
</summary>
            <returns>A const pointer to the property.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.SetEnableAudioRender(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Enable/Disable audio render.
</summary>
            <param name="enableAudioRenderValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.EnableAudioRender">
            <summary>
Gets the value of the property.
Enable/Disable audio render.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.EnableAudioCaptureProperty">
            <summary>
Gets the property of the property
Enable/Disable audio capture.
</summary>
            <returns>A pointer to the property.</returns>
            <summary>
Gets a read-only reference to the property of the property
Enable/Disable audio capture.
</summary>
            <returns>A const pointer to the property.</returns>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.SetEnableAudioCapture(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Enable/Disable audio capture.
</summary>
            <param name="enableAudioCaptureValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cAudioCaptureProperties.EnableAudioCapture">
            <summary>
Gets the value of the property.
Enable/Disable audio capture.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="T:MoCapCore.cStringListPropertyValue">
            <summary>A property value represented by a list of strings.</summary>
        </member>
        <member name="T:MotiveCore.cBVHExporter">
            <summary>
Exporter class for BVH files
</summary>
        </member>
        <member name="M:NMotive.BVHExporter.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="filename">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.BVHExporter.SkeletonName">
            <summary>
Gets and sets the name of the skeleton to export. 
The default is to export the first skeleton in the takes
list of skeletons.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.MotionBuilderNames">
            <summary>
Gets and sets whether or not to use MotionBuilder names.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.HandsDownward">
            <summary>
Gets and sets the hands downward option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.ExcludeFingers">
            <summary>
Gets and sets the exclude fingers option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.ExcludeToes">
            <summary>
Gets and sets the exclude toes option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.SingleJointTorso">
            <summary>
Gets and sets the single joint torso option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in BVH export. Default value is meters.
</summary>
        </member>
        <member name="M:NMotive.BVHExporter.#ctor">
            <summary>
Constructs a <c>BVHExporter</c> object with the default options.
</summary>
        </member>
        <member name="T:NMotive.BVHExporter">
            <summary>
Class for exporting take data in BVH format.
</summary>
        </member>
        <member name="M:NMotive.Settings.ImportCalibrationSettings(System.String)">
            <summary>Import calibration settings from a file. The importation must be
done before every operation that will use them.</summary>
            <param name="settingsFilename">Calibration settings file name.</param>
            <returns>The result of the import attempt.</returns>
        </member>
        <member name="M:NMotive.Settings.ImportMotiveProfile(System.String)">
            <summary>Import a Motive profile from a file. The importation must be
done before every operation that will use the settings contained therein. 
In particular this applies for reconstruction settings in the profile file.</summary>
            <param name="profileFile">Motive profile settings file name.</param>
            <returns>The result of the import attempt.</returns>
        </member>
        <member name="T:NMotive.Settings">
            <summary>Functions for importing global settings. Like reconstruction and
calibration settings.</summary>
        </member>
        <member name="M:MotiveCore.cCalibrationSerializer.SaveCalibrationAsCalFile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cCameraCalibration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Export a calibration to a disk file.</summary>
        </member>
        <member name="M:MotiveCore.cCalibrationSerializer.LoadCalibration(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cCameraCalibration*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Import a calibration from file on disk.</summary>
        </member>
        <member name="T:MotiveCore.cCalibrationSerializer">
            <summary>A loader/saver class for handling calibrations.</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.SetAnchorVisibilities(std.map&lt;Core.cUID,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;,std.less&lt;Core.cUID&gt;,std.allocator&lt;std.pair&lt;Core.cUID!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the anchor marker visibility from the cameras.</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.AnchorVisibilities">
            <summary>
Returns the anchor marker ID to camera serials map. 
Indicates the visibilities of the anchor markers by the cameras at the time of the creation.
</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.SetAnchorMarkers(std.vector&lt;Core.cTMarker&lt;System.Single&gt;,std.allocator&lt;Core.cTMarker&lt;System.Single&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set list of anchor markers.</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.ClearAnchorMarkers">
            <summary>Clear list of anchor markers.</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.AnchorMarkers">
            <summary>Fetch list of anchor markers.</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.SetCalibrationInfo(MoCapCore.cCameraCalibration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copy calibration info from another cCameraCalibration</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.ClearCalibrationInfo">
            <summary>Clear calibration info with this method.</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.InitializeCalibrationInfo(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Populate calibration info with this method.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.Year">
            <summary>Date and time of calibration</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandActive">
            <summary>IsActiveWand reports if an active wand was used for calibration.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMicronSeries">
            <summary>IsMicronSeries reports if an OptiTrack Micron Series wand was used.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandCenterOffset">
            <summary>This is the amount of offset in the wand's center marker in meters.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandLength">
            <summary>This length of the wand used for calibration in meters.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError99Percentile">
            <summary>99% of the Wand Mean Error values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError95Percentile">
            <summary>95% of the Wand Mean Error values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError50Percentile">
            <summary>50% of the Wand Mean Error values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError">
            <summary>This is the global wand mean error for the system.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError99Percentile">
            <summary>99% of the Triangulation Mean Residual values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError95Percentile">
            <summary>95% of the Triangulation Mean Residual values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError50Percentile">
            <summary>50% of the Triangulation Mean Residual values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError">
            <summary>This is the global triangulation mean residual error for the camera system.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.ReprojectionMeanPixelError">
            <summary>This is the global reprojection mean pixel error for the camera system.</summary>
        </member>
        <member name="T:MoCapCore.cFileStream">
            <summary>
A concrete implementation of the cDataStream interface that abstracts the real file system.
</summary>
        </member>
        <member name="T:MoCapCore.cDataStream">
            <summary>
A partial implementation of the cIDataStream interface that provides some convenience functionality
for derived classes.
</summary>
        </member>
        <member name="M:NMotive.FBXBinaryExporter.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given data file.
</summary>
            <param name="take">The take to export</param>
            <param name="filename">The data file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.RemoveBoneNamePrefixes">
            <summary>
Gets and sets the remove bone name prefixes option. When set to <c>true</c>
removes the skeleton name prefix from the bones to create skeletons that are
easily retargetable and interchangeable. Use when exporting to Unreal Engine.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.ExcludeFingers">
            <summary>
Gets and sets the exclude fingers option. When set to <c>true</c>, exported
skeletons will not include fingers, if they are tracked in the take file.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.IndividualAssets">
            <summary>
Gets and sets the individual assets option. If <c>true</c> data for each
asset is exported into a separate file. Default value is <c>false</c></summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.CamerasOption">
            <summary>
Select the cameras to include in your export. The default is
<c>Cameras.NoCameras</c></summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.MarkersetNames">
            <summary>
Selects which markersets will be exported when the <c>MarkersetWriteOption</c>
has value <c>MarkersetWriteOptions.Named</c>. The list is empty
by default.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.MarkersetWriteOption">
            <summary>
Gets and sets the option for writing out markersets.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.MarkersetNulls">
            <summary>
Gets and sets the markerset nulls property. If true exports 6 degrees of
freedom data for selected assets. 
Default value is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.BoneNamingConvention">
            <summary>
Gets and sets the bone naming convention.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.SkeletalMesh">
            <summary>
Gets and sets the Skeletal Stick Mesh property. Set to
<c>true</c> if exporting to a game engine that requires 
FBX mesh asset to apply tracked skeletons to other characters
for retargeting purposes. Default value is false;
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.IsBusy">
            <summary>
Gets a property that is <c>true</c> if the this object is currently 
busy doing an export operation.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.IsBinary">
            <summary>
Gets a property that is <c>strue</c> if the export format is binary.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.Description">
            <summary>
Gets the description of this exporter.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.Name">
            <summary>
Gets the name of this exporter.
</summary>
        </member>
        <member name="M:NMotive.FBXBinaryExporter.#ctor">
            <summary>
Creates an <c>FBXBinaryExporter</c> instance with default options.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.MarkersetWriteOptions.None">
            <summary>
Do not write out markersets.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.MarkersetWriteOptions.Named">
            <summary>
Only write markersets whose name appears in the class property
<c>MarkersetNames</c></summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.MarkersetWriteOptions.All">
            <summary>
Write out all markersets.
</summary>
        </member>
        <member name="T:NMotive.FBXBinaryExporter.MarkersetWriteOptions">
            <summary>
Options for writing out markersets.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.Cameras.AllCameras">
            <summary>
All cameras.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.Cameras.ColorCameras">
            <summary>
All color cameras.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.Cameras.NoCameras">
            <summary>
Do not export cameras.
</summary>
        </member>
        <member name="T:NMotive.FBXBinaryExporter.Cameras">
            <summary>
Camera export options.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.BoneNamingConventions.UnrealEngine">
            <summary>
Unreal Engine convention.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.BoneNamingConventions.FBX">
            <summary>
FBX convention.
</summary>
        </member>
        <member name="F:NMotive.FBXBinaryExporter.BoneNamingConventions.Motive">
            <summary>
Motive convention.
</summary>
        </member>
        <member name="T:NMotive.FBXBinaryExporter.BoneNamingConventions">
            <summary>
Bone naming options.
</summary>
        </member>
        <member name="T:NMotive.FBXBinaryExporter">
            <summary>
Class for exporting take data in FBX binary format.
</summary>
        </member>
        <member name="M:NMotive.CSVExporter.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="filename">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.CSVExporter.WriteHeader">
            <summary>
Gets and sets the write header property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.RotationType">
            <summary>
Gets and sets the rotation type. Default is Quaternion.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteQualityStats">
            <exclude />
            <summary>
Gets and sets the write quality statistics property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteBoneMarkers">
            <summary>
Gets and sets the write bone markers property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteBones">
            <summary>
Gets and sets the write bones property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteRigidBodyMarkers">
            <summary>
Gets and sets the write rigid body markers property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteRigidBodies">
            <summary>
Gets and sets the write rigid bodies property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteMarkers">
            <summary>
Gets and sets the write markers property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.UseWorldSapceCoordinates">
            <summary>
Gets and sets the property determining whether or not to use world
coordinates.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in CSV export. Default value is meters.
</summary>
        </member>
        <member name="M:NMotive.CSVExporter.#ctor">
            <summary>
Constructs a <c>CSVExporter</c> object with the default options.
</summary>
        </member>
        <member name="T:NMotive.CSVExporter">
            <summary>
Class for exporting take files to CSV (Comma Separated Value) format.
</summary>
        </member>
        <member name="T:NMotive.Rotation">
            <summary>
Enumeration of possible rotation options.
</summary>
        </member>
        <member name="F:NMotive.Rotation.ZYX">
            <summary>zyx rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.ZXY">
            <summary>zxy rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.YZX">
            <summary>yzx rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.YXZ">
            <summary>yxz rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.XZY">
            <summary>xzy rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.XYZ">
            <summary>xyz rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.QuaternionFormat">
            <summary>Rotations in quaternion format.</summary>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
Trajectorizes a set of frame ranges in a take.
</summary>
            <param name="take">Take to trajectorize.</param>
            <param name="frameRanges">A set of frame ranges to trajectorize.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take)">
            <summary>
Trajectorizes the given take.
</summary>
            <param name="take">Take to trajectorize.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take,NMotive.FrameRangeSet,NMotive.TrajectorizerOption)">
            <summary>
Trajectorizes the given take according to the given processing option.
</summary>
            <param name="take">Take to trajectorize.</param>
            <param name="frameRanges">A set of frame ranges to trajectorize.</param>
            <param name="processingOption">Reconstruct, auto label, or both.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take,NMotive.TrajectorizerOption)">
            <summary>
Trajectorizes the given take according to the given processing option.
</summary>
            <param name="take">Take to trajectorize.</param>
            <param name="processingOption">Reconstruct, auto label, or both.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.#ctor(NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>Trajectorizer</c> instance that uses the given 
progress indicator to report progress.
</summary>
            <param name="progress">This progress indicator will be used to report
trajectorization progress.</param>
        </member>
        <member name="M:NMotive.Trajectorizer.#ctor">
            <summary>
Constructs a <c>Trajectorizer</c> instance.
</summary>
        </member>
        <member name="M:NMotive.Trajectorizer.#cctor">
            <exclude />
        </member>
        <member name="T:NMotive.Trajectorizer">
            <summary>
Class for performing trajectorization of the 2D data in a take to
produce 3D data.
</summary>
        </member>
        <member name="T:NMotive.TrajectorizerOption">
            <summary>
Enumeration of trajectorizer take processing.
</summary>
        </member>
        <member name="F:NMotive.TrajectorizerOption.ReconstructAndAutoLabel">
            <summary>Reconstruct and auto-label.</summary>
        </member>
        <member name="F:NMotive.TrajectorizerOption.AutoLabel">
            <summary>Auto-label only.</summary>
        </member>
        <member name="F:NMotive.TrajectorizerOption.Reconstruct">
            <summary>Reconstruct only. Do not label.</summary>
        </member>
        <member name="M:MoCapCore.cReconstructionPropertySet.ReconstructionBounds">
            <summary>Calculate the reconstruction volume based on shape type, etc.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.ClearLibrary">
            <summary>
Clear (and delete) the static library of stored collection definitions. This allows an application
to tear down any collection definitions that have been stored up during application execution.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.FindInLibrary(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Find a definition in the collection library, if it exists. If it is not found (perhaps ClearLibrary()
has been called), an invalid shared pointer is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.FindInLibrary(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Find a definition in the collection library, if it exists. If it is not found (perhaps ClearLibrary()
has been called), an invalid shared pointer is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.AddToLibrary(std.shared_ptr&lt;MoCapCore.cPropertyCollectionDefinition&gt;)">
            <summary>
Add a definition collection to the static list of available collections. This is a convenient
way to keep a reference to the definition available for creation of instances. The library can
be cleared so that definitions can be torn down by calling ClearLibrary().
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.CreateProperties(std.vector&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;,std.allocator&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;&gt;&gt;*,System.Boolean)">
            <summary>Create an instance of each of the properties in the definition and add it to the passed array.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.CreateInstance(System.Boolean)">
            <summary>Create a new cPropertyCollection instance from this definition.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.AddDefinition(std.unique_ptr&lt;MoCapCore.cPropertyDefinition,std.default_delete&lt;MoCapCore.cPropertyDefinition&gt;&gt;,System.Boolean)">
            <summary>
Add a new property definition to this collection. The collection takes ownership of the PropertyDefinition
object at this point. Property definitions can only be added to a group once.
</summary>
            <param name="def">The new definition. Ownership of the pointer will be assumed by the collection.</param>
            <param name="replaceExisting">If true and there exists a definition with the same name, the old definition
will be removed and replaced with the new one. Otherwise the old one will not be removed and the new 
definition will not be added.</param>
            <returns>True if the property was unique within the group and added successfully.</returns>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.ID">
            <summary>A cUID used to uniquely identify this definition.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.Name">
            <summary>Retrieve the name of this definition collection.</summary>
        </member>
        <member name="T:MoCapCore.cPropertyCollectionDefinition">
            <summary>
A grouping of parameter definitions that simplifies the task of creating and maintaining parameter
blocks.
</summary>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Trims tails of the given markers in the given frame ranges in the given take.
</summary>
            <param name="take">The take to process.</param>
            <param name="markerIDs">Trim tails on these markers only.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
Trims tails of the given markers in the given frame ranges in the given take.
</summary>
            <param name="take">The take to process.</param>
            <param name="selectedRanges">Trim tails in these ranges only.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take,NMotive.FrameRangeSet,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Trims tails of the given markers in the given frame ranges in the given take.
</summary>
            <param name="take">The take to process.</param>
            <param name="selectedRanges">Trim tails in these ranges only.</param>
            <param name="markerIDs">Trim tails on these markers only.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take)">
            <summary>
Trims tails in the given take.
</summary>
            <param name="take">The take to process.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="P:NMotive.TrimTails.Automatic">
            <summary>
If true the trimming algorithm will determine the number of frames
to trim. The set the maximum number of frames the algorithm is 
allowed to tr
</summary>
        </member>
        <member name="P:NMotive.TrimTails.MinimumSegmentSize">
            <summary>
When trimming tails, the tool will make sure that data segments 
(i.e. sections of data with no gaps) are not reduced below this 
number of frames. Default value is 5.
</summary>
        </member>
        <member name="P:NMotive.TrimTails.TrailingTrimSize">
            <summary>
The number of frames to trim at the end of any gaps, or the 
maximum number of frames to trim at the end of any gaps when the 
</summary>
        </member>
        <member name="P:NMotive.TrimTails.LeadingTrimSize">
            <summary>
The number of frames to trim at the beginning of any gaps, or the 
maximum number of frames to trim at the beginning of any gaps when the 
</summary>
        </member>
        <member name="P:NMotive.TrimTails.GapSizeThreshold">
            <summary>
Gets and sets the gap size threshold.
When trimming tails, a gap must be at least this large before any
trimming will be done on its leading or trailing edge.
</summary>
        </member>
        <member name="M:NMotive.TrimTails.#ctor">
            <summary>
Constructs a <c>TrimTails</c> instance with default values.
</summary>
        </member>
        <member name="F:NMotive.TrimTails.mNaitveDeleteKeys">
            <exclude />
            <summary>
Backing native implementation for delete keys.
</summary>
        </member>
        <member name="F:NMotive.TrimTails.mNativeFindTails">
            <exclude />
            <summary>
Backing native implementation for find tails.
</summary>
        </member>
        <member name="T:NMotive.TrimTails">
            <summary>
As markers pass into and out of view of the cameras, sometimes those 
partial occlusions can introduce "tails" in a trajectory near data 
gaps. The <c>TrimTails</c>class finds and removes these tails.
</summary>
        </member>
        <member name="T:MoCapCore.cDeleteKeysAction">
            <summary>
Deletes all selected keys on selected nodes, optionally only in selected time ranges.
</summary>
        </member>
        <member name="T:MoCapCore.cFindTailsAction">
            <summary>
Trim keys that may be noisy near the start or end of a gap.
</summary>
        </member>
        <member name="P:NMotive.Joint.ActiveDOFs">
            <summary>
Gets the active degrees of freedom.
</summary>
        </member>
        <member name="M:NMotive.Joint.#ctor(MoCapCore.cBoneNode*)">
            <exclude />
        </member>
        <member name="F:NMotive.Joint.DOF.AllDOF">
            <summary>
X translation, plus Y translation, plus Z translation, plus
X rotation, plus Y rotation, plus Z rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.AllRot">
            <summary>
X rotation, plus Y rotation, plus Z rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.AllTrans">
            <summary>
X translation, plus Y translation, plus Z translation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.ZRot">
            <summary>
Z rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.YRot">
            <summary>
Y rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.XRot">
            <summary>
X rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.ZTrans">
            <summary>
Z translation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.YTrans">
            <summary>
Y translation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.XTrans">
            <summary>
X translation.
</summary>
        </member>
        <member name="T:NMotive.Joint.DOF">
            <summary>
Enumeration of degrees of freedom
</summary>
        </member>
        <member name="T:NMotive.Joint">
            <summary>
Class for representing joint nodes in a scene.
</summary>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
 Apply the filter to the all the markers in the given frame ranges in
the given take.
</summary>
            <param name="take">Take to filter.</param>
            <param name="selectedRanges">Data will be filtered in these ranges.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take,NMotive.FrameRangeSet,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
 Apply the filter to the given markers in the given frame ranges in
the given take.
</summary>
            <param name="take">Take to filter.</param>
            <param name="selectedRanges">Data will be filtered in these ranges.</param>
            <param name="markerIDs">ID's of the markers to filter.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Apply the filter to the given markers in all the frames of the 
given take.
</summary>
            <param name="take">Take to filter.</param>
            <param name="markerIDs">ID's of the markers to filter.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take)">
            <summary>
Apply the filter to all markers in all the frames of the 
given take.
</summary>
            <param name="take">Take to filter.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="P:NMotive.Filter.CutOffFrequency">
            <summary>
Cutoff frequency in Hz for this filter. Default is 15.
</summary>
        </member>
        <member name="P:NMotive.Filter.DataRate">
            <summary>
Gets and sets the data rate property for this filter. Default
is 120.
</summary>
        </member>
        <member name="M:NMotive.Filter.#ctor(System.Double,System.Double)">
            <summary>
Constructs a <c>Filter</c> object with the given data rate and 
cutoff frequency.
</summary>
            <param name="dataRate">The data rate.</param>
            <param name="cutoffFrequency">The cutoff frequency for the filter.</param>
        </member>
        <member name="M:NMotive.Filter.#ctor">
            <summary>
Constructs a <c>Filter</c> object with default cutoff frequency
and data rate.
</summary>
        </member>
        <member name="T:NMotive.Filter">
            <summary>
Smooths 3D data by passing it through a low pass filter.
The lower the cutoff frequency setting, the more smoothed the data will
be.  High frequencies are present during sharp transitions in the data, 
such as foot-plants, but can also be introduced by noise in the data. 
Commonly used ranges for Filter Cutoff Frequency are 7-12 Hz, but you 
may want to adjust that up for fast, sharp motions to avoid softening 
transitions in the motion that need to stay sharp.
</summary>
        </member>
        <member name="T:MoCapCore.cFilterAction">
            <summary>
Either change the label of the passed marker, or combine it with an existing marker in the scene if
one already exists.
</summary>
        </member>
        <member name="M:NMotive.TakeMetadata.Finalize">
            <exclude />
        </member>
        <member name="M:NMotive.TakeMetadata.Dispose">
            <exclude />
        </member>
        <member name="M:NMotive.TakeMetadata.HasData(NMotive.Take.DataType)">
            <summary>
Returns <c>true</c> if this take contains the given
data type.
</summary>
            <param name="dataType">The type of data.</param>
            <returns>
                <c>true</c> if this take contains the given data type.</returns>
        </member>
        <member name="M:NMotive.TakeMetadata.HasGaps">
            <summary>
Checks if the take has gaps.
</summary>
            <returns>
                <c>true</c> if the take has gaps.</returns>
        </member>
        <member name="P:NMotive.TakeMetadata.Best">
            <summary>
Gets the "best" property of the take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.Scene">
            <summary>
Access to the contained NodeWarehouse
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FileName">
            <summary>
Gets the name of the file associated with the take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FullFrameRange">
            <summary>
Gets the full frame range for the take as a frame range.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FullTimeRange">
            <summary>
Gets the full time range for the take as a tuple where the first member 
is the start time and the second member is the end time.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FrameTime">
            <summary>
Gets the master frame time (in seconds per frame).
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.Notes">
            <summary>
Gets the notes field for this take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.Name">
            <summary>
Gets the name for this take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FrameRate">
            <summary>
Gets the frame rate for this take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.ID">
            <summary>
Gets the unique ID for this take.
</summary>
        </member>
        <member name="M:NMotive.TakeMetadata.#ctor(System.String)">
            <summary>
Constructs a <c>TakeMetadata</c> from the given take file.
</summary>
            <param name="takeFilePath">Take file path.</param>
        </member>
        <member name="F:NMotive.TakeMetadata.mSession">
            <exclude />
        </member>
        <member name="F:NMotive.TakeMetadata.mNativeStreamWarehouse">
            <exclude />
        </member>
        <member name="F:NMotive.TakeMetadata.mNativeTake">
            <exclude />
        </member>
        <member name="T:NMotive.TakeMetadata">
            <summary>
Contains read-only meta data for a take. Construction of objects of type
<c>TakeMetadata</c> is more efficient than contructing full <c>Take</c> objects.
If you want to access read-only information about a take without doing any processing
or editing, prefer the <c>TakeMetadata</c> class as it is much faster.
</summary>
        </member>
        <member name="T:MoCapCore.cStructuredStreamWarehouse">
            <summary>
A full implementation of the cIDataStreamWarehouse interface that implements a files-within-a-file structure.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouseFactory.TypeName">
            <summary>
Type name for stream warehouse instances created by this factory. This is just the name that will
be used to request instances, and does not necessarily have to correspond to the class name.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouseFactory.CreateInstance">
            <summary>
Creates a new instance of a requested cIDataStreamWarehouse type. Ownership of the newly created 
instance is transferred to the caller.
</summary>
        </member>
        <member name="T:MoCapCore.cIDataStreamWarehouseFactory">
            <summary>
Abstract base class for all cDataStreamWarehouse factories.
</summary>
        </member>
        <member name="M:MoCapCore.cDataStreamWarehouse.AddStream(MoCapCore.cIDataStream*)">
            <summary>Concrete implementations should call this method at the end of OpenStream
to add a new stream to the list of open streams.
</summary>
        </member>
        <member name="M:MoCapCore.cDataStreamWarehouse.CloseAllStreams">
            <summary>Close any open streams.</summary>
        </member>
        <member name="T:MoCapCore.cDataStreamWarehouse">
            <summary>
A partial implementation of the cIDataStreamWarehouse interface to use as a base class for
concrete implementations.
</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.Clear">
            <summary>Clear all factories and aliases.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.FindFactory(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the factory of the given type.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.CreateNode(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create a new node of the given type name.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.AddTypeAlias(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a type name alias (usually for legacy purposes) that will map an alias to an existing
type name. The type name must already exist in the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.AddFactory(std.unique_ptr&lt;MoCapCore.cINodeFactory,std.default_delete&lt;MoCapCore.cINodeFactory&gt;&gt;)">
            <summary>Add a factory to the warehouse. Ownership is transferred here.</summary>
        </member>
        <member name="T:MoCapCore.cINodeFactoryWarehouse">
            <summary>Interface class that provides ability to create node instances of named class types.</summary>
        </member>
        <member name="M:MotiveCore.cCameraFrameFactory.CreateInstance">
            <summary>Create a new instance of a camera frame.</summary>
        </member>
        <member name="M:NMotive.C3DExporter.SetAxisMotionBuilderCompatible">
            <summary>
Sets the axis mapping to be motion builder compatible.
X-axis -&gt; negative X-axis
Y-axis -&gt; negative Z-axis
Z-axis -&gt; positive Y-axis
</summary>
        </member>
        <member name="M:NMotive.C3DExporter.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="filename">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.C3DExporter.MarkerNameSyntax">
            <summary>
Gets and sets a property for marker naming in the exported data.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.ColonNameSeparator">
            <summary>
Gets and sets the property for determining if the marker name separator
is a colon or an underscore. If true colons will be used, if false 
underscores will be used.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.ZAxis">
            <summary>
Gets and sets translations for movement along the z-axis for C3D export.
Default is positive y-axis.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.YAxis">
            <summary>
Gets and sets translations for movement along the y-axis for C3D export.
Default is negative z-axis.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.XAxis">
            <summary>
Gets and sets translations for movement along the x-axis for C3D export.
Default is negative x-axis.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in C3D export. Default value is meters.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.UseTimeCode">
            <summary>
Gets and sets the use time code property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.WriteFingerTipMarkers">
            <summary>
Gets and sets the export fingertip markers property.
If <c>true</c> synthetic fingertip markers generated by the solver 
will be exported. The default is <c>false</c></summary>
        </member>
        <member name="P:NMotive.C3DExporter.RenameUnlabeledMarkers">
            <summary>
Gets and sets the rename unlabeled markers property.
Renames unlabeled markers as "_000X". Default is <c>false</c></summary>
        </member>
        <member name="P:NMotive.C3DExporter.WriteUnlabeledMarkers">
            <summary>
Gets and sets export unlabeled markers property. The default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.UseZeroBasedFrameIndex">
            <summary>
Gets and sets a boolean indicating whether frame indexing in the output
C3D file should be ones base or zero based. The default is 
<c>true</c> - zero based.
</summary>
            <remarks>
Zero based is the convention for MotionBuilder. Ones based is per C3D
Specification.
</remarks>
        </member>
        <member name="M:NMotive.C3DExporter.#ctor">
            <summary>
Constructs a <c>C3DExporter</c> object with the default options.
</summary>
        </member>
        <member name="F:NMotive.C3DExporter.C3DMarkerNameSyntax.NoAssetPrefix">
            <summary>
No separator
</summary>
        </member>
        <member name="F:NMotive.C3DExporter.C3DMarkerNameSyntax.Underscore">
            <summary>
Name separator is '_'
</summary>
        </member>
        <member name="F:NMotive.C3DExporter.C3DMarkerNameSyntax.Colon">
            <summary>
Name separator is a ':'
</summary>
        </member>
        <member name="T:NMotive.C3DExporter.C3DMarkerNameSyntax">
            <summary>
Marker naming syntax options. The name separator will be used to separate the
asset name and the corresponding marker name in the exported data.
</summary>
        </member>
        <member name="T:NMotive.C3DExporter">
            <summary>
Class for exporting take files to C3D format.
</summary>
        </member>
        <member name="T:MotiveCore.cC3DExporter">
            <summary>
Exporter class for C3D files
</summary>
        </member>
        <member name="M:SkeletonSolver.CSkeletonSolver.ProcessTrajectories(System.Int32,SkeletonSolver.CLocalizeLabelHelper*,System.Single,System.Int32,System.Single,System.Boolean,System.Boolean,System.Boolean)">
iMaxMissingFrameToConnect:  Labels a marker if there is a candidate within iMaxMissingFrameToConnect frames.
fMaxFrameToFrameDist:       Labels a marker if the distance from the previous frame is less than this value.
</member>
        <member name="M:Core.cRayBundle.AverageRayLength(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Calculates the average ray length of all rays contributing to the given marker.</summary>
        </member>
        <member name="M:Core.cRayBundle.ReconstructionRayCount(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the number of assigned rays present for the given reconstruction.</summary>
        </member>
        <member name="M:Core.cRayBundle.HasReconstructionRays(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if there are assigned rays present for the given reconstruction.</summary>
        </member>
        <member name="M:Core.cRayBundle.ReconstructionRays(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Return an iterator pair for the rays that contribute to the given reconstruction.</summary>
        </member>
        <member name="M:Core.cRayBundle.HasUnassignedRays">
            <summary>Returns true if there are assigned rays present.</summary>
        </member>
        <member name="M:Core.cRayBundle.UnassignedRays">
            <summary>Retrieve begin/end iterators for the unassigned rays (rays that are NOT assigned to markers).</summary>
        </member>
        <member name="M:Core.cRayBundle.HasAssignedRays">
            <summary>Returns true if there are assigned rays present.</summary>
        </member>
        <member name="M:Core.cRayBundle.AssignedRays">
            <summary>Retrieve begin/end iterators for the assigned rays (rays that are assigned to markers).</summary>
        </member>
        <member name="M:Core.cRayBundle.HasRays">
            <summary>Returns true if there are rays present.</summary>
        </member>
        <member name="M:Core.cRayBundle.AllRays">
            <summary>Retrieve begin/end iterators for the full ray list.</summary>
        </member>
        <member name="M:Core.cRayBundle.SetRaysPresorted(std.vector&lt;Core.cCameraRay,std.allocator&lt;Core.cCameraRay&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Populate the rays for this frame instance. The passed array is a non-const reference
because it will be swapped with the internal array and cleared on return, without freeing memory.
That will allow memory to be reused when possible.

This array is presorted by cUID for tracked rays with untracked rays following.
</summary>
        </member>
        <member name="M:Core.cRayBundle.SetRays(std.vector&lt;Core.cCameraRay,std.allocator&lt;Core.cCameraRay&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Populate the rays for this frame instance. The passed array is a non-const reference
because it will be swapped with the internal array and cleared on return, without freeing memory.
That will allow memory to be reused when possible.
</summary>
        </member>
        <member name="M:Core.cRayBundle.op_Assign(Core.cRayBundle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Assignment operator.</summary>
        </member>
        <member name="T:Core.cRayBundle">
            <summary>
A container class that holds a collection of rays and caches some state information on them
for fast computational access to lists of markers that meet certain criteria.
</summary>
        </member>
        <member name="M:Core.cCameraRay.Residual">
            <summary>Distance from this ray to the marker it contributes to. Zero if no marker is associated.</summary>
        </member>
        <member name="M:Core.cCameraRay.IsTracked">
            <summary>Tracked ray. This signifies that the ray intersects one or more other rays that has resulted in a 
3D marker reconstruction.</summary>
        </member>
        <member name="M:Core.cCameraRay.op_LessThan(Core.cCameraRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Comparison operators. Used mostly for sorting.</summary>
        </member>
        <member name="M:Core.cCameraRay.Equals(Core.cCameraRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this ray instance is identical to the given instance.</summary>
        </member>
        <member name="M:Core.cCameraRay.LengthSquared">
            <summary>Ray length.</summary>
        </member>
        <member name="M:Core.cCameraRay.Direction">
            <summary>3D ray direction.</summary>
        </member>
        <member name="M:Core.cCameraRay.Origin">
            <summary>3D ray origin.</summary>
        </member>
        <member name="M:Core.cCameraRay.ImageArea">
            <summary>Retrieves the (pixel) base area in the camera image.</summary>
        </member>
        <member name="M:Core.cCameraRay.ImagePosition">
            <summary>Retrieve the 2D image position in the camera image.</summary>
        </member>
        <member name="M:Core.cCameraRay.MarkerID">
            <summary>The ID of the marker that this ray is assigned to, or cUID::kInvalid if none.</summary>
        </member>
        <member name="M:Core.cCameraRay.SetMarkerID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the assigned marker ID.</summary>
        </member>
        <member name="M:Core.cCameraRay.CameraSerial">
            <summary>Retrieve the serial number of the camera from which this ray originated.</summary>
        </member>
        <member name="M:Core.cCameraRay.ID">
            <summary>The (unique among rays) ID for this ray.</summary>
        </member>
        <member name="T:Core.cCameraRay">
            <summary>
A class representing a ray that emanates from a camera, and may be assigned to a 3D marker reconstruction.
</summary>
        </member>
        <member name="M:NMotive.TRCExporter.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="filename">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.TRCExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in C3D export. Default value is meters.
</summary>
        </member>
        <member name="M:NMotive.TRCExporter.#ctor">
            <summary>
Constructs a <c>TRCExporter</c> object with the default options.
</summary>
        </member>
        <member name="T:NMotive.TRCExporter">
            <summary>
Class for exporting take files to TRC format.
</summary>
        </member>
        <member name="M:MotiveCore.cTRCExporter.SetScale(System.Single,System.Boolean)">
            <summary>Sets the scale factor used for exporting values.</summary>
            <param name="s">The scale factor to apply to exported
values. Must a decimal value be between 0 and 1.</param>
        </member>
        <member name="M:MotiveCore.cTRCExporter.Scale">
            <summary>Gets the scale factor used for exporting values.</summary>
            <returns>The scale as a decimal between 0 and 1.</returns>
        </member>
        <member name="M:MotiveCore.cTRCExporter.SetUnits(Core.eUnits!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Sets the value of the property.
Units of position measurement.</summary>
            <param name="unitsValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cTRCExporter.Units">
            <summary>Gets the value of the property.
Units of position measurement.</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Processes the given take, filling gaps for the specified markers.
</summary>
            <param name="take">The take to process.</param>
            <param name="markerIDs">Fill gaps for these markers. For pattern
based interpolation it is the list of pattern markers with the 
target marker being the first in the list. i.e. <c>markerIDs[0]</c></param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
Processes the given take, filling gaps for the specified markers in the
specified ranges.
</summary>
            <param name="take">The take to process.</param>
            <param name="frameRanges">Fill gaps in these frame ranges.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take,NMotive.FrameRangeSet,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Processes the given take, filling gaps for the specified markers in the
specified ranges.
</summary>
            <param name="take">The take to process.</param>
            <param name="frameRanges">Fill gaps in these frame ranges.</param>
            <param name="markerIDs">Fills gaps for these markers. For pattern
based interpolation it is the list of pattern markers with the 
target marker being the first in the list. i.e. <c>markerIDs[0]</c></param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take)">
            <summary>
Processes the given take. Fill is done for all markers and all frames.
</summary>
            <param name="take">The take to process.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="P:NMotive.FillGaps.CustomFillProvider">
            <exclude />
        </member>
        <member name="P:NMotive.FillGaps.MaxGapFillWidth">
            <summary>
Gets and sets the maximum size, in frames, 
that a gap can be for Motive to fill. Raising this will allow 
larger gaps to be filled. However, larger gaps may be more prone to 
incorrect interpolation.
</summary>
        </member>
        <member name="P:NMotive.FillGaps.InterpolationMode">
            <summary>
Gets and sets the interpolation algorithm for gap filling.
</summary>
        </member>
        <member name="M:NMotive.FillGaps.#ctor(System.Int32,NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>FillGaps</c> object the given max gap fill width and progress
indicator.
</summary>
            <param name="maxGapFillWidth">The maximum size, in frames, 
that a gap can be for Motive to fill. Raising this will allow 
larger gaps to be filled. However, larger gaps may be more prone to 
incorrect interpolation.</param>
            <param name="progress">Progress indicator used by this processor.</param>
        </member>
        <member name="M:NMotive.FillGaps.#ctor(System.Int32)">
            <summary>
Constructs a <c>FillGaps</c> object the given max gap fill width.
</summary>
            <param name="maxGapFillWidth">The maximum size, in frames, 
that a gap can be for Motive to fill. Raising this will allow 
larger gaps to be filled. However, larger gaps may be more prone to 
incorrect interpolation.</param>
        </member>
        <member name="M:NMotive.FillGaps.#ctor(NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>FillGaps</c> object with the given progress indicator.
</summary>
            <param name="progress">Progress indicator used by this processor.</param>
        </member>
        <member name="M:NMotive.FillGaps.#ctor">
            <summary>
Constructs a <c>FillGaps</c> object with default options.
</summary>
        </member>
        <member name="T:NMotive.FillGaps">
            <summary>
Take processor implementation for filling gaps in 3D data.
</summary>
        </member>
        <member name="T:NMotive.ICustomFillProvider">
            <exclude />
        </member>
        <member name="M:MoCapCore.cActionManager.SetProgressHandler(std.shared_ptr&lt;MoCapCore.cIProgressIndicator&gt;)">
            <summary>Set a progress indicator interface to use to report busy/progress.</summary>
        </member>
        <member name="M:MoCapCore.cIActionManagerObserver.OnAssignmentChanged(MoCapCore.cActionManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when any action assignment is changed.</summary>
        </member>
        <member name="M:MoCapCore.cIActionManagerObserver.OnActionListChanged(MoCapCore.cActionManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called after selection sets are added to or removed from the list.</summary>
        </member>
        <member name="T:MoCapCore.cIActionManagerObserver">
            <summary>
Derive from this class and add yourself as an observer to cActionManager to be notified when changes occur.
</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.DefaultProfileBackupFilename">
            <summary>Returns the full path to the backup file that will be written when the default profile
is updated.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.DefaultProfileName">
            <summary>Default user profile name, to use when starting up, and to save to when shutting down.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ProfileFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Composes the full path to the given profile name.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.AvailableProfiles(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <summary>Retrieve list of profile names that currently exist in the default profile path.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ProfilePath">
            <summary>Full path to where all system user profiles are stored.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ResetToDefault(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Reset the list profile subscriber with the given names to default.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ResetToDefault(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Reset the profile subscriber with the given name to default.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ResetToDefault">
            <summary>Reset profile subscribers to default.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load profile information for only the given subscriber type names from the given
profile file.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load profile information for only the given subscriber from the default profile file.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Load profile information for only the given subscriber from the given profile file.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load a profile from the given filename.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.SaveProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Save information for only the given subscriber type names to the given profile filename.
Any existing contents in the file will be replaced.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.SaveProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Save information for only the given subscriber type name to the given profile filename.
Any existing contents in the file will be replaced.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.SaveProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Save a profile to the given filename. For the methods that take one or more subscriber names,
the saved profile will only contain elements from the named subscribers.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.AllSubscribers(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIProfileSubscriber&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIProfileSubscriber&gt;&gt;&gt;*)">
            <summary>Retrieve a full list of subscribers.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.FindSubscriber(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Locate a subscriber by type name.</summary>
            <returns>Valid object if found, null otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cProfileManager.AddSubscriber(std.shared_ptr&lt;MoCapCore.cIProfileSubscriber&gt;)">
            <summary>Add a subscriber.</summary>
        </member>
        <member name="T:MoCapCore.cProfileManager">
            <summary>
Abstract base class for all nodes in a scene.
</summary>
        </member>
        <member name="M:MoCapCore.cIProfileManagerObserver.OnProfileLoaded(MoCapCore.cProfileManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the a profile is saved or loaded.
</member>
        <member name="T:MoCapCore.cIProfileManagerObserver">
            <summary>
Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.
</summary>
        </member>
        <member name="M:MoCapCore.cFillGapsAction.SetCustomFillProvider(std.unique_ptr&lt;MoCapCore.cICustomFillProvider,std.default_delete&lt;MoCapCore.cICustomFillProvider&gt;&gt;)">
            <summary>Set custom fill provider for pattern/model based fill.</summary>
        </member>
        <member name="T:MoCapCore.cFillGapsAction">
            <summary>
Fill gaps on based on the scoping and interpolation type specified in the operation's settings.
</summary>
        </member>
        <member name="T:MoCapCore.cStreamsManager">
            <summary>A concrete implementation of the the cIStreamsManager interface.</summary>
        </member>
        <member name="P:NMotive.RealMarker.KeyFrameRange">
            <summary>
Gets the keyframe range.
</summary>
        </member>
        <member name="P:NMotive.RealMarker.ChannelCount">
            <summary>
Gets the number of channels available.
</summary>
        </member>
        <member name="M:NMotive.RealMarker.HasChannel(NMotive.Channel.ChannelType)">
            <summary>
Returns true if a channel of the given type exists on this node.
</summary>
            <param name="channelType">Type of channel.</param>
            <returns>
                <c>true</c> if this node contains data for the
specified channel type.</returns>
        </member>
        <member name="M:NMotive.RealMarker.WorldTransform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full world coordinate transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine world transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.RealMarker.Transform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.RealMarker.Translation(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the local position at the given frame index.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>Local position of the frame index.</returns>
        </member>
        <member name="M:NMotive.RealMarker.SetTranslation(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.Vector3f)">
            <summary>
A convenience method for setting local translation. The default translation value will be set if no
animation channel exists.
</summary>
            <param name="frameIndex">Frame index to set value on.</param>
            <param name="val">The value to set.</param>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:NMotive.RealMarker.SetChannel(NMotive.Channel)">
            <summary>
Set one of the animation channels. Which channel gets set is governed by the Type()
of the given channel.
</summary>
            <param name="channel">The channel.</param>
            <returns>True if the given channel was a match for this node and was set as the translation channel.</returns>
        </member>
        <member name="M:NMotive.RealMarker.Clear">
            <summary>
Clear all animation data.
</summary>
        </member>
        <member name="M:NMotive.RealMarker.Clear(NMotive.FrameRange)">
            <summary>
Clear all animation data over the given range.
</summary>
            <param name="range">A range</param>
        </member>
        <member name="M:NMotive.RealMarker.IsKeyed(NMotive.FrameRange)">
            <summary>
Checks for the presence of keyed data in a give range.
</summary>
            <param name="range">A range.</param>
            <returns>Returns <c>true</c> if a transform key exists in the given range.</returns>
        </member>
        <member name="M:NMotive.RealMarker.IsKeyed">
            <summary>
Checks for the presence of keyed data.
</summary>
            <returns>Returns <c>true</c> if a transform key exists.</returns>
        </member>
        <member name="P:NMotive.RealMarker.TranslationChannel">
            <summary>
Gets the translation, or position, channel for this marker.
</summary>
            <returns>Translation channel for this marker.</returns>
        </member>
        <member name="P:NMotive.RealMarker.MarkerLabel">
            <summary>
Get this markers label.
</summary>
            <returns>
                <c>Label</c> for this marker. If the marker is not labeled the
returned label will be invalid, as indicated by the <c>Label</c>'s <c>Valid</c> property.</returns>
        </member>
        <member name="P:NMotive.RealMarker.IsLabeled">
            <summary>
Get the labeled status of this marker.
</summary>
            <returns>
                <c>true</c> if this is a labeled marker.</returns>
        </member>
        <member name="P:NMotive.RealMarker.Size">
            <summary>
Gets and sets the size of a marker.
</summary>
        </member>
        <member name="P:NMotive.RealMarker.Name">
            <summary>
Gets and sets the name for this node.
</summary>
        </member>
        <member name="M:NMotive.RealMarker.#ctor">
            <summary>
Constructs a default instance of a real marker.
</summary>
        </member>
        <member name="T:NMotive.RealMarker">
            <summary>
Class representing real marker objects in a scene.
</summary>
        </member>
        <member name="M:NMotive.Label.op_LessThan(NMotive.Label,NMotive.Label)">
            <summary>
Less than operator.
</summary>
            <param name="l1">A <c>Label</c> object.</param>
            <param name="l2">A <c>Label</c> object.</param>
            <returns>
                <c>true</c> if <c>l1</c> is less than <c>l2</c>.
</returns>
        </member>
        <member name="M:NMotive.Label.op_Inequality(NMotive.Label,NMotive.Label)">
            <summary>
Not equal operator.
</summary>
            <param name="l1">A <c>Label</c> object.</param>
            <param name="l2">A <c>Label</c> object.</param>
            <returns>
                <c>true</c> if <c>l1</c> is not equal to <c>l2</c>.
</returns>
        </member>
        <member name="M:NMotive.Label.op_Equality(NMotive.Label,NMotive.Label)">
            <summary>
Equality operator.
</summary>
            <param name="l1">A <c>Label</c> object.</param>
            <param name="l2">A <c>Label</c> object.</param>
            <returns>
                <c>true</c> if <c>l1</c> is equal to <c>l2</c>.
</returns>
        </member>
        <member name="P:NMotive.Label.Valid">
            <summary>
Returns true if this label is a valid label.
</summary>
        </member>
        <member name="P:NMotive.Label.MemberID">
            <summary>
Gets the label member ID within the entity.
</summary>
        </member>
        <member name="P:NMotive.Label.EntityID">
            <summary>
Gets he node ID for the entity that this label belongs to.
</summary>
        </member>
        <member name="T:NMotive.Label">
            <summary>
A class that represents a marker label. Marker labels consist of two parts: The entity that the marker
is associated with (e.g. skeleton, rigid body, etc.), and a member ID.
</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.IsCalibration">
            <summary>If it is used only during calibration.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.DisplayColor">
            <summary>Display color for the constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.RotationOffset">
            <summary>The target positional offset of the constraint from the constrained entity.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.PositionOffset">
            <summary>The target positional offset of the constraint from the constrained entity.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetRotationOffset(Core.cQuaternion&lt;System.Single,true&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the position offset.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetPositionOffset(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the position offset.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.Diameter">
            <summary>Diameter of this constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.Weight">
            <summary>Relative weight of this constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.ActiveTagID">
            <summary>The IMU tag ID, or -1 if no there is no associated Active Tag.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.ActiveID">
            <summary>The active ID, or 0 if passive</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.AttachmentID">
            <summary>The ID of the node this constraint is attached to.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetAttachmentID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the ID of the node this constraint is attached to.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetActiveID(System.UInt32)">
            <summary>Set the active ID</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetDisplayColor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
            <summary>Set the display color.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetDisplayColor(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the display color.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetDisplayColorToMacro(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the display color to Con.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetDiameter(System.Single)">
            <summary>Sets the constraint diameter.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.SetWeight(System.Single)">
            <summary>Sets the constraint weight.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.IsIMUConstraint">
            <summary>True if this is an IMU constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.IsMarkerConstraint">
            <summary>True if this is a marker constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.Is6DOF">
            <summary>True if this is a 6 DOF (rigid body) constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.Marker">
            <summary>Retrieve the marker associated with this constraint, or null if none.</summary>
        </member>
        <member name="M:MoCapCore.cConstraintNode.MemberID">
            <summary>The ID of this constraint. Must be unique within a given ILabelSource for marker constraints. Zero for 6-DOF (TODO). </summary>
        </member>
        <member name="M:MoCapCore.cIChannelFactoryWarehouse.Clear">
            <summary>Clear all factories and type aliases.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelFactoryWarehouse.AddTypeAlias(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a type name alias (usually for legacy purposes) that will map an alias to an existing
type name. The type name must already exist in the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelFactoryWarehouse.AddFactory(std.unique_ptr&lt;MoCapCore.cIChannelFactory,std.default_delete&lt;MoCapCore.cIChannelFactory&gt;&gt;)">
            <summary>Add a factory to the warehouse. Ownership is transferred here.</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Delete(System.String)">
            <summary>
Deletes the named entry. If it is a directory, entries are recursively
deleted from the given
path down.
</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Exists(System.String)">
            <summary>Check if the given path exists as a stream or directory.</summary>
            <returns>
                <c>true</c> if the given path is a stream or directory.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.IsDirectory(System.String)">
            <summary>Returns true if the given path in the storage is a directory.</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Entries(System.String)">
            <summary>Retrieve a list of all streams/directories at the given 
path in the storage.</summary>
            <param name="path">Storage path.</param>
            <returns>List of streams/directories at the given path in the storage.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.CloseStream(NMotive.DataStream)">
            <summary>Close a repository data stream.</summary>
            <returns>
                <c>true</c> if the stream was successfully closed.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.OpenStream(System.String,NMotive.DataStream.StreamOpenMode,System.Boolean)">
            <summary>
Open a stream in the storage repository. 
</summary>
            <param name="filename">The given filename is understood to be relative to the root
of the repository if preceded by a '/'. Otherwise, the path is understood to be relative to the
current working directory within the repository.</param>
            <param name="openMode">Stream open mode</param>
            <param name="binary">If binary is true, the stream is opened in binary mode. Otherwise, 
 it is opened in text mode.</param>
            <returns>null if the requested path is invalid, if the stream is already open, or if the stream
could not be opened with the requested mode.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.SetWorkingDirectory(System.String,System.Boolean)">
            <summary>
Sets the current working directory. The given path can be either absolute (e.g. "/fred/george")
or relative to the previous current working directory (e.g. "fred/george" or "../fred"). Unix-style
directory navigation is supported (i.e. use of ".." and "." in paths).
Returns false if the requested path does not exist.
</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Close">
            <summary>Close the warehouse. Open must be called again before 
using any other methods.</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Open(System.String,System.Boolean)">
            <summary>Open the warehouse for use. This must be called before using 
any other methods.</summary>
            <param name="path">Path to the warehouse file.</param>
            <param name="makeWriteable">If <c>true</c> makes the resulting data 
stream writeable.</param>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.IsWritable">
            <summary>Returns true if the storage is writable.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.HasOpenStreams">
            <summary>Returns true if there are open file handles in this 
repository.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.WorkingDirectory">
            <summary>Retrieves the current working directory.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.RootPath">
            <summary>Returns the file path/name where the warehouse 
resides.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.IsOpen">
            <summary>Returns true if the warehouse is currently open.</summary>
        </member>
        <member name="T:NMotive.DataStreamWarehouse">
            <summary />
            <exclude />
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Delete(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Deletes the named entry. If it is a directory, entries are recursively deleted from the given
path down.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Exists(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given path exists as a stream or directory.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.IsDirectory(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given path in the storage is a directory.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Entries(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve a list of all streams/directories at the given path in the storage.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.CopyStream(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copies the given stream into this warehouse at the requested file location.
Any stream of the same filename in the warehouse will be overwritten.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.CloseStream(MoCapCore.cIDataStream*)">
            <summary>Close a repository data stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.FindOpenStream(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>This method can be used to search for a stream that may already be open.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.OpenStream(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStream.eStreamOpenMode,System.Boolean)">
            <summary>
Open a stream in the storage repository. The given filename is understood to be relative to the root
of the repository if preceded by a '/'. Otherwise, the path is understood to be relative to the
current working directory within the repository.
If binary is true, the stream is opened in binary mode. Otherwise, it is opened in text mode.
Returns NULL if the requested path is invalid, if the stream is already open, or if the stream
could not be opened with the requested mode.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.IsWritable">
            <summary>Returns true if the storage is writable.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.HasOpenStreams">
            <summary>Returns true if there are open file handles in this repository.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.WorkingDirectory">
            <summary>Retrieves the current working directory.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.SetWorkingDirectory(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the current working directory. The given path can be either absolute (e.g. "/fred/george")
or relative to the previous current working directory (e.g. "fred/george" or "../fred"). Unix-style
directory navigation is supported (i.e. use of ".." and "." in paths).
Returns false if the requested path does not exist.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.RootPath">
            <summary>Returns the file path/name where the warehouse resides.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.IsOpen">
            <summary>Returns true if the warehouse is currently open.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Close">
            <summary>Close the warehouse. Open must be called again before using any other methods.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Open(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Open the warehouse for use. This must be called before using any other methods.</summary>
        </member>
        <member name="T:MoCapCore.cIDataStreamWarehouse">
            <summary>
A structured storage class that manages streams (usually files) within a repository. A repository can be
either a physical directory on the file system, or it can be a structured storage file that may contain
other files, or it can be something more abstract like a network connection to a remote asset stream.

All paths for this class should be given using the Unix-style path separator '/'.
</summary>
        </member>
        <member name="M:NMotive.FBXAsciiExporter.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="filename">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.OpticalMarkerNameSpace">
            <summary>
Overrides the default Optical Name Space for FBX.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.MarkerNameSeparator">
            <summary>
Chooses ':' or '_' for marker name separator.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.SkeletonNullsNames">
            <summary>
If the <c>WriteSkeletons</c> property is equal to <c>RigidBodyWriteNullsOptions::Named</c>,
then only skeletons whose names are in this list will be written to output.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.WriteSkeletonNulls">
            <summary>
Gets or sets a value indicating whether or not to write skeleton nulls.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.WriteMarkers">
            <summary>
Gets and sets the <c>WriteMarkers</c> property.
The default value is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.IsBinary">
            <summary>
Gets a property that is <c>strue</c> if the export format is binary.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.Extension">
            <summary>
Gets the conventional extension for files with this export format.
The extension does NOT include the '.'
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.Description">
            <summary>
Gets the description of this exporter.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.Name">
            <summary>
Gets the name of this exporter.
</summary>
        </member>
        <member name="M:NMotive.FBXAsciiExporter.#ctor">
            <summary>
Constructs an <c>FBXAsciiExporter</c> instance with default options.
</summary>
        </member>
        <member name="T:NMotive.FBXAsciiExporter">
            <summary>
Class for exporting take data to FBX ASCII format.
</summary>
        </member>
        <member name="M:NMotive.FBXExporter.GetRBNullsSettings(NMotive.Take)">
            <exclude />
        </member>
        <member name="M:NMotive.FBXExporter.GetFrameRateSettings(NMotive.Take)">
            <exclude />
            <summary>
Returns the appropriate frame rate based on current settings.
</summary>
            <param name="take">A take.</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetFrameRangeSettings(NMotive.Take)">
            <exclude />
            <summary>
Returns the appropriate frame range based on current settings.
</summary>
            <param name="take">A take.</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetSkeletonSettings(NMotive.Take,System.Boolean)">
            <exclude />
            <summary>
Sets export settings based on the the 
value of the <c>WriteSkeletons</c> property.
</summary>
            <param name="take">The take being written to FBX ASCII format.</param>
            <param name="writeSkeletonNulls">Do or don't write skeleton nulls</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetSkeletonSettings(NMotive.Take)">
            <exclude />
            <summary>
Sets export settings based on the the 
value of the <c>WriteSkeletons</c> property.
</summary>
            <param name="take">The take being written to FBX ASCII format.</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetSkeletons(NMotive.Take)">
            <exclude />
            <summary>
Gets the list of skeleton ID's to be written based on the the 
value of the <c>WriteSkeletons</c> property.
</summary>
            <param name="take">The take being written to FBX ASCII format.</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetSkeletons(NMotive.Take,System.Boolean)">
            <exclude />
            <summary>
Gets the list of skeleton ID's to be written based on the the 
value of the <c>WriteSkeletons</c> property.
</summary>
            <param name="take">The take being written to FBX ASCII format.</param>
            <param name="writeSkeletonNulls">Do or don't write skeleton nulls</param>
        </member>
        <member name="P:NMotive.FBXExporter.NameSeparator">
            <summary>
Options for marker name separator character.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.MarkerGapsAtOrigin">
            <summary>
Move marker gap positions to origin(X=0,Y=0,Z=0).
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteUnlabeledMarkers">
            <summary>
Export markers as selected type:  NoMarkers = 0, AsOpticals, AsNulls
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.UseTimeCode">
            <summary>
Gets and sets the property specifying whether or not to use the time code
The default value is <c>false</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteVirtualFingerTipMarkers">
            <summary>
Gets and sets the export virtual fingertip markers property.
If <c>true</c> synthetic fingertip markers generated by the solver 
will be exported. The default is <c>false</c></summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteMarkerNulls">
            <summary>
Gets and sets the property specifying whether or not to write out
null markers.
The default value is <c>false</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteRigidBodyNulls">
            <summary>
Gets or sets a value indicating whether or not to write rigid body nulls.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in FBX export. Default value is meters.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteSkeletons">
            <summary>
Gets and sets the property for determining which skeletons, if any are 
written output.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.RigidBodyNames">
            <summary>
If the <c>RigidBodyWriteNullsOptions</c> property is equal to <c>RigidBodyWriteNullsOptions::Named</c>,
then only rigid bodies whose names are in this list will be written to output.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.SkeletonNames">
            <summary>
If the <c>WriteSkeletons</c> property is equal to <c>SkeletonWriteOptions::Named</c>,
then only skeletons whose names are in this list will be written to output.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.Extension">
            <summary>
Gets the conventional extension for files with this export format.
The extension does NOT include the '.'
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.mNamedRigidBodies">
            <summary>
If the WriteSkeletons property is equal the Named, write out
the skeletons whose names are in this list.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.mNamedSkeletons">
            <summary>
If the WriteSkeletons property is equal the Named, write out
the skeletons whose names are in this list.
</summary>
        </member>
        <member name="M:NMotive.FBXExporter.#ctor">
            <summary>
Constructs an <c>FBXExporter</c> object with the <c>WriteSkeletons</c>
equal to None.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter.FBXMarkerExport">
            <summary>
Options for exporting occulded markers
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.MarkerNameSeparatorOptions.Underscore">
            <summary>
Use '_' for marker name separator.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.MarkerNameSeparatorOptions.Colon">
            <summary>
Use ':' for marker name separator.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter.MarkerNameSeparatorOptions">
            <summary>
Options for marker name separator character.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.Active">
            <summary>
Write all active skeletons in the take.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.Named">
            <summary>
Write skeletons whose names specified in the <c>SkeletonNames</c>
property.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.None">
            <summary>
Do not write skeletons.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.All">
            <summary>
Write all skeletons.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter.SkeletonWriteOptions">
            <summary>
Options for writing skeletons to the output file.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.Active">
            <summary>
Write all active rigid bodies in the take.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.Named">
            <summary>
Write rigid body rigidBodies whose names specified in the <c>RigidBodyNames</c>
property.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.None">
            <summary>
Do not write rigid body rigidBodies.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.All">
            <summary>
Write all rigid body rigidBodies.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter.RigidBodyWriteNullsOptions">
            <summary>
Options for writing skeletons to the output file.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter">
            <summary>
Base class for FBX exporters
</summary>
        </member>
        <member name="M:NMotive.Exporter.NativeToManaged(Core.eUnits)">
            <exclude />
        </member>
        <member name="M:NMotive.Exporter.ManagedToNative(NMotive.LengthUnits)">
            <exclude />
        </member>
        <member name="P:NMotive.Exporter.Scale">
            <summary>
Gets and sets the scale property.
Range from 0 to 1. Default is 1.
</summary>
        </member>
        <member name="P:NMotive.Exporter.FrameRate">
            <summary>
Gets and sets frame rate to export at. The default value is the 
class constant <c>DefaultFrameRate</c>. When set to this value the
export frame rate will be the same as the take frame rate.
</summary>
        </member>
        <member name="P:NMotive.Exporter.EndFrame">
            <summary>
Gets the index of the last frame to export. Frames in the range 
<c>StartFrame</c> to <c>EndFrame</c> will be exporterd. The default
value is the class constant <c>Exporter::DefaultEndFrame</c>. When 
<c>EndFrame</c> is set to this value the end frame will 
be the last frame in the take being exported.
</summary>
        </member>
        <member name="P:NMotive.Exporter.StartFrame">
            <summary>
Gets the index of the first frame to export. Frames in the range 
<c>StartFrame</c> to <c>EndFrame</c> will be exporterd. The default
value is the class constant <c>Exporter::DefaultStartFrame</c>. When 
<c>StartFrame</c> is set to this value the start frame will 
be the first frame in the take being exported.
</summary>
        </member>
        <member name="F:NMotive.Exporter.DefaultFrameRate">
            <summary>
Default frame rate to export at. When the property
<c>FrameRate</c> is set to this value the export frame rate will be
the same as the take frame rate.
</summary>
        </member>
        <member name="F:NMotive.Exporter.DefaultEndFrame">
            <summary>
Default end frame in the take to export.
When the <c>EndFrame</c> property is set to this value the end frame will 
be the last frame in the take being exported.
</summary>
        </member>
        <member name="F:NMotive.Exporter.DefaultStartFrame">
            <summary>
Default starting frame in the take to export.
When the <c>StartFrame</c> property is set to this value the start frame will 
be the first frame in the take being exported.
</summary>
        </member>
        <member name="T:NMotive.Exporter">
            <summary>
Base class from which all take Exporters derive.
</summary>
        </member>
        <member name="T:MotiveCore.cFBXExporter">
            <summary>
Exporter class for FBX files
</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.PostNotification(std.unique_ptr&lt;MoCapCore.cINotification,std.default_delete&lt;MoCapCore.cINotification&gt;&gt;)">
            <summary>Post a notification to the user.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Finish(System.Boolean)">
            <summary>Call this to finish a measured task.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.StackDepth">
            <summary>Retrieve the current progress stack depth.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SubMessage(System.Int32)">
            <summary>Gets the current sub message.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Message(System.Int32)">
            <summary>Gets the current message.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Progress(System.Int32)">
            <summary>Gets the current progress value.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.IsCanceled">
            <summary>If the user or app has requested that an operation be canceled before completing, it
will set this property through the SetCanceled() method. Operations should regularly check this
state to see if the user has requested a cancel.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SetCanceled">
            <summary>Set the canceled state. UI's use this method to allow the user or the app to cancel
a long-running operation. Operations should regularly check the IsCanceled() state to see if
the user has requested a cancel.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SetSubMessage(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the sub message to display to the user.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SetMessage(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the message to display to the user.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SetProgress(System.UInt32)">
            <summary>Called to update progress value directly. Progress is in the range [0,100].</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.IncrementProgress">
            <summary>Called to increase the progress by one increment.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Start(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>This is called to run the operation using the given progress indicator.</summary>
            <param name="message">A user-facing message to display during the task.</param>
            <param name="incrementCount">The number of progress increments that the task will take to complete.</param>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.ExtendedValues(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>extension of functionality</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.PostNotification(MoCapCore.cINotification.eSeverity,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Post a notification to the user.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.PostNotification(std.unique_ptr&lt;MoCapCore.cINotification,std.default_delete&lt;MoCapCore.cINotification&gt;&gt;)">
            <summary>Post a notification to the user.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Finish(System.Boolean)">
            <summary>Call this to finish a measured task.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.StackDepth">
            <summary>Retrieve the current progress stack depth.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SubMessage(System.Int32)">
            <summary>Gets the current sub message for the given stackIndex. If stackIndex is negative or invalid, 
the latest stack's sub message will be returned.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Message(System.Int32)">
            <summary>Gets the current message for the given stackIndex. If stackIndex is negative or invalid, 
the latest stack's message will be returned.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Progress(System.Int32)">
            <summary>Gets the current progress value for the given stackIndex, in the range [0,100].</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.IsCanceled">
            <summary>If the user or app has requested that an operation be canceled before completing, it
will set this property through the SetCanceled() method. Operations should regularly check this
state to see if the user has requested a cancel.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SetCanceled">
            <summary>Set the canceled state. UI's use this method to allow the user or the app to cancel
a long-running operation. Operations should regularly check the IsCanceled() state to see if
the user has requested a cancel.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SetSubMessage(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the sub message to display to the user.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SetMessage(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the message to display to the user.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SetProgress(System.Single)">
            <summary>Called to update progress value directly. Progress is in the range [0,100].</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.IncrementProgress">
            <summary>Called to increase the progress by one increment.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Start(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>This is called to run the operation using the given progress indicator.</summary>
            <param name="message">A user-facing message to display during the task.</param>
            <param name="totalSteps">The number of progress increments that the task will take to complete.</param>
        </member>
        <member name="T:MoCapCore.cIProgressIndicator">
            <summary>
Used to report progress of long-running operations. This object can (and should) be used to
recurse into call trees of long-running operations where it makes sense to track progress of
portions of an operation. Start() may be called multiple times before calling Finish(), but
all calls to Start() must be matched with a call to Finish().
There are two ways to report progress. Either call Start() with a non-zero incrementCount to
set the number of times that IncrementProgress() will be called before the task is finished, or
just call SetProgress() to set the progress value directly during task execution. To help make
progress indication more predictable, it is recommended that you use an increment count
whenever possible.
</summary>
        </member>
        <member name="M:MoCapCore.cINotification.Stringify">
            <summary>Called by the framework to serialize this notification to a single line text string for persistence.</summary>
        </member>
        <member name="M:MoCapCore.cINotification.Severity">
            <summary>The severity of the notification.</summary>
        </member>
        <member name="M:MoCapCore.cINotification.LatestTimeStamp">
            <summary>Time when the notification was initially emitted.</summary>
        </member>
        <member name="M:MoCapCore.cINotification.Description">
            <summary>A verbose description of the notification that should provide granular detail useful to the user
in resolving any issue.</summary>
        </member>
        <member name="M:MoCapCore.cINotification.Category">
            <summary>The unique name of the system or category to which this notification belongs. Any object can be a system
that emits notifications. It just needs to use a consistent, unique Category when emitting them.</summary>
        </member>
        <member name="M:MoCapCore.cINotification.ID">
            <summary>A unique ID among all notifications. This uses an int and fast generation rather than a cUID
object for performance.</summary>
        </member>
        <member name="M:MoCapCore.cINotification.Clone">
            <summary>Clone this notification to a new instance with the same data.</summary>
        </member>
        <member name="T:NMotive.DataStream">
            <exclude />
            <summary>
class for data streams, which can usually be thought of as files. Streams may exist
as files on disk, or as files within a file archive, or as resources accessible over a network
connection, or some other representation that is suitable for this interface. Data streams are
created and destroyed by cIDataStreamWarehouse implementations.
</summary>
        </member>
        <member name="M:NMotive.VideoExporter.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given file.
</summary>
            <param name="take">The take to export</param>
            <param name="filename">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="M:NMotive.VideoExporter.Export(NMotive.Take,NMotive.DataStream,NMotive.ProgressIndicator)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <param name="progress"> The progress indicator to receive progress notifactions.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="M:NMotive.VideoExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.VideoExporter.TimeCodeOverlayForMjpeg">
            <summary>
Gets and sets the timecode overlay when exporting to MJPEG 
(<c>ColorVideoFormat == ColorVideoFormatValue.MJPEG</c>). This property
is ignored when export format is <c>ColorVideoFormatValue.H264</c>.
</summary>
        </member>
        <member name="P:NMotive.VideoExporter.DroppedFrameBehavior">
            <summary>
Gets and sets the policy for exporting frames dropped during video recording.
The options are to just to not export the dropped frame or insert a black frame in its place.
Inserting black frames will keep the video data in sync with the Motion Capture data.
</summary>
        </member>
        <member name="P:NMotive.VideoExporter.PlaybackSpeed">
            <summary>
Gets and sets the playback rate for exported video.
Scales playback speed of the exported video. The time interval between 
each frame will be increased or decreased by this ratio, making 
the video length longer or shorter.
</summary>
        </member>
        <member name="P:NMotive.VideoExporter.ColorVideoFormat">
            <summary>
Gets and sets the format for exported color video.
</summary>
        </member>
        <member name="P:NMotive.VideoExporter.FrameRate">
            <summary>
Gets and sets the frame at which to export the video.
</summary>
        </member>
        <member name="M:NMotive.VideoExporter.#ctor(NMotive.VideoExporter.FrameRateValue)">
            <summary>
Constructs a video exporter object with the frame rate.
</summary>
            <param name="frameRate">Video will be exported at this frame rate.</param>
        </member>
        <member name="M:NMotive.VideoExporter.#ctor">
            <summary>
Constructs a video exporter object. Exported frame rate is full.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.DroppedFrameBehaviorValue.RepeatLastFrame">
            <summary>
Insert previous valid frame for the dropped frame when exporting. Video data remains in
sync with MoCap data.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.DroppedFrameBehaviorValue.BlackFrame">
            <summary>
Insert a black frame for the dropped frame when exporting. Video data remains in
sync with MoCap data.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.DroppedFrameBehaviorValue.DropFrame">
            <summary>
Skip dropped frames when exporting video data. Video will be 
out of sync with MoCap data.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.DroppedFrameBehaviorValue">
            <summary>
Options for exporting dropped frames from recorded video.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Eighth">
            <summary>
Playback at eighth speed
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Quarter">
            <summary>
Playback at quarter speed
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Half">
            <summary>
Playback at half speed
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Full">
            <summary>
Playback at full speed
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.PlaybackSpeedValue">
            <summary>
Values for scaling the playback speed of the exported video.
Each frame will be increased or decreased by this ratio, making 
the video length longer or shorter.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.ColorVideoFormatValue.MJPEG">
            <summary>
MJPEG video compression format.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.ColorVideoFormatValue.H264">
            <summary>
H.264 or MPEG-4 Part 10 video coding.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.ColorVideoFormatValue">
            <summary>
Supported exported color video file formats.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.FrameRateValue.Quarter">
            <summary>
Quarter frame rate.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.FrameRateValue.Half">
            <summary>
Half frame rate.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.FrameRateValue.Full">
            <summary>
Full frame rate.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.FrameRateValue">
            <summary>
Exporter frame rate values. Video can exported at full frame rate,
half frame rate, and quarter frame rate.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter">
            <summary>
Class for exporting video from a take to a file. Exported video format
is 'avi'. The take must contain video data for the exportation to be
successful.
</summary>
        </member>
        <member name="M:NMotive.ExporterBase.Export(NMotive.Take,System.String,System.Boolean)">
            <summary>
Exports the given take to the given file with option to overwrite existing
file.
</summary>
            <param name="take">The take to export</param>
            <param name="filePath">The path of the file to export to.</param>
            <param name="overwrite">If <c>true</c>, and the specified file exists
it will be overwritten. If <c>false</c> and the specified file exists
then the existing file will not be overwritten and the take will not be
exported. The <c>Success</c> property on the returned <c>Result</c> object
will be <c>false</c>. If the specified file does not exist this parameter has no affect.
</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="M:NMotive.ExporterBase.Export(NMotive.Take,System.String)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="filePath">The file to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.ExporterBase.Progress">
            <summary>
Gets/Sets the progress indicator used by this exporter.
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.Overwrite">
            <summary>
Gets/Sets a property that is <c>true</c> The exporter will overwrite existing file contents.
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.IsBinary">
            <summary>
Gets a property that is <c>true</c> if the export format is binary.
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.Extension">
            <summary>
Gets the conventional extension for files with this export format.
The extension does NOT include the '.'
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.Description">
            <summary>
Gets the description of this exporter.
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.Name">
            <summary>
Gets the name of this exporter.
</summary>
        </member>
        <member name="M:NMotive.ExporterBase.#cctor">
            <exclude />
        </member>
        <member name="F:NMotive.ExporterBase.mOverwrite">
            <exclude />
        </member>
        <member name="F:NMotive.ExporterBase.mNativeExporter">
            <exclude />
        </member>
        <member name="T:NMotive.ExporterBase">
            <summary>
Base class from which all take Exporters derive.
</summary>
        </member>
        <member name="T:MoCapCore.cIntPropertyValue">
            <summary>A property value represented by an integer value.</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.OpenFile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStream.eStreamOpenMode,System.Boolean)">
            <summary>Convenience method to open a new file stream with the given filename.</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.CreateWarehouse(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create a new stream warehouse of the requested type, if it exists. Returns NULL if the 
requested type is not available or cannot be created.
</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.CreateWarehouse">
            <summary>Create a warehouse of the default type.</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.SetDefaultWarehouseType(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the default warehouse type.</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.AddFactory(MoCapCore.cIDataStreamWarehouseFactory*)">
            <summary>Add a stream warehouse type factory. Ownership of the factory is transferred.</summary>
        </member>
        <member name="T:MoCapCore.cIStreamsManager">
            <summary>
Manager class for stream storage. This class aggregates stream warehouse types and has convenience
methods for creating and maintaining cIStreamWarehouse instances.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.IsEOF">
            <summary>Returns true if the stream position is at the end of the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Mode">
            <summary>Retrieves the access mode for the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.SetMode(MoCapCore.cIDataStream.eStreamOpenMode)">
            <summary>Set the access mode for the stream. Returns true if the mode could be set.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Flush">
            <summary>Flush any pending output to the storage media.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Write(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
            <summary>
Writes a block of data and advances the stream position. Writes up to byteCount bytes,
so the buffer must be at least byteCount bytes long.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Read(System.Byte*,System.UInt64)">
            <summary>
Reads up to byteCount bytes of data and advances the stream position. The buffer must be at
least byteCount bytes long. Returns the number of bytes actually read.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Seek(System.UInt64)">
            <summary>Seek to the requested (absolute) position in the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Tell">
            <summary>Returns the current position in the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Size">
            <summary>Returns the (current) full size of the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.FullName">
            <summary>
Returns the full stream name, including path. Stream names always use the '/' path separator.
To convert, you can use Filename::ConvertSeparators().
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Owner">
            <summary>Return the warehouse that owns this stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.IsOpen">
            <summary>Returns true if the stream is valid and open.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Open">
            <summary>Attempts to open the stream, if not already open.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Destroy">
            <summary>Call this method, not the destructor, to destroy cIDataStream instances.</summary>
        </member>
        <member name="T:MoCapCore.cIDataStream">
            <summary>
The interface class for data streams, which can usually be thought of as files. Streams may exist
as files on disk, or as files within a file archive, or as resources accessible over a network
connection, or some other representation that is suitable for this interface. Data streams are
created and destroyed by cIDataStreamWarehouse implementations.
</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.SetAllToDefaults">
            <summary>Reset all exporter properties to default.</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.FindExporterByName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to find an exporter by exporter name. Borrowed reference. DO NOT DELETE.</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.FindExporter(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Attempt to find an exporter that writes to the requested extension type. If more than one
matching exporter is found, only the first one is returned. Borrowed reference. DO NOT DELETE.
</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.Exporter(System.Int32)">
            <summary>Retrieves the exporter at the given index. Borrowed reference. DO NOT DELETE.</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.ExporterCount">
            <summary>Returns the number of available exporters.</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.AddExporter(std.unique_ptr&lt;MoCapCore.cIExporter,std.default_delete&lt;MoCapCore.cIExporter&gt;&gt;)">
            <summary>Add a new exporter type.</summary>
        </member>
        <member name="T:MoCapCore.cExporterManager">
            <summary>
Manages instances of cIExporter, along with the operations involving file exporting.
</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.MapToString(System.Int32)">
            <summary>Maps an error code from this exporter to a human-readable string value.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Export(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIProgressIndicator*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Export the given take using the given (open) stream. Exporters return 0 on success and a non-zero
value on failure. The return value can be mapped to a human-readable string using the MapToString
method.
</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.IsBinary">
            <summary>Should return true for exporters that expect to write data in binary format.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Properties">
            <summary>
Retrieve the property collection of options for this exporter.
</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Extension">
            <summary>Retrieve the file extension used by exporters of this type.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Description">
            <summary>Human-readable description of the file type this exporter creates.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Name">
            <summary>Brief name describing the exported type.</summary>
        </member>
        <member name="T:MoCapCore.cIExporter">
            <summary>Abstract base class for all exporters.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.DataFor(System.Int32)">
            <summary>Returns data for the device of the given serial number if it is present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.DataTypes">
            <summary>Returns which (eDataType) data types are present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.PrecisionTimestamp">
            <summary>Time code information. Will be flagged as valid if timecode was present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.TimeCode">
            <summary>Time code information. Will be flagged as valid if timecode was present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.AudioDataSize">
            <summary>Retrieve the analog data, if any.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.CameraFrameCount">
            <summary>Retrieve the device data, if any.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.MemorySize">
            <summary>Approximate size of this object in memory.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.SetAudioData(System.UInt32,System.Byte*)">
            <summary>Set the analog data for this frame, if any. Ownership of the passed pointer is transferred here.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.AddCameraFrame(Core.cICameraFrame*)">
            <summary>Add a device frame.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.Clone(std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,System.Int32)">
            <summary>Clone this instance, and optionally exclude the given data types.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,System.Int16)">
            <summary>Load this object from the given reader.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize this object to the given writer.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.UpdateNow">
            <summary>Runs the garbage collection and pre-fetch operation now rather than waiting for the next
wait interval to pass. Useful for clients that are just doing a temporary loading of frames to operate
on them, but do not want to have them remain in memory after that.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.SetBlockUnloadTimeThreshold(System.Double)">
            <summary>Set the time (in seconds) that frame blocks will be held in memory in between accesses.
Once this time threshold is exceeded, an unused block will be removed from memory.</summary>
        </member>
        <member name="T:MoCapCore.cMultiDeviceTrack.sCameraInfo">
            <summary>Adds to the given list of camera serial numbers that have data of the requested type(s).</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Name">
            <summary>Returns the track name</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Frame(System.Int32)">
            <summary>
Returns the frame at the given frame index. If no frame exists at that frame, a NULL frame is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.IsComplete">
            <summary>Returns true if the track is "complete" (i.e. if data has been recorded and the
mode of the track has been set to read-only.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Empty">
            <summary>Returns true if completely empty (no frames present).</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.FullTimecodeRange">
            <summary>Returns the full timecode range, or invalid values for timecode if no timecode data is present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.FullFrameRange">
            <summary>Returns full frame range, or an empty range if no data is present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.FullTimeRange">
            <summary>Returns full time range, or an empty range if no data is present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Load(System.Double)">
            <summary>Load initial contents, index tables, etc. from the input stream to prepare the object for use.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Save(System.Boolean)">
            <summary>Finish saving to the output stream, pushing any unsaved data.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Add(std.shared_ptr&lt;MoCapCore.cMultiDeviceFrame&gt;,Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Add a new multi-device frame. This should only be called during recording.</summary>
            <param name="writeBlockwise">
If true, blocks will be written out when kWriteBlockFrames have been added. Be careful
to set this option to false for real-time recording as it can block long enough during a block write
that one or more frames could be missed in recording.
</param>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.#ctor(MoCapCore.cIDataStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,System.Boolean)">
            <summary>
Create a new track. The readOnly parameter should be set to true if this track is being
loaded from a previously recorded track.
</summary>
        </member>
        <member name="T:MoCapCore.cMultiDeviceTrack">
            <summary>
A streaming container for camera and device data streams. This is a write-once, read-only container.
Once the track is saved using the Save() method, the track becomes read-only.
</summary>
        </member>
        <member name="M:Core.cStringHelpers.EndsWith(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Find if a string ends with a given string.</summary>
        </member>
        <member name="M:Core.cStringHelpers.StartsWith(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Find if a string starts with a given string.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ReplaceSubstring(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find and replace all occurrences of the given text</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimRight(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a wstring from end.</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimRight(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a string from end.</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimLeft(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a wstring from start.</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimLeft(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a string from start.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Trim(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a wstring.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Trim(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a string.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt64(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt64(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToLongDouble(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to a floating-point value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToDouble(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to a floating-point value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Tokenize(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
            <summary>Split a string into a vector of strings, removing the delimiter.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToUpper(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to all uppercase characters.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToLower(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to all lowercase characters.</summary>
        </member>
        <member name="M:Core.cStringHelpers.AreEqualNoCase(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Do a case-insensitive compare between two strings.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Format(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst,BTEllipsis)">
            <summary>Implementation of sprintf for strings.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Format(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst,BTEllipsis)">
            <summary>Implementation of sprintf for wstrings.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ConvertFromWString(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a (UTF-16) std::wstring to a (UTF-8) std::string.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ConvertToWString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a (UTF-8) std::string to a (UTF-16) std::wstring.</summary>
        </member>
        <member name="M:Core.cStringHelpers.AreDigits(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,System.UInt64)">
            <summary>Returns true if the characters in the given range are all numeric digits.</summary>
        </member>
        <member name="M:Core.cStringHelpers.IncrementName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Uses the standard method to increment the given name. The standard method looks for
(%d), and adds (2) if it is not found, and replaces it with (%d+1) if found.
</summary>
        </member>
        <member name="T:Core.cStringHelpers">
            <summary>A collection of platform-neutral string management routines.</summary>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Keyframe`1{NMotive.Quaternion}})">
            <summary>
Apply the filter to the given list of quaternion rotations.
</summary>
            <param name="vals">A list of quaternion rotations.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Keyframe`1{NMotive.Vector3f}})">
            <summary>
Apply the filter to the given list of key frame 3-D vectors.
</summary>
            <param name="vals">A list of key frame 3-D vectors.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Vector3f})">
            <summary>
Apply the filter to the given list of 3-D vectors.
</summary>
            <param name="vals">A list of 3-D vectors.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Keyframe`1{System.Single}})">
            <summary>
Apply the filter to the given key frames.
</summary>
            <param name="vals">A list of key frames.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{System.Single})">
            <summary>
Apply the filter to the given values.
</summary>
            <param name="vals">A list of values.</param>
        </member>
        <member name="P:NMotive.KeyframeDataFilter.CutoffFrequency">
            <summary>
Set the cut-off frequency (in Hz) for the filter.
</summary>
        </member>
        <member name="P:NMotive.KeyframeDataFilter.SampleRate">
            <summary>
Set the data rate (in Hz) to assume for all samples.
</summary>
        </member>
        <member name="P:NMotive.KeyframeDataFilter.Order">
            <summary>
Set the order of the filter. Must be an even integer in the range [2,6].
</summary>
        </member>
        <member name="T:NMotive.KeyframeDataFilter">
            <summary>
Builds an nth order Butterworth IIR filter, and allows setting of the cutoff frequency. The filter
order must be an even integer to allow backward and forward application of 1/2 nth order filters to
compensate for phase shift that would otherwise be introduced by only running the filter in the
forward direction. See MatLab's filtfilt for description.
This filter assumes that the keyframe data is contiguous (i.e. no gaps).
</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.Apply(std.vector&lt;System.Single,std.allocator&lt;System.Single&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Apply the filter to the given keys. Keys are assumed to be contiguous.</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.SetCutoffFrequency(System.Double)">
            <summary>Set the cutoff frequency (in Hz) for the filter.</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.SetSampleRate(System.Double)">
            <summary>Set the data rate (in Hz) to assume for all samples.</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.SetOrder(System.Int32)">
            <summary>Set the order of the filter. Must be an even integer in the range [2,6].</summary>
        </member>
        <member name="T:MoCapCore.cKeyframeDataFilter">
            <summary>
Builds an nth order Butterworth IIR filter, and allows setting of the cutoff frequency. The filter
order must be an even integer to allow backward and forward application of 1/2 nth order filters to
compensate for phase shift that would otherwise be introduced by only running the filter in the
forward direction. See MatLab's filtfilt for description.
This filter assumes that the keyframe data is contiguous (i.e. no gaps).
</summary>
        </member>
        <member name="M:NMotive.ITakeProcessingScript.ProcessTake(NMotive.Take,NMotive.ProgressIndicator)">
            <summary>
Process a take and, optionally, update progress.
</summary>
            <param name="takeToProcess">The take to process.</param>
            <param name="progress">Progress object that the process may
update with its progress.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="T:NMotive.ITakeProcessingScript">
            <summary>
Interface implemented by .NET scripts if they want to be run using the
Motive Batch Processor application. 
</summary>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearRigidBodyNodes">
            <summary>
Removes all rigid body nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearSkeletonNodes">
            <summary>
Removes all skeleton nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearMarkerSetNodes">
            <summary>
Removes all marker set nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearMarkerNodes">
            <summary>
Removes all marker nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearJointNodes">
            <summary>
Removes all joint nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.RemoveNode(System.String)">
            <summary>
Removes the first node found with the given name.
</summary>
            <param name="nodeName">Name of the node to remove.</param>
            <returns>
                <c>true</c> if a node with the given name was found and successfully removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.RemoveNode(NMotive.UID)">
            <summary>
Removes the node with the given ID.
</summary>
            <param name="nodeId">ID of the node to remove.</param>
            <returns>
                <c>true</c> if the node was found and successfully removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AddNode(NMotive.Node)">
            <summary>
Add a node to the scene.
</summary>
            <param name="node">The node to add.</param>
            <returns>
                <c>true</c> if the node was successfully added. <c>false</c>
otherwise.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllCameras">
            <summary>
Get a list of all camera nodes.
</summary>
            <returns> A list of the camera nodes. If there are no camera nodes
the returned list will be empty.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllMarkerSets">
            <summary>
Get a list of all marker sets.
</summary>
            <returns>List of marker sets.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllSkeletons">
            <summary>
Retrieves a list of all skeleton nodes.
</summary>
            <returns>A list of the skeleton nodes. If there are no skeleton nodes
the returned list will be empty.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllRigidBodies">
            <summary>
Retrieves a list of all rigid body nodes.
</summary>
            <returns>A list of the trackible nodes. If there are no trackible nodes
the returned list will be empty.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllJoints">
            <summary>
Retrieves a list of all joint nodes.
</summary>
            <returns>A list of the joint nodes. If there are no joint nodes
the returned list will be empty.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllMarkers">
            <summary>
Retrieves a list of all marker nodes.
</summary>
            <returns>A list of the marker nodes. If there are no marker nodes
the returned list will be empty.</returns>
        </member>
        <member name="T:NMotive.NodeWarehouse">
            <summary>
Manages all 3D objects in the scene.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.RateDivisor">
            <summary>
Get the camera's frame rate divisor. 
For reference cameras the master sampling rate is divided by
this value. This allows the reference cameras to capture at a slower 
framerate. This reduces the number of frames captured by the reference 
camera which reduces the overall data size. For tracking cameras the
value will always be one.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.RateHz">
            <summary>
Gets the camera's frame rate in Hertz
</summary>
        </member>
        <member name="P:NMotive.CameraNode.FocalLengthMeters">
            <summary>
Gets the camera's focal length in meters.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.SerialNumber">
            <summary>
Gets the camera's serial number.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.Number">
            <summary>
Gets the number of the camera in the scene.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.Gain">
            <summary>
Gets the gain for this camera. The higher the gain the brighter the image.
For Flex13 cameras there are 3 gain settings:
    0 - Low
    1 - Medium
    2 - High

For all other cameras the settings are:
    0 - Low
    1
    2
    3 - Medium
    4
    5
    6
    7 - High
</summary>
        </member>
        <member name="P:NMotive.CameraNode.IRFilterEnabled">
            <summary>
Gets the IR filter enabled value for this camera.
When enabled, the camera captures in IR spectrum, and when disabled,
the camera captures in visible spectrum. 
</summary>
        </member>
        <member name="P:NMotive.CameraNode.VideoMode">
            <summary>
Gets this camera's video mode.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.Threshold">
            <summary>
Defines the minimum brightness for a pixel to be seen by a camera, with all pixels 
below the threshold being ignored.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.ExposureMicroseconds">
            <summary>
Gets the amount of time that the camera exposes per frame in microseconds.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.LEDEnabled">
            <summary>
Gets a boolean value indicating whether or not the LED illumination is enabled.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.ReconstructionEnabled">
            <summary>
Gets and sets the reconstruction property for this camera.
This enables/disables contribution of this camera to the 
reconstruction of the 3D data. 
</summary>
        </member>
        <member name="P:NMotive.CameraNode.Enabled">
            <summary>
Gets the enabled state for this camera.
</summary>
        </member>
        <member name="P:NMotive.CameraNode.DeviceType">
            <summary>
Gets the camera type as a string.
</summary>
        </member>
        <member name="T:NMotive.CameraNode">
            <summary>
Class representing camera nodes in a scene.
</summary>
        </member>
        <member name="P:NMotive.AnimatedNode.KeyFrameRange">
            <summary>
Gets the keyframe range.
</summary>
        </member>
        <member name="P:NMotive.AnimatedNode.ChannelCount">
            <summary>
Gets the number of channels available.
</summary>
        </member>
        <member name="M:NMotive.AnimatedNode.HasChannel(NMotive.Channel.ChannelType)">
            <summary>
Returns true if a channel of the given type exists on this node.
</summary>
            <param name="channelType">Type of channel.</param>
            <returns>
                <c>true</c> if this node contains data for the
specified channel type.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.WorldTransform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full world coordinate transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine world transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Transform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Rotation(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the local rotation at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The rotation as a unit quaternion for the frame.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Translation(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the local position at the given frame index.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>Local position of the frame index.</returns>
        </member>
        <member name="P:NMotive.AnimatedNode.RotationChannel">
            <summary>
Gets the rotation channel. If there is no rotation channel 
<c>null</c> is returned.
</summary>
        </member>
        <member name="P:NMotive.AnimatedNode.TranslationChannel">
            <summary>
Gets the translation channel. If there is
no translation channel <c>null</c> is returned.
</summary>
        </member>
        <member name="M:NMotive.AnimatedNode.SetRotation(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.Quaternion)">
            <summary>
A convenience method for setting local rotation. The default rotation will be set if no animation
channel exists.
</summary>
            <param name="frameIndex">Frame index to set value on.</param>
            <param name="val">The value to set.</param>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.SetTranslation(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.Vector3f)">
            <summary>
A convenience method for setting local translation. The default translation value will be set if no
animation channel exists.
</summary>
            <param name="frameIndex">Frame index to set value on.</param>
            <param name="val">The value to set.</param>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.SetChannel(NMotive.Channel)">
            <summary>
Set one of the animation channels. Which channel gets set is governed by the Type()
of the given channel.
</summary>
            <param name="channel">The channel.</param>
            <returns>True if the given channel was a match for this node and was set as the translation channel.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Clear">
            <summary>
Clear all animation data.
</summary>
        </member>
        <member name="M:NMotive.AnimatedNode.Clear(NMotive.FrameRange)">
            <summary>
Clear all animation data over the given range.
</summary>
            <param name="range">A range</param>
        </member>
        <member name="M:NMotive.AnimatedNode.IsKeyed(NMotive.FrameRange)">
            <summary>
Checks for the presence of keyed data in a give range.
</summary>
            <param name="range">A range.</param>
            <returns>Returns <c>true</c> if a transform key exists in the given range.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.IsKeyed">
            <summary>
Checks for the presence of keyed data.
</summary>
            <returns>Returns <c>true</c> if a transform key exists.</returns>
        </member>
        <member name="T:NMotive.AnimatedNode">
            <summary>
Base class for animated nodes in a scene. Nodes are gathered into a hierarchy in the scene
where they are either a child of the root scene node <c>NodeWarehouse</c>
or a child of another existing node in the scene.
Each node also has a transform that accumulates with its parent transform such that a full transform
hierarchy is formed by traversing the node hierarchy.</summary>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetOrAddKeyComponent(System.Single,System.Int32,System.Int32,NMotive.InterpolationType)">
            <summary>
Sets a single component of a key, or creates a new key if none exists. The other axes of the new key
will be filled in using the requested interpolation type.
</summary>
            <param name="val">The value.</param>
            <param name="whichAxis">0 = x, 1 = y, 2 = z.</param>
            <param name="frameIndex">The key frame index which contains the value
to be set.</param>
            <param name="interpType">This interpolation type to used to interpret the other two axis
values if the key needs to be added.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKeyComponent(System.Single,System.Int32,System.Int32)">
            <summary>
Sets a single component of a key. If the key is not found no values will
be set.
</summary>
            <param name="val">The value.</param>
            <param name="whichAxis">0 = x, 1 = y, 2 = z.</param>
            <param name="frameIndex">The key frame index which contains the value
to be set.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.FindKeys(NMotive.FrameRange)">
            <summary>
Retrieve all the keys that fall within the given time range, including end points. The keys
in the returned array are guaranteed to be in order of increasing time.
</summary>
            <param name="range">Find all keys in this frame range.</param>
            <returns>List of keys, in order of increasing time, of all the keys in the 
specified range.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.AllKeys">
            <summary>
Retrieve a copy of the entire key array.
</summary>
            <returns>A list of all keys.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.KeyExtents(NMotive.FrameRange,System.Int32,NMotive.Vector3f@,NMotive.Vector3f@)">
            <summary>
Calculate the minimum and maximum values in the requested dimension for all keys 
within the given range.
</summary>
            <param name="range">The frame range over which to compute the mimimum and 
maximum values.</param>
            <param name="minVals">Minimum values if there are keys in the given range.</param>
            <param name="maxVals">Maximum values if there are keys in the given range.</param>
            <param name="axis">Axis to get extents for. 0 = x-axis, 1 = y-axis, 2 = z-axis.</param>
            <returns>
                <c>true</c> if there are keys in the given range and <c>minVals</c> and
<c>maxVals</c> contain valid values. <c>false</c> if there are no keys in the given range.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.Value(System.TimeSpan)">
            <summary>
Evaluate the channel at the given time and return its value. Will interpolate 
keys where needed.
</summary>
            <param name="fractionalFrame">Fractional frame time of the value.</param>
            <returns>The value at the frame time.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.Value(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean@)">
            <summary>
Evaluate the channel at the given frame and return its value. No interpolation.
</summary>
            <param name="frameIndex">et value for this frame index.</param>
            <param name="isKey">Set to <c>true</c> if the frame index corresponds to a key frame.</param>
            <returns>Value at the frame index if it is a keyframe. If it is not
a keyframe it is the value of the nearest previous key.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.InsertKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Vector3f}},System.Boolean)">
            <summary>
Inserts the given keys into this channel. The time range of the incoming keys is cleared before
setting new keys. The given keys must be in the array in order of increasing frame number.
</summary>
            <param name="sourceKeys">Keys to insert.</param>
            <param name="preserveOriginal">If true any existing keys will be inserted into the input
<c>sourceKeys</c> before the source keys are inserted.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Vector3f}},System.Boolean)">
            <summary>
Convenience method for setting multiple keys at once.
</summary>
            <param name="keys">Key frames to set.</param>
            <param name="addIfNotFound">If true, a new key will be created if one 
does not exist for each key.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKey(NMotive.Vector3f,System.Int32,System.Boolean)">
            <summary>
Set a key at a given frame.
</summary>
            <param name="val">Key value to assign.</param>
            <param name="frameIndex">Frame index at which to assign value.</param>
            <param name="addIfNotFound">If true, a new key will be created 
at the given time if one does not exist</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKey(NMotive.Keyframe`1{NMotive.Vector3f},System.Boolean)">
            <summary>
Set a keyframe value.
</summary>
            <param name="key">Keyframe to add</param>
            <param name="addIfNotFound">If true, a new key will be created at the
given time if one does not exist</param>
        </member>
        <member name="P:NMotive.Vector3fChannel.DefaultValue">
            <summary>
Gets and sets the default <c>Vector3fChannel</c> value.
</summary>
        </member>
        <member name="M:NMotive.Vector3fChannel.#ctor">
            <summary>
Constructs an empty <c>Vector3fChannel</c> object.
</summary>
        </member>
        <member name="T:NMotive.Vector3fChannel">
            <summary>
Channel class for postitional, or transalational, data.
</summary>
        </member>
        <member name="M:NMotive.QuaternionChannel.FindKeys(NMotive.FrameRange)">
            <summary>
Retrieve all the keys that fall within the given time range, including end points. The keys
in the returned array are guaranteed to be in order of increasing time.
</summary>
            <param name="range">Find keys in this frame range.</param>
            <returns>List of keyframes in the given range. The list may be
empty.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.AllKeys">
            <summary>
Retrieve a copy of the entire list of keys.
</summary>
            <returns>The list of all keys.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.KeyExtents(NMotive.FrameRange,System.Int32,NMotive.Quaternion@,NMotive.Quaternion@)">
            <summary>
Calculate the min and max values in the requested dimension for all 
keys within the given range.
</summary>
            <param name="range">Get extents for keys in this frame range.</param>
            <param name="axis">Index of axis for which to retrieve extents if keys
exist in the given range.</param>
            <param name="minVals">If there are keys in the range min exents will be placed in 
<c>minVals[axis]</c>.</param>
            <param name="maxVals">If there are keys in the range max exents will be placed in 
<c>maxVals[axis]</c>.</param>
            <returns>False if there are no keys in the given range.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.Value(System.TimeSpan)">
            <summary>
Evaluate the channel at the given time and return its value. Will interpolate 
keys where needed.
</summary>
            <param name="fractionalFrame">Fractional frame time of the value.</param>
            <returns>The value at the frame time.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.TryGetValue(System.Int32,NMotive.Quaternion@)">
            <summary>
Get the value the channel at the given frame if it frame is a key. No interpolation.
</summary>
            <param name="frame">Frame index.</param>
            <param name="val">If the return value is true, contains the value.
If the return value is false this value is untouched.</param>
            <returns>true if there is a value for this frame. In this case 
<c>val</c> contains the value</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.InsertKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Quaternion}}!System.Runtime.CompilerServices.IsByValue,System.Boolean)">
            <summary>
Inserts the given keys into this channel. The time range of 
the incoming keys is cleared before
setting new keys. The given keys must be in the array in order 
of increasing frame number.
</summary>
            <param name="sourceKeys">Keys to insert.</param>
            <param name="preserveOriginal">Preserve original key values.</param>
        </member>
        <member name="M:NMotive.QuaternionChannel.SetKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Quaternion}}!System.Runtime.CompilerServices.IsByValue,System.Boolean)">
            <summary>
Convenience method for setting multiple keys at once.
</summary>
            <param name="keys">The keys to set.</param>
            <param name="addIfNotFound">If true, a new key will be created 
if one does not exist for each key.</param>
        </member>
        <member name="M:NMotive.QuaternionChannel.SetKey(NMotive.Quaternion,System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Set a key at the given frame.
</summary>
            <param name="val">Key value to assign</param>
            <param name="tm">Frame index at which to add the key</param>
            <param name="addIfNotFound">If true, a new key will be created at 
the given time if one does not exist</param>
        </member>
        <member name="M:NMotive.QuaternionChannel.SetKey(NMotive.Keyframe`1{NMotive.Quaternion},System.Boolean)">
            <summary>
Set a keyframe.
</summary>
            <param name="key">Keyframe to add</param>
            <param name="addIfNotFound">If true, a new key will be created at the
given time if one does not exist</param>
        </member>
        <member name="P:NMotive.QuaternionChannel.DefaultValue">
            <summary>
Sets and gets the default value to use when no keys exist.
</summary>
        </member>
        <member name="M:NMotive.QuaternionChannel.#ctor">
            <summary>
Constructs an empty <c>QuaternionChannel</c> object.
</summary>
        </member>
        <member name="T:NMotive.QuaternionChannel">
            <summary>
Quaternion channel values for a node.
</summary>
        </member>
        <member name="M:NMotive.SimpleTransformf.ToString">
            <summary>
Creates a string representation of self.
</summary>
            <returns>A string representation of self.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.Equals(NMotive.SimpleTransformf,System.Single)">
            <summary>
Does a comparison with another transform. This is an approximate comparison.
</summary>
            <param name="other">Transform to compare self to.</param>
            <param name="tolerance">Tolerance to be used for the comparison.</param>
            <returns>
                <c>true</c> if transforms are equal within tolerance.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.IsIdentity">
            <summary>
Check if the transform is the identity (i.e. no transform).
</summary>
            <returns>
                <c>true</c> if this transform is the identity transformation.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.InverseTransform(NMotive.Vector3f)">
            <summary>
Transform the given point through the inverse of this transform. 
Transform order is Rotate-Translate by convention.
</summary>
            <param name="point">Point to transform.</param>
            <returns>The transformed point.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.Transform(NMotive.Vector3f)">
            <summary>
Transform the given point through this transform. Transform order is Rotate-Translate by convention.
</summary>
            <param name="point">Point to transform.</param>
            <returns>The transformed point.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.Transform(NMotive.SimpleTransformf)">
            <summary>
Transforms our coordinate system by the given transform.
</summary>
            <param name="transform">A simple transformation.</param>
        </member>
        <member name="M:NMotive.SimpleTransformf.Invert">
            <summary>
Invert this transform in place.
</summary>
        </member>
        <member name="M:NMotive.SimpleTransformf.Translate(NMotive.Vector3f)">
            <summary>
Accumulates the given translation into the transform. Given translation is understood to
to be in the local coordinate system.
</summary>
            <param name="translation">Translation to be added.</param>
        </member>
        <member name="M:NMotive.SimpleTransformf.Rotate(NMotive.Quaternion)">
            <summary>Accumulates the given rotation into the transform.</summary>
            <param name="rotation">Rotation to be added.</param>
        </member>
        <member name="P:NMotive.SimpleTransformf.Rotation">
            <summary>
Gets and sets the rotation quaternion for this transformation.
</summary>
        </member>
        <member name="P:NMotive.SimpleTransformf.Translation">
            <summary>
Gets and sets the translation vector for this transformation.
</summary>
        </member>
        <member name="M:NMotive.SimpleTransformf.#ctor(NMotive.Vector3f,NMotive.Quaternion)">
            <summary>
Constructs a simple transform object with the given translation
and rotation.
</summary>
            <param name="translation">The translation vector.</param>
            <param name="rotation">The rotation expressed as a unit quaternion.</param>
        </member>
        <member name="M:NMotive.SimpleTransformf.#ctor">
            <summary>
Parameterless constructor. Constructs the identity transformation.
</summary>
        </member>
        <member name="T:NMotive.SimpleTransformf">
            <summary>
Class representing a "simple" transform, i.e. a rotation plus translation. Scale
is presumed to be one.
</summary>
        </member>
        <member name="M:NMotive.Quaternion.ToString">
            <summary>
A string representation of self.
</summary>
            <returns>A string representation of self.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Equals(NMotive.Quaternion,System.Single)">
            <summary>
Compares this quaternion to another for equality with a specified
tolerance..
</summary>
            <param name="other">Quaternion to compare self to.</param>
            <param name="tolerance">A tolerance to use for comparison.</param>
            <returns>
                <c>true</c> if all components are equal withing the
specified tolerance - the absolute value of the difference of
each component must be less than the tolerance.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Equals(NMotive.Quaternion)">
            <summary>
Compares this quaternion to another for equality.
</summary>
            <param name="other">Quaternion to compare self to.</param>
            <returns>
                <c>true</c> if all components are exactly equal.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Rotate(NMotive.Vector3f)">
            <summary>Rotate the given vector through the rotation of this quaternion.</summary>
            <param name="vec">Vector to rotate.</param>
            <returns>The rotated vector.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Invert">
            <summary>
Invert this quaternion.
</summary>
            <returns>This object inverted.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Conjugate">
            <summary>
Conjugates this quaternion.
</summary>
            <returns>This object conjucated.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Normalize">
            <exclude />
        </member>
        <member name="M:NMotive.Quaternion.Norm">
            <exclude />
        </member>
        <member name="M:NMotive.Quaternion.NormSquared">
            <exclude />
        </member>
        <member name="M:NMotive.Quaternion.AxisAngle">
            <summary>Get Axis Angle. Angle is encoded in vector's length</summary>
            <returns>A vector representation of the axis angle.</returns>
        </member>
        <member name="M:NMotive.Quaternion.SetAxisAngle(NMotive.Vector3f)">
            <summary>Set Axis Angle. Angle is encoded in vector's length</summary>
            <param name="axisAngleVector">The angle encoded as a vector.</param>
        </member>
        <member name="M:NMotive.Quaternion.SetRealPart(NMotive.Vector3f)">
            <summary>Set the real part (i.e. XYZ components) of the quaternion.</summary>
            <param name="vals">Vector of value. 
vals[0] = x-value.
vals[1] = y-value.
vals[2] = z-value.</param>
        </member>
        <member name="M:NMotive.Quaternion.SetValues(System.Single[])">
            <summary>
Sets the values for this quaternion.
</summary>
            <param name="vals">Vector of value. 
vals[0] = x-value.
vals[1] = y-value.
vals[2] = z-value.
vals[3] = w-value.</param>
        </member>
        <member name="M:NMotive.Quaternion.SetValues(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Sets the values for this quaternion.
</summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
            <param name="z">Z value.</param>
            <param name="w">W value.</param>
        </member>
        <member name="M:NMotive.Quaternion.FromOrthogonalVectors(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>Create unit quaternion from 2 orthogonal vectors</summary>
            <param name="vec1">A vector.</param>
            <param name="vec2">A vector.</param>
            <returns>Unit quaternion from 2 orthogonal vectors.</returns>
        </member>
        <member name="M:NMotive.Quaternion.FromVectors(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>Create a unit quaternion from 2 vectors.</summary>
            <param name="vec1">A vector.</param>
            <param name="vec2">A vector.</param>
            <returns>Unit quaternion from 2 vectors.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Slerp(NMotive.Quaternion,NMotive.Quaternion,System.Single)">
            <summary>
Returns a spherical linear interpolated quaternion some percentage 't' between two quaternions.
The parameter t is usually in the range [0,1], but this method can also be used to extrapolate
rotations beyond that range.
</summary>
            <param name="q1">A quaternion.</param>
            <param name="q2">A quaternion.</param>
            <param name="t">Percentage expressed as fraction between 0 and 1.</param>
            <returns>Interpolated value.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Lerp(NMotive.Quaternion,NMotive.Quaternion,System.Single)">
            <summary>
Returns a linear interpolated quaternion some percentage 't' between two quaternions.
The parameter t is usually in the range [0,1], but this method can also be used to extrapolate
rotations beyond that range.
</summary>
            <param name="q1">A quaternion.</param>
            <param name="q2">A quaternion.</param>
            <param name="t">Percentage expressed as fraction between 0 and 1.</param>
            <returns>Interpolated value.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Inverse(NMotive.Quaternion)">
            <summary>
Computes the inverse of a quaternion.
</summary>
            <param name="q">A quaternion.</param>
            <returns>The inverse of <c>q</c>.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Conjugate(NMotive.Quaternion)">
            <summary>
Forms the conjugate of a quaternion.
</summary>
            <param name="q">A quaternion.</param>
            <returns> The conjugate of <c>q</c>.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Dot(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Dot product.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns>The dot product of <c>p</c> and <c>q</c>.</returns>
        </member>
        <member name="M:NMotive.Quaternion.op_Inequality(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Inequality operator for quaternions.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns>
                <c>true</c> if the two quaternions differ in at
least one component.</returns>
        </member>
        <member name="M:NMotive.Quaternion.op_Equality(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Equality operator for quaternions.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns>
                <c>true</c> if the two quaternions are exactly equal,
component-wise.</returns>
        </member>
        <member name="M:NMotive.Quaternion.op_Multiply(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Multiplies two quaternions.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns> Product as a unit quaternion.</returns>
        </member>
        <member name="P:NMotive.Quaternion.default(System.Int32)">
            <summary>
Index operator
</summary>
        </member>
        <member name="P:NMotive.Quaternion.RealPart">
            <summary>
Gets and sets the real part of the quaternion.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.W">
            <summary>
Gets and sets the w or scalar component.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.Z">
            <summary>
Gets and sets the z or k component.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.Y">
            <summary>
Gets and sets the y or j component.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.X">
            <summary>
Gets and sets the x or i component.
</summary>
        </member>
        <member name="M:NMotive.Quaternion.#ctor(System.Single[])">
            <summary>
Constructs a unit <c>Quaternion</c> object from the given array of components.
</summary>
            <param name="vals">
                <c>vals[0]</c> = i component,
<c>vals[1]</c> = j component,
<c>vals[2]</c> = k component,
<c>vals[3]</c> = scalar component,
</param>
        </member>
        <member name="M:NMotive.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs a unit <c>Quaternion</c> object from the given vector and scalar
parts.
</summary>
            <param name="x">i component.</param>
            <param name="y">j component.</param>
            <param name="z">k component.</param>
            <param name="w">Scalar component.</param>
        </member>
        <member name="T:NMotive.Quaternion">
            <summary>
Unit quaternion class.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.NativeToManaged(Core.cVector3&lt;System.Single&gt;)">
            <summary>
Returns the managed version of a native vector.
</summary>
            <param name="nativeVector">A native vector.</param>
            <returns>A managed version of the native vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Distance(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the Euclidean distance between two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The Euclidean distance between the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.DistanceSquared(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the Euclidean distance squared between two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The Euclidean distance squared between the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Lerp(NMotive.Vector3f,NMotive.Vector3f,System.Single)">
            <summary>
Returns a linear interpolated vector some percentage 't' between two vectors.
The parameter t is usually in the range [0,1], but this method can also be used to extrapolate
vectors beyond that range.
</summary>
            <param name="v1">Vector one.</param>
            <param name="v2">Vector two.</param>
            <param name="t">Percentage as decimal between 0 and 1.</param>
            <returns>The interploted value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Normalize(NMotive.Vector3f)">
            <summary>
Normalizes a vector to have length one.
</summary>
            <param name="x">A vector.</param>
            <returns>A normalized version of the input vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Angle(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the angle (in radians) between two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The angle between the two vectors in radians.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Cross(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the cross or vector product of two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The cross product.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Dot(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the dot or scalar product of two vectors.
</summary>
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Normalize">
            <summary>
Normalizes this vector to have length one.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.Norm">
            <summary>
Computes the Euclidean norm.
</summary>
            <returns>The Euclidean norm.</returns>
        </member>
        <member name="M:NMotive.Vector3f.NormSquared">
            <summary>
Computes the Euclidean norm squared.
</summary>
            <returns>The Euclidean norm squared.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Decrement(NMotive.Vector3f)">
            <summary>
Decrements the components of self by the values of the corresponding
components of the given vector. Note that this is just subtracting
the give vector from this vector.
</summary>
            <param name="v">A vector to subtract from self.</param>
        </member>
        <member name="M:NMotive.Vector3f.Decrement(System.Single,System.Single,System.Single)">
            <summary>
Decrements the components of self by the given
amounts.
</summary>
            <param name="dx">Amount to Decrement the X component by.</param>
            <param name="dy">Amount to Decrement the Y component by.</param>
            <param name="dz">Amount to Decrement the Z component by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Decrement">
            <summary>
Decrements the value of each component of self by one.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.Decrement(System.Single)">
            <summary>
Decrements each component of self by the given value.
</summary>
            <param name="a">Amount to decrement by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment(NMotive.Vector3f)">
            <summary>
Increments each component of this vector by the corresponding
component of the input vector.
</summary>
            <param name="v">Vector to increment this vector by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment(System.Single,System.Single,System.Single)">
            <summary>
Increments the components of self by the given
amounts.
</summary>
            <param name="dx">Amount to increment the X component by.</param>
            <param name="dy">Amount to increment the Y component by.</param>
            <param name="dz">Amount to increment the Z component by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment(System.Single)">
            <summary>
Increments each component of self by the given value.
</summary>
            <param name="a">Increment amount.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment">
            <summary>
Increments each component of self by one.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.Scale(System.Single)">
            <summary>
Multiplies each component of self by the given scalar.
</summary>
            <param name="s">The scalar.</param>
        </member>
        <member name="M:NMotive.Vector3f.SetValues(System.Single,System.Single,System.Single)">
            <summary>
Sets the components of self to the given values.
</summary>
            <param name="x">Value to set the X or first component to.</param>
            <param name="y">Value to set the Y or second component to.</param>
            <param name="z">Value to set the Z or third component to.</param>
        </member>
        <member name="M:NMotive.Vector3f.ToString">
            <summary>
Constructs a string representation of self.
</summary>
            <returns>A string representation of this vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Equals(NMotive.Vector3f)">
            <summary>
Compares this vector to another for component-wise equality.
</summary>
            <param name="v">Vector to compare self to.</param>
            <returns>
                <c>true</c>if the componnents of self are equal
to the input vector.</returns>
            <remarks>This function will return <c>true</c> only if the vector
components are all equal in a bit-wise sense.</remarks>
        </member>
        <member name="M:NMotive.Vector3f.Equals(NMotive.Vector3f,System.Single)">
            <summary>
Compares this vector with another vector for equality using a 
tolerance. This function will return <c>true</c> if the 
absolute value of the difference of each component is less than
the specified tolerance.
</summary>
            <param name="v">Vector to compare self to.</param>
            <param name="tolerance">The tolerance.</param>
            <returns>
                <c>true</c> if the vectors are equal within the 
specified tolerance. </returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Inequality(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Compares two vectors for component-wise non-equality.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>
                <c>true</c>if the componnents of the two vectors are not equal.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Equality(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Compares two vectors for component-wise equality.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>
                <c>true</c>if the componnents of the two vectors are equal.</returns>
            <remarks>This function will return <c>true</c> only if the vectors
components are all equal in a bit-wise sense.</remarks>
        </member>
        <member name="M:NMotive.Vector3f.op_Multiply(System.Single,NMotive.Vector3f)">
            <summary>
Computes a vector whose components are equal to the components of
the input vector multiplied by a give scalar value.
</summary>
            <param name="s">A scaler to scale by.</param>
            <param name="x">A vector to scale.</param>
            <returns>Scaled vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Multiply(NMotive.Vector3f,System.Single)">
            <summary>
Computes a vector whose components are equal to the components of
the input vector multiplied by a give scalar value.
</summary>
            <param name="x">A vector to scale.</param>
            <param name="s">A scaler to scale by.</param>
            <returns>Scaled vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Subtraction(System.Single,NMotive.Vector3f)">
            <summary>
Subtract vector and scalar. Computes a vector whose ith component value
is the scalar minus the ith component value.
</summary>
            <param name="s">A scalar.</param>
            <param name="x">A vector.</param>
            <returns>a vector whose ith component value
is the scalar minus the ith component value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Subtraction(NMotive.Vector3f,System.Single)">
            <summary>
Subtract a scalar from a vector. Decrements each component of the vector by
</summary>
            <param name="x">A vector.</param>
            <param name="s">A scalar.</param>
            <returns>A vector whose component values are equal to the input vectors
incremented by the scalar value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Addition(System.Single,NMotive.Vector3f)">
            <summary>
Add a vector and a scalar. Increments each component of the vector by
</summary>
            <param name="s">A scalar.</param>
            <param name="x">A vector.</param>
            <returns>A vector whose component values are equal to the input vectors
incremented by the scalar value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Addition(NMotive.Vector3f,System.Single)">
            <summary>
Add a vector and a scalar. Increments each component of the vector by
</summary>
            <param name="x">A vector.</param>
            <param name="s">A scalar.</param>
            <returns>A vector whose component values are equal to the input vectors
incremented by the scalar value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Subtraction(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Vector subtraction operator. Returns the component-wise difference
of two vectors.
</summary>
            <param name="x">A vector.</param>
            <param name="y">A vector</param>
            <returns>The difference of the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Addition(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Vector addition operator. Returns the component-wise sum of two vectors.
</summary>
            <param name="x">A vector.</param>
            <param name="y">A vector</param>
            <returns>The sum of the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_UnaryNegation(NMotive.Vector3f)">
            <summary>
Vector negation. returns a new vector object with component values
equal to equal to the negated input vector component values.
</summary>
            <param name="x">A vector to negate.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="P:NMotive.Vector3f.default(System.Int32)">
            <summary>
Index operator. Return the vector component at the specified
zero based index. X = [0], Y = [1], Z = [2].
Any index value other than 0, 1, or 2 will raise an exception.
</summary>
            <returns>The component at the give index.</returns>
        </member>
        <member name="P:NMotive.Vector3f.Z">
            <summary>
Gets and sets the Z component value.
</summary>
        </member>
        <member name="P:NMotive.Vector3f.Y">
            <summary>
Gets and sets the Y component value.
</summary>
        </member>
        <member name="P:NMotive.Vector3f.X">
            <summary>
Gets and sets the X component value.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.#ctor(System.Single[])">
            <summary>
Constructs a <c>Vector3f</c> object with the given component
values.
</summary>
            <param name="values"> values[0] is the X component value,
values[1] is the Y component value, values[2] is the Z 
component value.</param>
        </member>
        <member name="M:NMotive.Vector3f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructs a <c>Vector3f</c> object with the given component
values.
</summary>
            <param name="x"> X component value.</param>
            <param name="y"> Y component value.</param>
            <param name="z"> Z component value.</param>
        </member>
        <member name="T:NMotive.Vector3f">
            <summary>
A three dimensional vector.
</summary>
        </member>
        <member name="M:NMotive.Channel.CompareTo(NMotive.Channel)">
            <summary>
Comparison operator, used for instance sorting
</summary>
            <param name="other">A channel to compare self to.</param>
            <returns>
Less than zero if this ID is less than other,
zero if this ID is equal to other,
greater than zero if this ID is greater than other.
</returns>
        </member>
        <member name="M:NMotive.Channel.KeyIndexRange(NMotive.FrameRange,System.Tuple`2{System.UInt32,System.UInt32}@)">
            <summary>
Get the key index range that falls within or on the edges of the given frame range.
</summary>
            <param name="range">The frame range to search across.</param>
            <param name="indexRange">The start and end indices of the keys that fall within or on the
frame range boundaries. Only valid if <c>true</c> is returned from the method.</param>
            <returns>
                <c>true</c> if a valid key index range was found.</returns>
        </member>
        <member name="M:NMotive.Channel.FindKeyIndex(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Finds the key index for the requested frame, searching forward or back to find it if the requested frame
does not lie at a key. 
</summary>
            <param name="frame">The requested frame.</param>
            <param name="searchForward">A value of <c>true</c> means to search forward.
A value of <c>false</c> means to search backward.</param>
            <returns>The key index or value less than zero if there are no keys or no keys exist at the requested time
or beyond when traveling in the search direction.</returns>
        </member>
        <member name="M:NMotive.Channel.KeyIndex(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Returns the key index at the given frame.
</summary>
            <param name="frame">A frame.</param>
            <returns>The key index at the given frame if it corresponds to a key. Frames that do not
correspond to a key will return a negative value. That value is the number of frames since the last
key, or <c>FrameConstants.NegativeInfinity</c> if there are no keys or the requested frame is before any keys.
For example, if the value returned for a given requested frame is -8, then the previous valid key in time
occurred 8 frames ago in time.</returns>
        </member>
        <member name="M:NMotive.Channel.KeyFrameDistance(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Calculate the distance, in frames, from the given frame index to the nearest key in the key array. Distance
will always be non-negative.
</summary>
            <param name="frame">A key frame.</param>
            <returns>The distance, in frames, from the given frame index to the nearest key in the key array.</returns>
        </member>
        <member name="M:NMotive.Channel.KeyFrame(System.Int32)">
            <summary>
Get the frame index for the key at the given index.
</summary>
            <param name="index">Key frame index.</param>
            <returns>Frame index for the given key frame index.</returns>
        </member>
        <member name="M:NMotive.Channel.IsKey(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Determine if a key is set at the given frame index
</summary>
            <param name="index">Frame index at which to search</param>
            <returns>True if key exists at the give frame index, false otherwise</returns>
        </member>
        <member name="M:NMotive.Channel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
</summary>
            <param name="startFrame">Starting frame for the search.</param>
            <param name="searchForward">A value of <c>true</c> means to search forward.
A value of <c>false</c> means to search backward.</param>
            <returns>The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range. If there
are no keys, an infinite range will be returned.</returns>
        </member>
        <member name="M:NMotive.Channel.GapRange(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Returns the full gap range of the gap that the requested frame lies within, or an empty range if
the frame is not in a gap.
</summary>
            <param name="frame">A frame.</param>
            <returns>Full gap range of the gap in which the given frame lies, or an empty range if the
frame is not in a gap.</returns>
        </member>
        <member name="M:NMotive.Channel.FillGaps(NMotive.FrameRange,NMotive.InterpolationType,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Fills any gaps that exist within the given frame range whose length is less than or equal to 
the given max gap width. The frame range must completely contain the gap(s) to be filled, except
in the case of filling gaps before the first key or after the last key. In that case, the gap
will be filled to the extents of the requested range as long as the range includes a key.
</summary>
            <param name="range">A frame range.</param>
            <param name="interpType">The type of interpolation used.</param>
            <param name="maxGapWidth">Do not fill gaps with widths greater than this value.</param>
            <returns>The number of gaps filled.</returns>
        </member>
        <member name="M:NMotive.Channel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.FrameRange,System.Int32!System.Runtime.CompilerServices.IsLong@,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range or there are no gaps
less than or equal to the requested max gap size that lie within the given full range.
</summary>
            <param name="frame">Beginning search frame.</param>
            <param name="fullRange">A frame range.</param>
            <param name="maxGap">Find gaps less than or equal to this number of frames.</param>
            <param name="searchForward">A value of <c>true</c> means to search forward.
A value of <c>false</c> means to search backward.</param>
            <returns>The next gap as a frame range, or an empty frame range if no gaps are found.</returns>
        </member>
        <member name="M:NMotive.Channel.Segments(NMotive.FrameRange)">
            <summary>
Retrieve a list of ranges that have continuous data (i.e. no gaps) for the given range.
</summary>
            <param name="range">A frame range.</param>
            <returns>The list of frame ranges with the given ranges with no gaps.</returns>
        </member>
        <member name="M:NMotive.Channel.Gaps(NMotive.FrameRange)">
            <summary>
Retrieve a list of gaps that lie within a given range. The output array is not cleared
during this call, so values are simply added to the passed array. Any gaps that lie on the boundary
of the requested range will be clipped to lie within the requested range.
</summary>
            <param name="range">A frame range.</param>
            <returns>The list of frame ranges with the given ranges with gaps.</returns>
        </member>
        <member name="M:NMotive.Channel.Gaps">
            <summary>
Retrieve a list of all gaps that currently exist.
</summary>
            <returns>The list of frame ranges with gaps.</returns>
        </member>
        <member name="M:NMotive.Channel.HasGaps(NMotive.FrameRange)">
            <summary>
Returns true if there are any frame gaps between the first key and the last. To test for gaps beyond
the first and last keys, you should pass in the full take frame range that you want to test against.
</summary>
            <param name="range">Check for gaps in this range.</param>
            <returns>
                <c>true</c>if there are gaps in the range. Returns <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NMotive.Channel.HasKeys(NMotive.FrameRange)">
            <summary>
Returns true if keys exist within the given the time range, including endpoints.
</summary>
            <param name="range">Check for keys in this range.</param>
            <returns>
                <c>true</c> if keys exist in the given range.</returns>
        </member>
        <member name="M:NMotive.Channel.HasKeys">
            <summary>
Returns true if keys exist.
</summary>
            <returns>
                <c>true</c> if keys exist.</returns>
        </member>
        <member name="M:NMotive.Channel.ScaleAndOffsetTime(System.Double,System.Double,System.Int32)">
            <summary>
Scale and offset the time component of all keys on the channels by the given amounts.
</summary>
            <param name="offset">Offset.</param>
            <param name="scale">Scale.</param>
            <param name="startFrame">Starting frame.</param>
        </member>
        <member name="M:NMotive.Channel.ClearSelected(NMotive.FrameRange)">
            <summary>
Deletes any selected keys in the given range.
</summary>
            <param name="range">Selected keys withing this range will be deleted.</param>
        </member>
        <member name="M:NMotive.Channel.Clear(NMotive.FrameRange)">
            <summary>
Deletes any keys within or on the edges of the given time range.
</summary>
            <param name="range">Keys withing this range will be deleted.</param>
        </member>
        <member name="M:NMotive.Channel.Clear">
            <summary>
Deletes all keys on this channel and sets it back to its default state.
</summary>
        </member>
        <member name="M:NMotive.Channel.SelectKeys(NMotive.FrameRange,System.Boolean)">
            <summary>
Set the selection state of the keys that fall within (or on the edges of) the given time range.
</summary>
            <param name="range">A frame range.</param>
            <param name="onOff">If <c>true</c> set key states in the range are "on". Otherwise
set key states "off".</param>
            <returns>The number of keys whose selection state was altered.</returns>
        </member>
        <member name="M:NMotive.Channel.SelectKey(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Set the selection state of the key at the given index.
</summary>
            <param name="index">Index of the key.</param>
            <param name="onOff">If <c>true</c> set key state "on". Otherwise
set key state "off".</param>
        </member>
        <member name="P:NMotive.Channel.Type">
            <summary>
Gets the channel type that this channel applies to within a node.
</summary>
        </member>
        <member name="P:NMotive.Channel.KeyFrameRange">
            <summary>
Gets the frame range covered by all keys.
</summary>
        </member>
        <member name="P:NMotive.Channel.KeyCount">
            <summary>
Gets the number of keys present.
</summary>
        </member>
        <member name="M:NMotive.Channel.#ctor(MoCapCore.cIChannel*,System.Boolean)">
            <summary>
Constructs a channel object with the given native implementation.
Constructed object may optionally take ownership of the native
reference.
</summary>
            <param name="nativeImpl">A pointer to the native implementation.</param>
            <param name="takeOwnershipOfImpl">If true this object will own the 
native implementation and free it upon destruction. If this parameter
value is true it is assumed the native object pointed to is on the heap!</param>
            <exclude />
        </member>
        <member name="F:NMotive.Channel.mOwnImpl">
            <summary>
If <c>true</c> this object owns the native implementation and is
responsible for freeing it.
</summary>
        </member>
        <member name="F:NMotive.Channel.mNativeImpl">
            <exclude />
            <summary>
The native implementation.
</summary>
        </member>
        <member name="F:NMotive.Channel.ChannelType.SizeChannel">
            <exclude />
        </member>
        <member name="F:NMotive.Channel.ChannelType.ScaleChannel">
            <exclude />
        </member>
        <member name="F:NMotive.Channel.ChannelType.RotationChannel">
            <summary>
Rotation channel for nodes.
</summary>
        </member>
        <member name="F:NMotive.Channel.ChannelType.TranslationChannel">
            <summary>
Translation channel for nodes.
</summary>
        </member>
        <member name="F:NMotive.Channel.ChannelType.UnknownChannel">
            <summary>
Reserved for indeterminate types.
</summary>
        </member>
        <member name="T:NMotive.Channel.ChannelType">
            <summary>
Enum for the different channel types.
</summary>
        </member>
        <member name="T:NMotive.Channel">
            <summary>
Channels are owned by Takes and always have an associated ChannelType.
</summary>
        </member>
        <member name="F:NMotive.FrameConstants.Invalid">
            <summary>
Use for testing for a valid frame index.
</summary>
        </member>
        <member name="F:NMotive.FrameConstants.NegativeInfinity">
            <summary>
Use for testing frame index equal to negative infinity.
</summary>
        </member>
        <member name="F:NMotive.FrameConstants.PositiveInfinity">
            <summary>
Use for testing frame index equal to positive infinity.
</summary>
        </member>
        <member name="T:NMotive.FrameConstants">
            <summary>
Constants for frames.
</summary>
        </member>
        <member name="P:NMotive.Keyframe`1.Frame">
            <summary>
Gets and sets the frame number.
</summary>
        </member>
        <member name="P:NMotive.Keyframe`1.Value">
            <summary>
Gets and sets the key frame value.
</summary>
        </member>
        <member name="M:NMotive.Keyframe`1.op_Inequality(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Non-equality operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is not equal to right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_Equality(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Equality operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is equal to right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_GreaterThanOrEqual(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Greater than or equal operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is greater than or equal right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_LessThanOrEqual(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Less than or equal operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is less than or equal right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_GreaterThan(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Greater than operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is greater than right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_LessThan(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Less than operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is less than right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.CompareTo(NMotive.Keyframe`1{`0})">
            <summary>
Compares this key frame to another.
Comparison is made using the frame numbers.
</summary>
            <param name="other">A key frame.</param>
            <returns>
Less than zero if this frame is less than other,
zero if this frame is equal to other,
greater than zero if this frame is greater than other.
</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.Equals(NMotive.Keyframe`1{`0})">
            <summary>
Tests equality of this key frame to another.
Key frames are equal if the have the same number and value.
</summary>
            <param name="other">A key frame.</param>
            <returns>
                <c>true</c> if this key frame is equal to other.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.#ctor(`0,System.Int32)">
            <summary>
Constructs a key frame with the given value.
</summary>
            <param name="val">Value for this key frame.</param>
            <param name="frame">Frame number for this key frame.</param>
        </member>
        <member name="T:NMotive.Keyframe`1">
            <summary>
Generic representation for key frames.
</summary>
            <typeparam name="T">frame data type.</typeparam>
        </member>
        <member name="M:MoCapCore.cRigidBodyNode.PropertyNames">
            <summary>Returns the property name predicates with the names of the property warehouse properties that
this node uses.</summary>
        </member>
        <member name="M:MoCapCore.cRigidBodyNode.UserID">
            <summary>Retrieve the user ID.</summary>
        </member>
        <member name="M:MoCapCore.cRigidBodyNode.SetUserID(System.Int32)">
            <summary>Set the user ID</summary>
        </member>
        <member name="M:MoCapCore.cRigidBodyNode.CalibrationTime">
            <summary>Retrieve the time this object was last calibrated, or cTime::kInvalid if none.</summary>
        </member>
        <member name="M:MoCapCore.cRigidBodyNode.SetCalibrationTime(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convenience method to set the "last calibration time" for this object.</summary>
        </member>
        <member name="M:MoCapCore.cLabelGroup.InitializeProperties(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set all the properties to their creation defaults.</summary>
        </member>
        <member name="M:MoCapCore.cLabelGroup.PropertyNames">
            <summary>Returns the property name predicates with the names of the property warehouse properties that this node uses.</summary>
        </member>
        <member name="T:MoCapCore.cLabelGroup">
            <summary>A group of user-defined marker labels.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.HasInterpolatedFingers">
            <summary> Returns true if markered index and pinky fingers drive middle and ring fingers animation. </summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.HasIKFingers">
            <summary> Returns true if finger tip bone has marker. </summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.CreateSingleElementDOFDefinition(MoCapCore.cBoneNode!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Helper function to create a DOF definition with a single element.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.InitializeProperties(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set all the skeleton nodes properties to their creation defaults.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.PropertyNames">
            <summary>Populates the property name predicates with the names of the property warehouse properties that
this node uses.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.IsRigidBodySkeleton">
            <summary>Determine if this is a rigid body-based skeleton.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.HasDOFs">
            <summary>Returns true if any DOF's have been set.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.CreateInterpolatedFingerDOFDefinitions(System.Boolean)">
            <summary>Creates degree-of-freedom definitions for fingers with markers on second bone of thumb, 
index and pinky fingers.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.CreateIKFingerDOFDefinitions">
            <summary>Creates degree-of-freedom definitions for fingers with markers on finger tips.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.CreateDOFDefinitions">
            <summary>Creates degree-of-freedom definitions for skeleton.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.SetAllBoneRotationOrders">
            <summary>Sets rotation order based on bone type.</summary>
        </member>
        <member name="M:MoCapCore.cSkeletonNode.SetAllDOFs">
            <summary>Sets degree-of-freedom based on bone type.</summary>
        </member>
        <member name="M:Armory.cArmory.Status">
            <summary>Query the device status and return a JSON string with state info.</summary>
        </member>
        <member name="M:Armory.cArmory.ReadAllBytes(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Reads all bytes of a file into a byte array.</summary>
        </member>
        <member name="M:Armory.cArmory.GenerateNonce">
            <summary>Generate a random 12-byte nonce for use in key/data exchange.</summary>
        </member>
        <member name="M:Armory.cArmory.DecodeLicense(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Decode an encrypted license file for use by the application.</summary>
            <returns>License file decoded to HTML-ish format.</returns>
        </member>
        <member name="M:Armory.cArmory.UnauthorizedDeviceCount">
            <summary>Unauthorized camera count.</summary>
        </member>
        <member name="M:Armory.cArmory.DeviceCount">
            <summary>Number of devices in the database.</summary>
        </member>
        <member name="M:Armory.cArmory.WriteCounter">
            <summary>Current cached write counter.</summary>
        </member>
        <member name="M:Armory.cArmory.Serial">
            <summary>Security Key serial number.</summary>
        </member>
        <member name="M:Armory.cArmory.ExchangeMessage(api.Message!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Send a message and wait for a reply.</summary>
        </member>
        <member name="M:Armory.cArmory.Revalidate">
            <returns>Ensures that the device is connected and valid.</returns>
        </member>
        <member name="M:Armory.cArmory.ShutDown">
            <summary>Shut down and disconnect from the hardware device.</summary>
        </member>
        <member name="M:Armory.cArmory.Initialize">
            <summary>Initialize the armory. Attempts to connect to the hardware.</summary>
        </member>
        <member name="F:MotiveCore.cMarkerNameImporter.kMarkerSticksElement">
            <summary>Marker sticks section tag name.</summary>
        </member>
        <member name="F:MotiveCore.cMarkerNameImporter.kMarkerColorsElement">
            <summary>Marker colors section tag name.</summary>
        </member>
        <member name="F:MotiveCore.cMarkerNameImporter.kMarkerNamesElement">
            <summary>Marker name section tag name.</summary>
        </member>
        <member name="T:MotiveCore.cMarkerNameImporter">
            <summary>
Importer class for skeleton marker name maps, marker stick definitions, and marker colors.
</summary>
        </member>
        <member name="M:tinyxml2wc.XMLPrinter.CStrSize">
If in print to memory mode, return the size
of the XML file in memory. (Note the size returned
includes the terminating null.)

</member>
        <member name="M:tinyxml2wc.XMLPrinter.CStr">
If in print to memory mode, return a pointer to
the XML file in memory.

</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushComment(System.Char!System.Runtime.CompilerServices.IsConst*)">
Add a comment
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Double)">
Add a text node from a double.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Single)">
Add a text node from a float.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Boolean)">
Add a text node from a bool.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.UInt32)">
Add a text node from an unsigned.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Int32)">
Add a text node from an integer.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Add a text node.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.CloseElement">
If streaming, close the Element.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
If streaming, add an attribute to an open element.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.OpenElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
If streaming, start writing an element.
        The element must be closed with CloseElement()

</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushHeader(System.Boolean,System.Boolean)">
If streaming, write the BOM and declaration. 
</member>
        <member name="M:tinyxml2wc.XMLPrinter.#ctor(_iobuf*,System.Boolean)">
Construct the printer. If the FILE* is specified,
        this will print to the FILE. Else it will print
        to memory, and the result is available in CStr().
        If 'compact' is set to true, then output is created
        with only required whitespace and newlines.

</member>
        <member name="T:tinyxml2wc.XMLConstHandle">
A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
same in all regards, except for the 'const' qualifiers. See XMLHandle for API.

</member>
        <member name="M:tinyxml2wc.XMLHandle.ToDeclaration">
Safe cast to XMLDeclaration. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToUnknown">
Safe cast to XMLUnknown. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToText">
Safe cast to XMLText. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToElement">
Safe cast to XMLElement. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToNode">
Safe cast to XMLNode. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.NextSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the next sibling element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.NextSibling">
Get the next sibling of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.PreviousSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the previous sibling element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.PreviousSibling">
Get the previous sibling of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.LastChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the last child element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.LastChild">
Get the last child of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.FirstChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the first child element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.FirstChild">
Get the first child of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.op_Assign(tinyxml2wc.XMLHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment
</member>
        <member name="M:tinyxml2wc.XMLHandle.#ctor(tinyxml2wc.XMLHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:tinyxml2wc.XMLHandle.#ctor(tinyxml2wc.XMLNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a handle from a node.
</member>
        <member name="M:tinyxml2wc.XMLHandle.#ctor(tinyxml2wc.XMLNode*)">
Create a handle from any node (at any depth of the tree.) This can be a null pointer.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.PrintError">
If there is an error, print it to stdout.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.GetErrorStr2">
Return a possibly helpful secondary diagnostic location or string.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.GetErrorStr1">
Return a possibly helpful diagnostic location or string.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.ErrorID">
Return the errorID.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.Error">
Return true if there was an error parsing the document.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.DeleteNode(tinyxml2wc.XMLNode*)">
Delete a node associated with this document.
It will be unlinked from the DOM.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewUnknown(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Unknown associated with
this Document. The memory forthe object
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewText(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Text associated with
this Document. The memory for the Text
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewComment(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Comment associated with
this Document. The memory for the Comment
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Element associated with
this Document. The memory for the Element
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.RootElement">
Return the root element of DOM. Equivalent to FirstChildElement().
        To get the first node, use FirstChild().

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.SetBOM(System.Boolean)">
Sets whether to write the BOM when writing the file.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.HasBOM">
Returns true if this document has a leading Byte Order Mark of UTF8.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.SaveFile(_iobuf*,System.Boolean)">
        Save the XML file to disk. You are responsible
        for providing and closing the FILE*.

        Returns XML_NO_ERROR (0) on success, or
        an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.SaveFile(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Save the XML file to disk.
Returns XML_NO_ERROR (0) on success, or
an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.LoadFile(_iobuf*)">
        Load an XML file from disk. You are responsible
        for providing and closing the FILE*.

        Returns XML_NO_ERROR (0) on success, or
        an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.LoadFile(System.Char!System.Runtime.CompilerServices.IsConst*)">
Load an XML file from disk.
Returns XML_NO_ERROR (0) on success, or
an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.Parse(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
        Parse an XML file from a character string.
        Returns XML_NO_ERROR (0) on success, or
        an errorID.

        You may optionally pass in the 'nBytes', which is
        the number of bytes which will be parsed. If not
        specified, TinyXML will assume 'xml' points to a
        null terminated string.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.#ctor(System.Boolean,tinyxml2wc.Whitespace)">
constructor
</member>
        <member name="T:tinyxml2wc.TiXMLDocument">
A Document binds together all the functionality.
    It can be saved, loaded, and printed to the screen.
    All Nodes are connected and allocated to a Document.
    If the Document is deleted, all its Nodes are also deleted.

</member>
        <member name="M:tinyxml2wc.XMLElement.QueryFloatText(System.Single*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryDoubleText(System.Double*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryBoolText(System.Boolean*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryUnsignedText(System.UInt32*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.GetText">
Convenience function for easy access to the text inside an element. Although easy
        and concise, GetText() is limited compared to getting the TiXmlText child
        and accessing it directly.

        If the first child of 'this' is a TiXmlText, the GetText()
        returns the character string of the Text node, else null is returned.

        This is a convenient method for getting the text of simple contained text:
        @verbatim
        <foo>This is text</foo>
        const char* str = fooElement-&gt;GetText();
        @endverbatim

        'str' will be a pointer to "This is text".

        Note that this function can be misleading. If the element foo was created from
        this XML:
        @verbatim
        <foo><b>This is text</b></foo>
        @endverbatim

        then the value of str would be null. The first child node isn't a text node, it is
        another element. From this XML:
        @verbatim
        <foo>This is <b>text</b></foo>
        @endverbatim
        GetText() will return "This is ".

</member>
        <member name="M:tinyxml2wc.XMLElement.FindAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Query a specific attribute in the list.
</member>
        <member name="M:tinyxml2wc.XMLElement.FirstAttribute">
Return the first attribute in the list.
</member>
        <member name="M:tinyxml2wc.XMLElement.DeleteAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Delete an attribute.

</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int64)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Double)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryFloatAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Single*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryDoubleAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Double*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryBoolAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryUnsignedAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.FloatAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.DoubleAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.BoolAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.UnsignedAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.IntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Given an attribute name, IntAttribute() returns the value
        of the attribute interpreted as an integer. 0 will be
        returned if there is an error. For a method with error
        checking, see QueryIntAttribute()

</member>
        <member name="M:tinyxml2wc.XMLElement.Attribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none
        exists. For example:

        @verbatim
        const char* value = ele-&gt;Attribute( "foo" );
        @endverbatim

        The 'value' parameter is normally null. However, if specified,
        the attribute will only be returned if the 'name' and 'value'
        match. This allow you to write code:

        @verbatim
        if ( ele-&gt;Attribute( "foo", "bar" ) ) callFooIsBar();
        @endverbatim

        rather than:
        @verbatim
        if ( ele-&gt;Attribute( "foo" ) ) {
        if ( strcmp( ele-&gt;Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
        }
        @endverbatim

</member>
        <member name="M:tinyxml2wc.XMLElement.SetName(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Set the name of the element.
</member>
        <member name="M:tinyxml2wc.XMLElement.Name">
Get the name of an element (which is the Value() of the node.)
</member>
        <member name="T:tinyxml2wc.XMLElement">
The element is a container class. It has a value, the element name,
    and can contain other elements, text, comments, and unknowns.
    Elements also contain an arbitrary number of attributes.

</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Int64)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Single)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Double)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Boolean)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.UInt32)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Int32)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Set the attribute to a string value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryFloatValue(System.Single*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryDoubleValue(System.Double*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryBoolValue(System.Boolean*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryUnsignedValue(System.UInt32*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryIntValue(System.Int32*)">
QueryIntAttribute interprets the attribute as an integer, and returns the value
        in the provided paremeter. The function will return XML_NO_ERROR on success,
        and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.

</member>
        <member name="M:tinyxml2wc.XMLAttribute.FloatValue">
Query as a float. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.DoubleValue">
Query as a double. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.BoolValue">
Query as a boolean. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.UnsignedValue">
Query as an unsigned integer. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.IntValue">
IntAttribute interprets the attribute as an integer, and returns the value.
        If the value isn't an integer, 0 will be returned. There is no error checking;
        use QueryIntAttribute() if you need error checking.

</member>
        <member name="M:tinyxml2wc.XMLAttribute.Next">
The next attribute in the list.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.Value">
The value of the attribute.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.Name">
The name of the attribute.
</member>
        <member name="T:tinyxml2wc.XMLAttribute">
An attribute is a name-value pair. Elements have an arbitrary
    number of attributes, each with a unique name.

    @note The attributes are not XMLNodes. You may only query the
    Next() attribute in a list.

</member>
        <member name="T:tinyxml2wc.XMLUnknown">
Any tag that tinyXml doesn't recognize is saved as an
    unknown. It is a tag of text, but should not be modified.
    It will be written back to the XML, unchanged, when the file
    is saved.

    DTD tags get thrown into TiXmlUnknowns.

</member>
        <member name="T:tinyxml2wc.XMLComment">
An XML Comment. 
</member>
        <member name="M:tinyxml2wc.XMLText.CData">
Returns true if this is a CDATA text element.
</member>
        <member name="M:tinyxml2wc.XMLText.SetCData(System.Boolean)">
Declare whether this should be CDATA or standard text.
</member>
        <member name="T:tinyxml2wc.XMLText">
XML text.

    Note that a text node can have child element nodes, for example:
    @verbatim
    <root>This is <b>bold</b></root>
    @endverbatim

    A text node can have 2 ways to output the next. "normal" output
    and CDATA. It will default to the mode it was parsed from the XML file and
    you generally want to leave it alone, but you can change the output mode with
    SetCDATA() and query it with CDATA().

</member>
        <member name="M:tinyxml2wc.XMLNode.ShallowEqual(tinyxml2wc.XMLNode!System.Runtime.CompilerServices.IsConst*)">
        Test if 2 nodes are the same, but don't test children.
        The 2 nodes do not need to be in the same Document.

        Note: if called on a TiXMLDocument, this will return false.

</member>
        <member name="M:tinyxml2wc.XMLNode.ShallowClone(tinyxml2wc.TiXMLDocument*)">
        Make a copy of this node, but not its children.
        You may pass in a Document pointer that will be
        the owner of the new Node. If the 'document' is
        null, then the node returned will be allocated
        from the current Document. (this-&gt;GetDocument())

        Note: if called on a TiXMLDocument, this will return null.

</member>
        <member name="M:tinyxml2wc.XMLNode.DeleteChild(tinyxml2wc.XMLNode*)">
Delete a child of this node.

</member>
        <member name="M:tinyxml2wc.XMLNode.DeleteChildren">
Delete all the children of this node.

</member>
        <member name="M:tinyxml2wc.XMLNode.InsertAfterChild(tinyxml2wc.XMLNode*,tinyxml2wc.XMLNode*)">
Add a node after the specified child node.

</member>
        <member name="M:tinyxml2wc.XMLNode.InsertFirstChild(tinyxml2wc.XMLNode*)">
Add a child node as the first (left) child.

</member>
        <member name="M:tinyxml2wc.XMLNode.InsertEndChild(tinyxml2wc.XMLNode*)">
Add a child node as the last (right) child.

</member>
        <member name="M:tinyxml2wc.XMLNode.NextSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the next (right) sibling element of this node, with an opitionally supplied name.
</member>
        <member name="M:tinyxml2wc.XMLNode.NextSibling">
Get the next (right) sibling node of this node.
</member>
        <member name="M:tinyxml2wc.XMLNode.PreviousSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the previous (left) sibling element of this node, with an opitionally supplied name.
</member>
        <member name="M:tinyxml2wc.XMLNode.PreviousSibling">
Get the previous (left) sibling node of this node.
</member>
        <member name="M:tinyxml2wc.XMLNode.LastChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the last child element or optionally the last child
        element with the specified name.

</member>
        <member name="M:tinyxml2wc.XMLNode.LastChild">
Get the last child node, or null if none exists.
</member>
        <member name="M:tinyxml2wc.XMLNode.FirstChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the first child element, or optionally the first child
        element with the specified name.

</member>
        <member name="M:tinyxml2wc.XMLNode.FirstChild">
Get the first child node, or null if none exists.
</member>
        <member name="M:tinyxml2wc.XMLNode.NoChildren">
Returns true if this node has no children.
</member>
        <member name="M:tinyxml2wc.XMLNode.Parent">
Get the parent of this node on the DOM.
</member>
        <member name="M:tinyxml2wc.XMLNode.SetValue(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Set the Value of an XML node.
        @sa Value()

</member>
        <member name="M:tinyxml2wc.XMLNode.Value">
The meaning of 'value' changes for the specific type.
        @verbatim
        Document:       empty
        Element:        name of the element
        Comment:        the comment text
        Unknown:        the tag contents
        Text:           the text string
        @endverbatim

</member>
        <member name="M:tinyxml2wc.XMLNode.ToUnknown">
Safely cast to an Unknown, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToDeclaration">
Safely cast to a Declaration, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToDocument">
Safely cast to a Document, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToComment">
Safely cast to a Comment, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToText">
Safely cast to Text, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToElement">
Safely cast to an Element, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.GetDocument">
Get the TiXMLDocument that owns this XMLNode.

Get the TiXMLDocument that owns this XMLNode.
</member>
        <member name="T:tinyxml2wc.XMLNode">
XMLNode is a base class for every object that is in the
    XML Document Object Model (DOM), except XMLAttributes.
    Nodes have siblings, a parent, and children which can
    be navigated. A node is always in a TiXMLDocument.
    The type of a XMLNode can be queried, and it can
    be cast to its more defined type.

    A TiXMLDocument allocates memory for all its Nodes.
    When the TiXMLDocument gets deleted, all its Nodes
    will also be deleted.

    @verbatim
    A Document can contain: Element (container or leaf)
    Comment (leaf)
    Unknown (leaf)
    Declaration( leaf )

    An Element can contain: Element (container or leaf)
    Text    (leaf)
    Attributes (not on tree)
    Comment (leaf)
    Unknown (leaf)

    @endverbatim

</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLUnknown!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit an unknown node.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLComment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a comment node.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLText!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a text node.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLDeclaration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a declaration.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitExit(tinyxml2wc.XMLElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit an element.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitEnter(tinyxml2wc.XMLElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tinyxml2wc.XMLAttribute!System.Runtime.CompilerServices.IsConst*)">
Visit an element.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitExit(tinyxml2wc.TiXMLDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a document.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitEnter(tinyxml2wc.TiXMLDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a document.
</member>
        <member name="T:tinyxml2wc.XMLVisitor">
    Implements the interface to the "Visitor pattern" (see the Accept() method.)
    If you call the Accept() method, it requires being passed a XMLVisitor
    class to handle callbacks. For nodes that contain other nodes (Document, Element)
    you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
    are simply called with Visit().

    If you return 'true' from a Visit method, recursive parsing will continue. If you return
    false, <b>no children of this node or its sibilings</b> will be visited.

    All flavors of Visit methods have a default implementation that returns 'true' (continue
    visiting). You need to only override methods that are interesting to you.

    Generally Accept() is called on the TiXmlDocument, although all nodes support visiting.

    You should never change the document from a callback.

    @sa XMLNode::Accept()

</member>
        <member name="M:MotiveCore.cLicenseManager.LicenseInformationWidgetTree">
            <summary>Retrieve a Qt widget hierarchy that displays Motive license information. Caller is responsible
for freeing the returned objects.</summary>
        </member>
        <member name="M:MoCapCore.cILicenseManager.RevalidateLicense">
            <summary>Re-test primary license and determine if the license is valid.</summary>
        </member>
        <member name="M:MoCapCore.cILicenseManager.LicensingDeviceSerial">
            <summary>Returns the serial number of the licensing device.</summary>
        </member>
        <member name="M:MotiveCore.cPropertyWarehouse.AvailableProfiles(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <summary>Returns the names of available profiles that exist in the profiles directory.</summary>
        </member>
        <member name="F:ForceCompleteDelivery">
            <summary>
Queue frames up to kSyncFrameDepth(60) per camera.
Can cause 3D frame drops in next frame if the current frame had to wait long for all frames.
</summary>
        </member>
        <member name="F:FavorTimelyDelivery">
            <summary>
Detects if the frames are 5% or more out of order(i.e. frames arriving late) and if so enable queueing of frames. 
Otherwise sends out the frames as soon as a different frame ID comes in.
Can cause 2D frame drops for late arriving frames, if out of order amount is less than 5%.
</summary>
        </member>
        <member name="F:ForceTimelyDelivery">
            <summary>
Does not queue the frames. As soon as a different frame ID comes in, existing frames are sent out to the application.
Can cause 2D frame drops for late arriving frames.
</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateBuffer(System.Byte*,System.UInt32)">
            <summary>Fills the given buffer with random values.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateVector(System.UInt32*,System.UInt32)">
            <summary>Fills the given array with random values.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateUnsignedInt(System.UInt32,System.UInt32)">
            <summary>Generate a random 32-bit unsigned integer within the given range (inclusive).</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateUnsignedInt">
            <summary>Generate a random 32-bit unsigned integer.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateInt">
            <summary>Generate an integer within the full integer range.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.SetSeed(System.Int32)">
            <summary>Set the seed value to use.</summary>
        </member>
        <member name="M:CameraLibrary.Synchronizer.HasAvailableFrames">
            <summary>True if the pool has frames available for use.</summary>
        </member>
        <member name="M:CameraLibrary.Synchronizer.AllFramesAvailable">
            <summary>True if all allocated frames are also available.</summary>
        </member>
        <member name="M:CameraLibrary.Synchronizer.AllocatedFrameCount">
            <summary>Number of frames currently allocated for use in the frame pool. The frame pool will grow
or shrink under demand.</summary>
        </member>
        <member name="M:CameraLibrary.Synchronizer.Flush">
            <summary>Flush any pending frames.</summary>
        </member>
        <member name="M:CameraLibrary.Synchronizer.GetCompletedFrame">
            <summary>Retrieve the next frame in the completed frames queue. If the queue is empty, a null frame is returned.</summary>
        </member>
        <member name="M:CameraLibrary.Synchronizer.PostFrame(std.shared_ptr&lt;CameraLibrary.Frame!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a frame to the queue of completed frames, which can then be retrieved with GetCompletedFrame().</summary>
        </member>
        <member name="M:CameraLibrary.Synchronizer.GetAvailableFrame">
            <summary>Retrieves an available frame from the pool. If no frames are available, a null pointer is returned.</summary>
        </member>
        <member name="T:CameraLibrary.Synchronizer">
            <summary>A class used to track a buffer of frame objects for an individual camera.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromHardwareTimingCamera">
            <summary>True if this frame is from a camera that supports hardware timing.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromSynchronousVideoCamera">
            <summary>True if this frame is from a synchronous video source.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromFilterSwitchedCamera">
            <summary>True if this frame is from a camera that has a filter switcher.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromBaseStation">
            <summary>True if this frame is from a Base Station source.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromColorCamera">
            <summary>True if this frame is from a color camera source.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromTBar">
            <summary>True if this frame is from a TBar source.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromSyncAuthority">
            <summary>True if this frame is from a sync authority source.</summary>
        </member>
        <member name="M:CameraLibrary.Frame.IsFromCamera">
            <summary>True if this is a frame from a camera source (not a sync or other device type).</summary>
        </member>
        <member name="T:CameraLibrary.Frame">
            <summary>Data for a single camera on a single frame.</summary>
        </member>
        <member name="M:CameraLibrary.cActiveTag.SetGPIOPin(System.Int32,System.Boolean)">
            <summary>Sets the state of a GPIO pin. Also sets the number of available GPIO pin states based
on the index value that is passed.</summary>
        </member>
        <member name="M:CameraLibrary.cActiveTag.GPIOPin(System.Int32)">
            <summary>GPIO pin state.</summary>
        </member>
        <member name="M:CameraLibrary.cActiveTag.GPIOPinCount">
            <summary>Number of available GPIO pin states.</summary>
        </member>
        <member name="M:CameraLibrary.cActiveTag.TimeStampOffset">
            <summary>Offset (in ns) from the beginning of the frame.</summary>
        </member>
        <member name="M:NMotive.NMotiveException.#ctor(System.String,System.Exception)">
            <summary>
Constructs an <c>NMotiveException</c> object with the given
message and inner exception.
</summary>
            <param name="message">Exception message.</param>
            <param name="innerException">Inner exception.</param>
        </member>
        <member name="M:NMotive.NMotiveException.#ctor(System.String)">
            <summary>
Constructs an <c>NMotiveException</c> object with the given
message.
</summary>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:NMotive.NMotiveException.#ctor">
            <summary>
Constructs an empty <c>NMotiveException</c> object.
</summary>
        </member>
        <member name="T:NMotive.NMotiveException">
            <summary>
Class for a general exception thrown by NMotive code.
</summary>
        </member>
        <member name="M:NMotive.TakeProcessor.DefaultFramesRangeSet(NMotive.Take)">
            <summary>
The default range set for a take if none is specified.
</summary>
            <param name="take">The take.</param>
            <returns>The default frame range set for the take.</returns>
        </member>
        <member name="M:NMotive.TakeProcessor.SelectMarkersToProcess(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID},System.Int32)">
            <summary>
Selects in the take the markers with the specified ID's.
</summary>
            <param name="take">Select the markers in this take.</param>
            <param name="markerIDs">ID's of the markers to select.</param>
            <param name="indexOfPrimarySelection">The index into the <code>markerIDs</code> list of
the primary selection.</param>
        </member>
        <member name="M:NMotive.TakeProcessor.Process(NMotive.Take)">
            <summary>
Processes the given take. 
</summary>
            <param name="take">The take to process.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="P:NMotive.TakeProcessor.Progress">
            <summary>
Gets and sets the progress indicator for this processor.
</summary>
        </member>
        <member name="P:NMotive.TakeProcessor.Name">
            <summary>
Gets the name for this processor.
</summary>
        </member>
        <member name="M:NMotive.TakeProcessor.#ctor(NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>TakeProcessor</c> object with the given progress
indicator.
</summary>
            <param name="progress">Progress indicator used by this processor.</param>
        </member>
        <member name="M:NMotive.TakeProcessor.#ctor">
            <summary>
Constructs a <c>TakeProcessor</c> object.
</summary>
        </member>
        <member name="T:NMotive.TakeProcessor">
            <summary>
Abstract base class for take processing classes.
</summary>
        </member>
        <member name="P:NMotive.Result.Message">
            <summary>
Gets the message.
</summary>
        </member>
        <member name="P:NMotive.Result.Success">
            <summary>
Gets the success state.
</summary>
        </member>
        <member name="M:NMotive.Result.#ctor(System.Boolean,System.String)">
            <summary>
Constructs a <c>Result</c> object with the given success state 
and message.
</summary>
            <param name="success">The success state.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:NMotive.Result.#ctor">
            <summary>
Constructs a <c>Result</c> object with success set to <c>false</c>
empty message property.
</summary>
        </member>
        <member name="T:NMotive.Result">
            <summary>
Class representing the result of an operation. It indicates success or
failure and an information message (most useful when the result is
failure).
</summary>
        </member>
        <member name="P:NMotive.ProgressIndicator.IsCanceled">
            <summary>
Gets and sets the cancelled property. This property will be 
checked by the consumer code periodically to see if the operation
had been canceled.
</summary>
        </member>
        <member name="M:NMotive.ProgressIndicator.Finish">
            <summary>Call this to finish a measured task.</summary>
        </member>
        <member name="P:NMotive.ProgressIndicator.Message">
            <summary>Gets the current message.</summary>
        </member>
        <member name="P:NMotive.ProgressIndicator.Progress">
            <summary>Gets the current progress value.</summary>
        </member>
        <member name="M:NMotive.ProgressIndicator.SetMessage(System.String)">
            <summary>Set the message to display to the user.</summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:NMotive.ProgressIndicator.SetProgress(System.Single)">
            <summary>
Set the progress as a float value between 0 and 1.
</summary>
            <param name="progress">A float value in the range [0.0, 1.0] with 1.0 meaning
complete.</param>
        </member>
        <member name="M:NMotive.ProgressIndicator.SetProgress(System.UInt32)">
            <summary>
Called to update progress value directly. Progress is in the range [0,100].
</summary>
            <param name="percent">Progress as a percentage in the range [1,100]</param>
        </member>
        <member name="M:NMotive.ProgressIndicator.IncrementProgress">
            <summary>Called to increase the progress by one increment.</summary>
        </member>
        <member name="M:NMotive.ProgressIndicator.Start(System.String,System.UInt32)">
            <summary>This is called to run the operation using the given progress indicator.</summary>
            <param name="message">A user-facing message to display during the task.</param>
            <param name="incrementCount">The number of progress increments that the task will take to complete.</param>
        </member>
        <member name="F:NMotive.ProgressIndicator.mIsCancelled">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mMessage">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mProgressCount">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mIncrementCount">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mProgressPercent">
            <exclude />
        </member>
        <member name="T:NMotive.ProgressIndicator">
            <summary>
Class for indicating progress and messages pertaining to an operation.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SelectedRangesChanged">
            <summary>Called when selected frame ranges change.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.RunModeChanged(System.UInt32)">
            <summary>Called when the run mode changes.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.VisibleRangeChanged">
            <summary>Called when the playback range changes.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.PlayRangeChanged">
            <summary>Called when the playback range changes.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.AnimationRangeChanged">
            <summary>Called when the valid animation range changes.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.TimeStepChanged">
            <summary>Called when the playback frame rate changes.</summary>
        </member>
        <member name="F:MoCapCore.cTimeManager.kDefaultFrameRate">
            <summary>The default time step applied at creation, and usable for resetting to default.</summary>
        </member>
        <member name="F:MoCapCore.cTimeManager.kDefaultAnimationRange">
            <summary>The default animation range applied at creation, and usable for resetting to default.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.VisibleRange">
            <summary>Get the current play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetVisibleRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the "visible" time range, which is always a subset of the full animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.HasSelectedRanges">
            <summary>Returns true if there is a non-empty time selection.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SelectedRanges">
            <summary>Returns the number of (disconnected) selected frame ranges.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.ClearSelectedRanges">
            <summary>Clears all frame selections.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SelectRanges(Core.cFrameRangeSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Replace any current range selection with the given range set.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SelectRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Add the given range to the currently selected frame range(s).</summary>
            <param name="exclusive">If true, any existing time selection will be replaced by the one given.</param>
        </member>
        <member name="M:MoCapCore.cTimeManager.PlaySpeed">
            <summary>Returns the time scaling in effect during playback.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.FrameRate">
            <summary>Get the master frame rate (in frames/sec), based on current time step.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.TimeStep">
            <summary>Returns the current frame time step (in secs) used during playback.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Looping">
            <summary>Returns true if looping is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsPlaybackMode(MoCapCore.cTimeManager.eRunMode)">
            <summary>Returns true if the given mode is a "playback" mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsLiveMode(MoCapCore.cTimeManager.eRunMode)">
            <summary>Returns true if the given mode is a "live" mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsLive">
            <summary>Returns true if we are in a live mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsPaused">
            <summary>Returns true if playback is paused.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsPlaying">
            <summary>Returns true if playback is active (not real-time, paused, or recording).</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsRecording">
            <summary>Returns true if recording is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.CanGoLive">
            <summary>Returns true if the system can go live and/or record.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.RecordingDurationComplete">
            <summary>Returns true if the recording duration has been reached.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.RecordingDuration">
            <summary>The current requested recording duration, if recording. Zero otherwise.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.PlayRange">
            <summary>Get the current play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.AnimationRange">
            <summary>Get the current valid animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.DisplayFrame(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Applies logic to determine the values that should be displayed for frame time. If in Live mode,
this will return zero until recording starts. If in playback mode, it will return the current frame.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.CurrentFrame">
            <summary>Gets the current frame number.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.RunMode">
            <summary>Current run mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetPlaySpeed(System.Double)">
            <summary>Set the time scaling to use during playback, in the range [0.01, 100.0].</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetFrameRate(System.Double)">
            <summary>Set the master frame rate. This is the playback rate when playing back at 100% play speed.</summary>
            <returns>True if the given step size was valid and set.</returns>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetPlaybackType(MoCapCore.cTimeManager.ePlaybackType,System.Boolean)">
            <summary>
Set playback type, choosing between looping / bounce and EndPoint.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetLooping(System.Boolean,System.Boolean)">
            <summary>
Set looping on or off. When looping is on, playback will reset to the other end of the
play range if playback is stepped beyond the end.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetPlayRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the valid playback range, which must be a subset of the animation range.</summary>
            <param name="keepTimeInRange">If true, current time will be changed as needed to lie within the new play range.</param>
            <returns>False if the range was already equal to the value passed.</returns>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetAnimationRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the full valid range for any playback, time selection, etc.</summary>
            <param name="keepTimeInRange">If true, current time will be changed as needed to lie within the new range.</param>
            <returns>False if the range was already equal to the value passed.</returns>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetCurrentFrame(System.Int32,System.Boolean,System.Boolean)">
            <summary>Set the current frame. Run mode status is unaffected.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.GoToEnd">
            <summary>Sets the current time to the end of the current play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.GoToStart">
            <summary>Sets the current time to the beginning of the play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Reset(System.Double,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Resets to initial state, with a given time step and animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Record(System.Int32)">
            <summary>Called by the framework to begin recording. If recording duration is zero, recording proceeds until
another run state is requested.</summary>
            <param name="recordingDuration">Prescribed amount of time to record. If zero, recording proceeds until another mode
is specified.</param>
        </member>
        <member name="M:MoCapCore.cTimeManager.Stop">
            <summary>Stop any playback and set run mode to real-time.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.StepBackward(System.UInt32)">
            <summary>Steps playback one frame backward. Stops recording or playback if either is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.StepForward(System.UInt32)">
            <summary>Steps playback forward the given number of frames. Stops recording or playback if either is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Pause">
            <summary>Pause playback.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.PlayReverse">
            <summary>
Start playback in reverse. Stops recording if recording is active. During playback,
time gets updated on TimeManager's own thread, and update notifications that go out
do so on that thread.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Play">
            <summary>
Start playback. Stops recording if recording is active. During playback, time gets
updated on TimeManager's own thread, and update notifications that go out do so on
that thread.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.ShutDown">
            <summary>Shut the thread down and prepare for tear-down.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.StartUp">
            <summary>
Must be called after construction to initialize the frame counter. Should be done toward the 
end of application startup to minimize time change notifications during startup.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.#ctor(System.Boolean)">
            <summary>Create a new instance. There should typically only be one instance of TimeManager.</summary>
            <param name="canGoLive">Sets whether live/record modes are available or not.</param>
        </member>
        <member name="T:MoCapCore.cTimeManager">
            <summary>
A singleton class that manages the playback head, including current time and recording status.
Any objects that rely on knowledge of time, playback status, or recording status should acquire
it from this object.
</summary>
        </member>
        <member name="M:Core.cThreadHelpers.ThreadID">
            <summary>Returns a unique ID for the calling thread.</summary>
        </member>
        <member name="M:Core.cThreadHelpers.Sleep(System.Int32)">
            <summary>Relinquish the CPU and wait for the given time on the caller's thread.</summary>
        </member>
        <member name="T:Core.cThreadHelpers">
            <summary>A collection of useful thread-related functions.</summary>
        </member>
        <member name="M:Core.cThread.Process">
            <summary>
Override this method to define the functionality that should run each time the thread wakes up and runs
either through continuous running, or via a call to RunOnce().
</summary>
        </member>
        <member name="M:Core.cThread.LoopWait">
            <summary>Get the current wait time between Process() calls when running.</summary>
        </member>
        <member name="M:Core.cThread.Priority">
            <summary>Get the current thread priority.</summary>
        </member>
        <member name="M:Core.cThread.IsRunning">
            <summary>Returns true if the thread is running continuously (i.e. not in RunOnce mode).</summary>
        </member>
        <member name="M:Core.cThread.Stop">
            <summary>Stop the thread (i.e. kill the thread). This effectively destroys the internal thread and calling
Run() or RunOnce() can be called after this to recreate and restart the thread.</summary>
        </member>
        <member name="M:Core.cThread.Pause(System.Boolean)">
            <summary>Pause continuous running of the thread, placing the thread in a suspended state. Run() or 
RunOnce() can be called after this.</summary>
        </member>
        <member name="M:Core.cThread.RunOnce">
            <summary>Run the processing method once (asynchronously) on this thread, then suspend the thread.
The thread will remain active in between calls to RunOnce(), but be in a suspended state. To terminate
the thread, call Stop().</summary>
        </member>
        <member name="M:Core.cThread.Run">
            <summary>Run the processing method continuously until Pause is called or the thread is
destroyed.</summary>
        </member>
        <member name="M:Core.cThread.SetLoopWait(System.Int32)">
            <summary>Set the amount of time to wait between calls to Process() when running continuously.</summary>
        </member>
        <member name="M:Core.cThread.SetPriority(Core.cThread.eThreadPriority)">
            <summary>Set the thread priority. May be called at any time.</summary>
        </member>
        <member name="T:Core.cThread">
            <summary>
A platform-neutral thread. Derive from this class and override the Process() method to define functionality
that should run each time the thread wakes up. This class manages a separate thread, but is not thread-safe
so methods on this class should be called from a single thread for each cThread instance.
</summary>
        </member>
        <member name="P:NMotive.Node.Name">
            <summary>
Gets and sets the name for this node.
</summary>
        </member>
        <member name="P:NMotive.Node.ID">
            <summary>
Gets the ID for this node.
</summary>
        </member>
        <member name="P:NMotive.Node.Active">
            <summary>
Gets and sets this nodes active state.
</summary>
        </member>
        <member name="M:NMotive.Node.#cctor">
            <exclude />
        </member>
        <member name="T:NMotive.Node">
            <summary>
Base class for all objects in a take scene.
</summary>
        </member>
        <member name="M:NMotive.FindGaps.Find(NMotive.Take)">
            <summary>
Finds gaps in the given take.
</summary>
            <param name="take">The take.</param>
            <returns>A dictionary with marker keys and gaps, represented as 
a set of <c>FrameRange</c>'s, as values.</returns>
        </member>
        <member name="P:NMotive.FindGaps.MaxGapSize">
            <summary>
Gets and sets the maximum gap size in frames. Gaps with 
lengths strictly greater than <c>MaxGapSize</c> will be not be
reported.
</summary>
        </member>
        <member name="M:NMotive.FindGaps.#ctor(System.Int32)">
            <summary>
Constructs a <c>FindGaps</c> instance with the given maximum gap
size in frames.
</summary>
            <param name="maxGapSize">Maximum gap size in frames to find. Gaps with 
lengths strictly greater than <c>maxGapSize</c> will be not be
reported.</param>
        </member>
        <member name="M:NMotive.FindGaps.#ctor">
            <summary>
Constructs a <c>FindGaps</c> instance. The default maximum gap
size is 10 frames.
</summary>
        </member>
        <member name="M:NMotive.FindGaps.#cctor">
            <exclude />
        </member>
        <member name="M:NMotive.FindGaps.Marker.GetHashCode">
            <summary>
Gets the hashcode for this marker.
</summary>
            <returns>Hash code for this object.</returns>
        </member>
        <member name="M:NMotive.FindGaps.Marker.CompareTo(NMotive.FindGaps.Marker)">
            <summary>
Function for comparing to markers. Markers are compared using their
unique ID's.
</summary>
            <param name="rhs">Marker to compare self to.</param>
            <returns>Standard integer comparison value.</returns>
        </member>
        <member name="M:NMotive.FindGaps.Marker.Equals(NMotive.FindGaps.Marker)">
            <summary>
Determines if two markers are equal. Markers are equal if the have
the same unique ID.
</summary>
            <param name="rhs">The maker to compare self to.</param>
            <returns>
                <c>true</c> if this marker is equal to <c>rhs</c></returns>
        </member>
        <member name="P:NMotive.FindGaps.Marker.Name">
            <summary>
Gets the markers name.
</summary>
        </member>
        <member name="P:NMotive.FindGaps.Marker.ID">
            <summary>
Gets the markers ID.
</summary>
        </member>
        <member name="M:NMotive.FindGaps.Marker.#ctor(NMotive.UID,System.String)">
            <summary>
Constructs a <c>Marker</c> object with the given name and ID.
</summary>
            <param name="id">The marker unique ID.</param>
            <param name="name">The marker name.</param>
        </member>
        <member name="T:NMotive.FindGaps.Marker">
            <summary>
Class encapsulating a marker name and ID. Implements the IEquatable{Marker}
and IComparable{Marker} interfaces.
</summary>
        </member>
        <member name="T:NMotive.FindGaps">
            <summary>
Class for finding gaps in 3D data which have frame lengths less than
or equal to a specified number of frames.
</summary>
        </member>
        <member name="M:NMotive.Take.Finalize">
            <exclude />
        </member>
        <member name="M:NMotive.Take.Dispose">
            <exclude />
        </member>
        <member name="M:NMotive.Take.Save(System.String)">
            <summary>
Saves the take to the given file.
</summary>
            <param name="fileName">File to save to.</param>
            <returns>The result of the save attempt.</returns>
        </member>
        <member name="M:NMotive.Take.Save">
            <summary>
Saves any changes made to the take to its associated file.
</summary>
            <returns>The result of the save attempt.</returns>
        </member>
        <member name="M:NMotive.Take.TrimTake(NMotive.FrameRange,System.Boolean)">
            <summary>
Crops a specific frame range from this take.
</summary>
            <param name="range">Frame range to crop to.</param>
            <param name="resetFrameNumber">If <c>true</c> reset the frame numbers to 
start at 0.</param>
            <returns>The result of the rewritting the trimmed take.</returns>
        </member>
        <member name="M:NMotive.Take.UpdateDataTypes">
            <summary>
Update the data type meta-data on a take..
</summary>
        </member>
        <member name="M:NMotive.Take.DeleteAudioData">
            <summary>
Removes audio data from this take.
</summary>
            <returns>true if the data was successfully removed.</returns>
        </member>
        <member name="M:NMotive.Take.DeleteVideoData">
            <summary>
Removes video data from this take.
</summary>
            <returns>true if the data was successfully removed.</returns>
        </member>
        <member name="M:NMotive.Take.Delete3dData">
            <summary>
Removes 3D data from this take.
</summary>
            <returns>true if the data was successfully removed.</returns>
        </member>
        <member name="M:NMotive.Take.Delete2dData">
            <summary>
Removes 2D data from this take.
</summary>
            <returns>true if the data was successfully removed.</returns>
        </member>
        <member name="M:NMotive.Take.HasData(NMotive.Take.DataType)">
            <summary>
Returns <c>true</c> if this take contains the given
data type.
</summary>
            <param name="dataType">The type of data.</param>
            <returns>
                <c>true</c> if this take contains the given data type.</returns>
        </member>
        <member name="M:NMotive.Take.HasGaps">
            <summary>
Checks if the take has gaps.
</summary>
            <returns>
                <c>true</c> if the take has gaps.</returns>
        </member>
        <member name="M:NMotive.Take.Solve">
            <summary>
Computes tracking data.
</summary>
            <returns>true if the operation is successful.</returns>
        </member>
        <member name="M:NMotive.Take.RemoveSolve">
            <summary>
Removes all solved data from the take.
</summary>
        </member>
        <member name="M:NMotive.Take.RemoveSolve(NMotive.FrameRangeSet)">
            <summary>
Removes solved data in the specified frame ranges from the
take.
</summary>
            <param name="frameRanges">Solved data removed from these frame
ranges.</param>
        </member>
        <member name="P:NMotive.Take.EndTimecode">
            <summary>
Gets the ending timecode for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.RecordingStartTime">
            <summary>
Gets the recording start time in Coordinated Universal Time (UTC).
</summary>
        </member>
        <member name="P:NMotive.Take.StartTimecode">
            <summary>
Gets the starting timecode for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.Best">
            <summary>
Gets and sets the "Best" property for a take.
</summary>
        </member>
        <member name="P:NMotive.Take.Scene">
            <summary>
Access to the contained NodeWarehouse
</summary>
        </member>
        <member name="P:NMotive.Take.FileName">
            <summary>
Gets the name of the file associated with the take.
</summary>
        </member>
        <member name="P:NMotive.Take.WorkingFrameRange">
            <summary>
Gets the working frame range for the take as a frame range.
</summary>
        </member>
        <member name="P:NMotive.Take.FullFrameRange">
            <summary>
Gets the full frame range for the take as a frame range.
</summary>
        </member>
        <member name="P:NMotive.Take.FullTimeRange">
            <summary>
Gets the full time range for the take as a tuple where the first member 
is the start time and the second member is the end time.
</summary>
        </member>
        <member name="P:NMotive.Take.FrameTime">
            <summary>
Gets the master frame time (in seconds per frame).
</summary>
        </member>
        <member name="P:NMotive.Take.Notes">
            <summary>
Gets and sets the notes field for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.Name">
            <summary>
Gets and sets the name for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.FrameRate">
            <summary>
Gets the frame rate for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.SessionID">
            <summary>
Gets the session ID for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.ID">
            <summary>
Gets the unique ID for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.BuildNumber">
            <summary>
Gets the Motive software build number which the take was recorded
with.
</summary>
        </member>
        <member name="P:NMotive.Take.SoftwareVersionString">
            <summary>
Gets a string representation Motive software version number which the take
 was recorded with.
</summary>
        </member>
        <member name="P:NMotive.Take.SoftwareVersion">
            <summary>
Gets the Motive software version number which the take was recorded
with. The value is hexadecimal that can be used for comparisons.
</summary>
        </member>
        <member name="M:NMotive.Take.#ctor(System.String)">
            <summary>
Constructs a take from the data in the given take file.
</summary>
            <param name="takeFilename">A take file.</param>
        </member>
        <member name="M:NMotive.Take.#ctor">
            <summary>
Constructs an empty take.
</summary>
        </member>
        <member name="F:NMotive.Take.DataType.AllTypes">
            <summary>Has all of the types of data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.Audio">
            <summary>Audio data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.Video">
            <summary>Video data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.Bones">
            <summary>Joint angle data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.e3D">
            <summary>3D data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.e2D">
            <summary>2D data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.None">
            <summary>No data.</summary>
        </member>
        <member name="T:NMotive.Take.DataType">
            <summary>
Types of data that a take may contain.
</summary>
        </member>
        <member name="T:NMotive.Take">
            <summary>
Owns all animation data for a take, as well as setup info for cameras (calibration, etc.).
</summary>
        </member>
        <member name="M:NMotive.Timecode.SetValue(System.UInt32,System.Int32)">
            <summary>
Set timecode values from the Motive integer format for timecode and 
subframe number.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
            <param name="subframe">Subframe number.</param>
            <returns>
                <c>true</c> if the conversion was successful.</returns>
        </member>
        <member name="M:NMotive.Timecode.SetValue(System.UInt32)">
            <summary>
Set timecode values from the Motive integer format for timecode.
Subframe number is set to 0.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
            <returns>
                <c>true</c> if the conversion was successful.</returns>
        </member>
        <member name="P:NMotive.Timecode.Subframe">
            <summary>
Gets and sets the subframe portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Frame">
            <summary>
Gets and sets the frame portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Seconds">
            <summary>
Gets and sets the seconds portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Minutes">
            <summary>
Gets and sets the minutes portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Hours">
            <summary>
Gets and sets the hours portion of the timecode.
</summary>
        </member>
        <member name="M:NMotive.Timecode.#ctor(System.Int64)">
            <summary>
Constructs a <c>Timecode</c> object and intializes its values from
the Motive integer64 format for timecode.
</summary>
            <param name="timecodeWithSubframe">Motive integer64 timecode format.</param>
        </member>
        <member name="M:NMotive.Timecode.#ctor(System.UInt32,System.Int32)">
            <summary>
Constructs a <c>Timecode</c> object and intializes its values from
the Motive integer format for timecode.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
            <param name="subframe">Subframe number.</param>
        </member>
        <member name="M:NMotive.Timecode.#ctor(System.UInt32)">
            <summary>
Constructs a <c>Timecode</c> object and intializes its values from
the Motive integer format for timecode.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
        </member>
        <member name="M:NMotive.Timecode.#ctor">
            <summary>
Constructs a <c>Timecode</c> object with all values set to zero.
</summary>
        </member>
        <member name="T:NMotive.Timecode">
            <summary>
Class representing SMPTE timecode. 
</summary>
        </member>
        <member name="M:MotiveCore.cFileIOHelpers.SaveTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cTakeManager&gt;,std.shared_ptr&lt;MoCapCore.cIStreamsManager&gt;)">
            <summary>Save a take to an arbitrary location on disk.</summary>
        </member>
        <member name="M:MotiveCore.cFileIOHelpers.LoadTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cTakeManager&gt;,std.shared_ptr&lt;MoCapCore.cTimeManager&gt;,System.Boolean)">
            <summary>Load a take from an arbitrary location on disk.</summary>
        </member>
        <member name="T:MotiveCore.cFileIOHelpers">
            <summary>A loader/saver application layer class for takes.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Hash">
            <summary>Returns a unique value for the contents of this instance. Another instance may have the same
value if it has exactly the same contents.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Merge(MoCapCore.cPipelineFrame!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Merge the contents of the given instance into this one.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.IsEmpty">
            <summary>True if there are no data bundles. Meta-information may also be empty or invalid.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.HasDataBundle(System.Int32)">
            <summary>Determine whether a data bundle for the given type exists.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.DataBundle(System.Int32)">
            <summary>Retrieve the data bundle for the given type. Returns an invalid shared pointer if a bundle of the requested
type has not been set.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.RemoveDataBundle(System.Int32)">
            <summary>Remove a bundle type.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SetDataBundle(std.shared_ptr&lt;Core.cIDataTypeBundle!System.Runtime.CompilerServices.IsConst&gt;)">
            <summary>Set the data bundle of the given type.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.UseHighPrecision">
            <summary>If true, downstream solvers and others should use best precision to settle solutions, etc.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.ClockOutputStatus">
            <summary>The bitwise-encoded clock output state.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.FrameDeliveryRate">
            <summary>Frames per second.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Recording">
            <summary>True if this frame is to be recorded.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SystemTimestamp">
            <summary>The system (CPU) time since application startup.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Timestamp">
            <summary>The frame timestamp, in seconds.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.PrecisionTimestamp">
            <summary>The frame timestamp, in seconds.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.TimeCode">
            <summary>The frame timestamp, in seconds.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SystemFrame">
            <summary>The system frame number, without any offsets for recording.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Frame">
            <summary>The frame number. This will be zero-based during a recording.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.TakeID">
            <summary>The ID of the take from which this frame was extracted. Live pipeline frames will have
an invalid take ID.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SetUseHighPrecision(System.Boolean)">
            <summary>Sets whether to use high precision solving.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SetMetaData(MoCapCore.sPipelineMetaData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the frame number, time code, timestamp, and whether or not this frame is to be recorded,
along with other ancillary frame information.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Clear">
            <summary>Clears all data and prepares this instance to be reused. This is useful for reusing memory
that has been previously allocated </summary>
        </member>
        <member name="T:MoCapCore.cPipelineFrame">
            <summary>
A container class that holds all the accumulated data streams and telemetry information for a single frame of data.
Data objects in this container may be set once and only once until the entire container is cleared.
This is to help ensure write-once/read-many behavior.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.DefaultSessionPath">
            <summary>Get the default session directory.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.CopyNodesToTake(std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>Copy a collection of nodes from the current take to a target take.</summary>
            <param name="overwriteExisting">If true, overwrite any duplicate (by ID) nodes found in the target take.</param>
            <param name="overwriteExisting">If true, include the collection of nodes in the hierarachy under every requested sourceNode.</param>
        </member>
        <member name="M:MoCapCore.cTakeManager.PrimarySelectedTake">
            <summary>Convenience method to retrieve the primary selected take in the current session.</summary>
            <returns>An invalid ID if no take is selected in the current session.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.SelectedTakes(std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;*)">
            <summary>Convenience method to retrieve the composite list of ID's of selected takes across all sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.ClearSelectedTakes">
            <summary>De-selects all selected takes.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SeedTake">
            <summary>
Access the "seed" take that is used as the master when populating a new take for recording.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Search a take with the given file path.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Search among all sessions, starting with the current session, to locate the take with the given
ID.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Search to find a take with the given name that belongs to the session with the given ID.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.RewriteTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
            <summary>Overwrites an existing take with a new take that has the given property adjustments.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.MoveCopySession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Moves/Copies the Session with the given ID to another session.</summary>
            <returns>True if the session is moved/Copied.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.CopyTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copies the take with the given ID from one session to another.</summary>
            <returns>True if the take was found and copied.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.MoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Moves the take with the given ID from one session to another.</summary>
            <returns>True if the take was found and moved.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.RemoveAllTakesInSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>
Remove all takes in the given session, and optionally remove session and delete the session 
directory if it contains no other files.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.RemoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>
Search among all sessions, starting with the current session, and attempt to find and remove
the take with the given ID.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetEditableCurrentTake">
            <summary>
Attempts to set the current take to the non-seed take that was last current. If a valid
choice can't be found, the current take is set to the seed take and false is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetCurrentTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Search among all sessions to locate the take with the given ID, setting it as the current take if found.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.CurrentTake">
            <summary>convenience method for retrieving the current take from the current session.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.PopulateEmptyTake">
            <summary>
Use the current suggested take name to either locate an existing (empty) take or create a new take.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AddTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convenience method for adding a new take to a given session. If the take doesn't already exist, the
given suggested take name is used as the seed for the name of the new take, but the caller should
query the Name property of the take that is returned to get the final name.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AddTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a new or existing take, also adding any parent sessions that are needed. The passed
filename should be a full path and filename.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SuggestedTakeName">
            <summary>Retrieve the current suggested take name.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetSuggestedTakeName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the suggested name to use for the next new take. The name may be augmented to make it
unique before actually creating a take.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.TopLevelSessions(std.vector&lt;MoCapCore.cSession**,std.allocator&lt;MoCapCore.cSession**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve a list of all top-level sessions (i.e. sessions with no parent).</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AllSessions(std.vector&lt;MoCapCore.cSession**,std.allocator&lt;MoCapCore.cSession**&gt;&gt;*)">
            <summary>Retrieve a list of all existing sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SessionByIndex(System.UInt32)">
            <summary>Get a session by index. Returns the default session if index is out of range.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SessionCount">
            <summary>Get the number of available sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.ContainsCurrentSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given session is or contains the current recording session.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.CurrentSession">
            <summary>Get the current session.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindSession(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the session with the given path.</summary>
            <returns>The session, if found. NULL otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindSession(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the session with the given name.</summary>
            <returns>The session, if found. NULL otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the session with the given ID.</summary>
            <returns>The session, if found. NULL otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetCurrentSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the current session by session ID. The active take within the session will also be
set as the active take if the active session is changed through this call.
</summary>
            <returns>True if the session was found and set current.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.RemoveSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Remove the session with the given ID. Sessions that still contain takes cannot be deleted
until all takes have either been moved to another session, or removed from the session. At
least one session must always exist, so the last session may not be deleted. Use Clear() to
remove all current sessions and reset to a fresh state.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AddSession(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Add a new session with the given path. The session will be created if it does not
already exist, or just returned if it does.</summary>
            <param name="makeCurrent">If true, the named session will be set as the current session.</param>
        </member>
        <member name="M:MoCapCore.cTakeManager.IsDirty">
            <summary>Returns true if any session or takes have changed since last save/load.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SaveDirtyTakes">
            <summary>Save any unsaved or changed (dirty) takes.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.ResumeNotifications">
            <summary>Resume notifications and emit any notifications that accrued since suspended.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SuspendNotifications">
            <summary>Suspend all notifications and start keeping track of which ones need to fire.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.Empty">
            <summary>Returns true if there are no available takes in any sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.Clear(System.Boolean,System.Boolean)">
            <summary>Clears all sessions and takes.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.ShutDown">
            <summary>Shut down the manager, preparing for application exit.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.Initialize(std.shared_ptr&lt;MoCapCore.cIStreamsManager&gt;,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,std.shared_ptr&lt;MoCapCore.cIChannelFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cINodeFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cIPropertyProvider&gt;,std.unique_ptr&lt;MoCapCore.cILegacyTakeLoader,std.default_delete&lt;MoCapCore.cILegacyTakeLoader&gt;&gt;)">
            <summary>Start up and initialize the manager.</summary>
        </member>
        <member name="T:MoCapCore.cTakeManager">
            <summary>
A class for managing sessions, take loading, session and take creation, and take application.
</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnTakeListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the take list for a specific session has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSessionUpdated(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when session is updated.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSelectedTakeListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the list of selected takes changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSuggestedTakeNameChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called anytime the suggested take name is altered.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSessionListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called after sessions are added to or removed from the loaded sessions list.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnTakeListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called after takes are added to or removed from the loaded takes list.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnCurrentSessionChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current session has been swapped out.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnCurrentTakeChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current take has been swapped out.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnCurrentTakeChanging(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current take is about to change.</summary>
        </member>
        <member name="M:MoCapCore.cSessionsWatcher.AddUpdatePath(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trigger a refresh of the session path.</summary>
        </member>
        <member name="M:MoCapCore.cSessionsWatcher.Resume">
            <summary>Called to resume monitoring after a pause.</summary>
        </member>
        <member name="M:MoCapCore.cSessionsWatcher.Pause">
            <summary>Called to pause the watcher so that changes to the monitored paths do not result
in any monitoring or updates. May be called multiple times as long as each call is matched
with a call to Resume().</summary>
        </member>
        <member name="M:MoCapCore.cSessionsWatcher.RemoveSession(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Stop watching the given session.</summary>
        </member>
        <member name="M:MoCapCore.cSessionsWatcher.AddSession(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Begin watching the given session. Does not populate the takes in that session.</summary>
        </member>
        <member name="M:MoCapCore.cILegacyTakeLoader.LoadLegacyTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize this object to the given writer.</summary>
        </member>
        <member name="M:MoCapCore.cSession.ChildNumber">
            <summary>The index of this session in its parent's child list.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Refresh">
            <summary>Force the watcher to update the list of takes, which could be until now empty.</summary>
        </member>
        <member name="M:MoCapCore.cSession.AllChildSessions(std.vector&lt;MoCapCore.cSession**,std.allocator&lt;MoCapCore.cSession**&gt;&gt;*)">
            <summary>Retrieve the list of all child sessions.</summary>
        </member>
        <member name="M:MoCapCore.cSession.RemoveChild(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to remove the given child. Also sets its parent to null.</summary>
        </member>
        <member name="M:MoCapCore.cSession.AddChild(MoCapCore.cSession*)">
            <summary>Add a child session to this parent. Child must have no existing parent.</summary>
        </member>
        <member name="M:MoCapCore.cSession.ParentSession">
            <summary>
Returns parent session. All sessions displayed in tree have always parent. Top level session's parent
is tree root item (it is invisible in tree).
</summary>
        </member>
        <member name="M:MoCapCore.cSession.IsDescendentOf(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this session is descended from (or equal to) the given session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindUniqueTakeName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Find a take name that is currently unique among takes in the session and on disk. The name will
use the given name as a seed starting point and append a suffix if needed to make it unique.
</summary>
        </member>
        <member name="M:MoCapCore.cSession.IsDirty">
            <summary>Returns true if any of the contained takes is dirty.</summary>
        </member>
        <member name="M:MoCapCore.cSession.UsingSeedTake">
            <summary>Returns true if the active take is the live (seed) take.</summary>
        </member>
        <member name="M:MoCapCore.cSession.PrimarySelectedTake">
            <summary>Retrieve the primary selected take, if any.</summary>
        </member>
        <member name="M:MoCapCore.cSession.SelectedTakes(std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;*)">
            <summary>Retrieve any selected takes.</summary>
        </member>
        <member name="M:MoCapCore.cSession.AllTakes(std.vector&lt;MoCapCore.cTake**,std.allocator&lt;MoCapCore.cTake**&gt;&gt;*)">
            <summary>Retrieve a list of all takes currently contained in the session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.TakeByIndex(System.UInt32)">
            <summary>Get a take by index, or the dummy take if index is out of range.</summary>
        </member>
        <member name="M:MoCapCore.cSession.TakeCount">
            <summary>Get the number of takes.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindEmptyTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*)">
            <summary>
Finds an empty take with the proposed name, or applies the following criteria to find an existing take
with a modified name.
 * Currently active take is empty take, given name is same name - ok use it (do not create new take)
 * Currently active take is empty take, text box has different name - create new take with given name (autogen if empty)
 * Currently active take is non-empty take - name is same name - create new take with autogen name
 * Currently active take is non-empty take - name is different name - create new take with given name
</summary>
            <returns>The existing take, if an appropriate choice is found. If an existing take is not found, the ioProposedName
parameter is adjusted to an acceptable name for a new take if the caller chooses to create one.</returns>
        </member>
        <member name="M:MoCapCore.cSession.FindChildByFolderID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to locate a child session in this session that has the given folder ID.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindTakeByFileID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to locate a contained take by its file ID (the ID unique to the take's file on disk).</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to find a take in this session with the given filename (including path).</summary>
            <returns>The take with the given label, or NULL if none found.</returns>
        </member>
        <member name="M:MoCapCore.cSession.FindTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the first take in the list with the given ID.</summary>
            <returns>The take with the given ID, or NULL if none found.</returns>
        </member>
        <member name="M:MoCapCore.cSession.FindTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the first take in the list with the given label. Labels are not required to be unique.</summary>
            <returns>The take with the given label, or NULL if none found.</returns>
        </member>
        <member name="M:MoCapCore.cSession.CurrentTake">
            <summary>Get the current take. This may be a dummy (but valid) take if no takes have been added.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FolderID">
            <summary>Retrieve the unique identifier used to locate this session (folder) in the file system.</summary>
        </member>
        <member name="M:MoCapCore.cSession.ID">
            <summary>Get the unique ID for this session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Path">
            <summary>Get the full path to the session folder.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Name">
            <summary>Get the name of this session (equivalent to the session folder name).</summary>
        </member>
        <member name="M:MoCapCore.cSession.ClearSelection">
            <summary>De-selects any selected takes.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Clear">
            <summary>Removes all takes except the seed/dummy take.</summary>
        </member>
        <member name="M:MoCapCore.cSession.SetEditableCurrentTake">
            <summary>Attempts to set the current take to the non-seed take that was last current. If a valid
choice can't be found, the current take is set to the seed take and false is returned.</summary>
            <returns>cFileHelpers::ResultOK if take was found and set current. cFileHelpers::NoFile if the take was not found
in this session.</returns>
        </member>
        <member name="M:MoCapCore.cSession.SetCurrentTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the current take by take ID.</summary>
            <returns>cFileHelpers::ResultOK if take was found and set current. cFileHelpers::NoFile if the take was not found
in this session.</returns>
        </member>
        <member name="M:MoCapCore.cSession.IsTakeLabelDefault(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Whether the take label has been (most probably) generated here by GenerateTakeLabel().</summary>
        </member>
        <member name="M:MoCapCore.cSession.GenerateTakeLabel">
            <summary>Generate a unique take label within this session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.MoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSession*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Moves the take with the given index from the given session into this one.</summary>
            <returns>True if the take was found and moved.</returns>
        </member>
        <member name="M:MoCapCore.cSession.RemoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>Remove the take with the given ID.</summary>
            <returns>True if the take was found and removed.</returns>
        </member>
        <member name="M:MoCapCore.cSession.AddTake(MoCapCore.cTake*,System.Boolean)">
            <summary>Add the given take.</summary>
        </member>
        <member name="M:MoCapCore.cSession.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the name (which also sets the session folder name). Setting this value will cause
the session folder on disk to be renamed as well.
</summary>
        </member>
        <member name="M:MoCapCore.cSession.#ctor(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cTake*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSessionsWatcher*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Create a new session.</summary>
            <param name="requestedName">
Try to use this name for the new session. The system will attempt to use this name first,
then will hunt for a similar unique name if makeUnique is true. If no reasonable name can be
found then the name is set to blank.
</param>
        </member>
        <member name="T:MoCapCore.cSession">
            <summary>
Owns all takes within a session.
</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnSelectedTakeListChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the list of selected takes in the session changes.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnTakeListChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when takes are added or removed from the takes list.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnCurrentTakeChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current take is swapped out.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnCurrentTakeChanging(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called just prior to swapping out the current take.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnNameChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the session name changes.</summary>
        </member>
        <member name="F:MoCapCore.cIProfileSubscriber.kGroupLabelInternal">
            <summary>Profile categories to display in UI.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ResetToDefault">
            <summary>Reset options/settings to their default values.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.LoadFromProfile(tinyxml2wc.XMLElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>De-serialize this object from the given XML element.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.SaveToProfile(tinyxml2wc.XMLElement*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize this object to an XML element.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileGroupLabel">
            <summary>A human-readable category of the information that this subscriber provide to display in UI.
This category will not be persisted with the user profile, and may change over time.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileDescription">
            <summary>A human-readable description of the information that this subscriber provides.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileLabel">
            <summary>A human-readable label to use for display in UI and other places. This label will not be persisted
with the user profile, and may change over time.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileTypeName">
            <summary>Returns a class-specific subscriber type name that does not change over time. This is also
the section name that will be used when writing the XML content for this subscriber. This
name must be unique among subscribers added to the ProfileManager.</summary>
        </member>
        <member name="T:MoCapCore.cIProfileSubscriber">
            <summary>
Interface for all classes that would like to participate in the User Profile system.
</summary>
        </member>
        <member name="M:Core.cTimeCode.TimeCodeWithSubFrame">
            <summary>Composite, compact timecode value (hours/mins/secs/frames/subframes).</summary>
        </member>
        <member name="M:Core.cTimeCode.TimeCode">
            <summary>Composite, compact timecode value (hours/mins/secs/frames).</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.AddLabelSource(std.shared_ptr&lt;MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a label source to our available list of sources.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.Clear">
            <summary>Remove all label sources.</summary>
        </member>
        <member name="T:MoCapCore.cILabelWarehouse">
            <summary>Warehouse class for label sources which provide available labels.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouseObserver.OnLabelListChanged(MoCapCore.cILabelWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever the available labels list changes.</summary>
        </member>
        <member name="M:MoCapCore.cTake.CurrentSoftwareVersion">
            <summary>Current running instance's version and build number.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetSoftwareVersion(System.UInt32,System.UInt32)">
            <summary>Call this to set the software version number that will be used to check for attempts to read
newer files into older software. It also gets stamped as meta-data for all new takes.</summary>
        </member>
        <member name="M:MoCapCore.cTake.LoadData(MoCapCore.cIDataStreamWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load take data from the given (already open) stream warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SaveData(MoCapCore.cIDataStreamWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Save take data (nodes and calibration). Node animation data will only be available if the
take is open.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.UpdateDataTypes">
            <summary>Forces an update of the internal data type meta-data based on data currently contained in the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.MarkClean">
            <summary>Mark the take as "clean" (i.e. not needing saving).</summary>
        </member>
        <member name="M:MoCapCore.cTake.MarkDirty">
            <summary>
Mark the take as dirty and notify observers. 
Once the take is marked dirty, it remains in memory even after switching to another take or to live mode,
until it is saved. So call this function with care. When the memory consumption increases, frame drop starts to
occur during recording. 
</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetFrameRate(System.Double)">
            <summary>Set the master frame rate for this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetSession(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the session this instance is attached to. Used to move takes between sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTake.DefaultFileExtension">
            <summary>Returns the file extension to use when loading/saving (without the '.').</summary>
        </member>
        <member name="M:MoCapCore.cTake.FileID">
            <summary>Retrieve the unique file identifier that can be used to identify this take file
on the file system (file system dependent).</summary>
        </member>
        <member name="M:MoCapCore.cTake.IsOpen">
            <summary>Returns true if the take is fully loaded from disk. Will be false if only meta-data is loaded.</summary>
        </member>
        <member name="M:MoCapCore.cTake.IsDirty">
            <summary>Returns true if data has changed since last save, or the take has not been saved.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FileExtension">
            <summary>Get the file extension used when loading/saving.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FileName">
            <summary>Get the full filename (with path and extension) to use for this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Close(System.Boolean,System.Boolean)">
            <summary>Close the take, but retain meta-data. Saves if saveIfNeeded is true and IsDirty is true.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Open(System.Boolean)">
            <summary>Load from the filename given by FileName().</summary>
        </member>
        <member name="M:MoCapCore.cTake.SaveTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStreamWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
            <summary>
Save to an arbitrary filename. Does not change name or filename. The passed stream
warehouse must not be open and will only be used if the requested filename does not match
the current take filename.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.Save(System.Boolean)">
            <summary>Save to our persistence stream if data has changed.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SoftwareVersionToString(System.UInt32)">
            <summary>Utility function to convert encoded software version number to a string.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetProgressIndicator(System.UInt32)">
            <summary>Progress indicator.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetHealthIndicator(System.UInt32)">
            <summary>Health indicator</summary>
        </member>
        <member name="M:MoCapCore.cTake.ToTime(System.Int32)">
            <summary>Convert a frame to a time, using the current time and frame range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ToTimeCode(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a frame number to timecode, if available. The returned timecode structure
will have its Invalid flag set if no timecode is available.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.SystemFrame(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to retrieve a "system" frame from a given take frame index. The system frame is the frame ID
of the frame group as it originally came from the cameras. If no camera data is present, FrameIndex::kInvalid
is returned.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FractionalFrame(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a time to a fractional frame value based on the current take time range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.AssetList">
            <summary>A string representing the names of the assets in the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.CaptureStartTime">
            <summary>Retrieve the time (date/time) when the take was captured.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetCaptureStartTime(QDateTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set captured frame rate</summary>
        </member>
        <member name="M:MoCapCore.cTake.HasGaps">
            <summary>
Determines whether there are any gaps in reconstructed data. Will be false if data has not been
reconstructed yet.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.IsBest">
            <summary>Get best.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetBest(System.Boolean)">
            <summary>Set best.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Notes">
            <summary>Get user notes.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetNotes(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set user notes.</summary>
        </member>
        <member name="M:MoCapCore.cTake.HasData(System.Int32)">
            <summary>
Returns true if data of the requested type is present. If AllData is requested, true will
be returned if any data types are present.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.DataTypes">
            <summary>Retrieve which types of data are present.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FullTimeRange">
            <summary>Retrieves the full time range of all 2D/3D data.</summary>
        </member>
        <member name="M:MoCapCore.cTake.WorkingFrameRange">
            <summary>Retrieves the working frame range of all 2D/3D data.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetWorkingFrameRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the working range to use for this take. Must be a strict sub-range of the full
animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FullFrameRange">
            <summary>Retrieves the full frame range of all 2D/3D data.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FrameRate">
            <summary>Returns the master frame rate (in frames per second).</summary>
        </member>
        <member name="M:MoCapCore.cTake.FrameTime">
            <summary>Returns the master frame time (in seconds per frame).</summary>
        </member>
        <member name="M:MoCapCore.cTake.Track(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
            <summary>Retrieve the track with the given name, or NULL if none.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Track(System.UInt32)">
            <summary>Retrieve the track at the given index, or NULL if none.</summary>
        </member>
        <member name="M:MoCapCore.cTake.TrackCount">
            <summary>Returns the current track count.</summary>
        </member>
        <member name="M:MoCapCore.cTake.AddTrack(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
            <summary>Allocates a new track and returns the new instance. Ownership remains with the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Selected">
            <summary>Retrieve the selection state.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetSelected(System.Boolean)">
            <summary>Set the selection state.</summary>
        </member>
        <member name="M:MoCapCore.cTake.UpdateCachedCameraCalibrationPoses">
            <summary>Update the cached calibration poses from the default camera node values.</summary>
        </member>
        <member name="M:MoCapCore.cTake.UpdateCachedCameraCalibrationPoses(std.map&lt;System.UInt32,Core.cPose&lt;System.Single&gt;,std.less&lt;System.UInt32&gt;,std.allocator&lt;std.pair&lt;System.UInt32!System.Runtime.CompilerServices.IsConst,Core.cPose&lt;System.Single&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Update the cached calibration pose for the given cameras.</summary>
        </member>
        <member name="M:MoCapCore.cTake.CameraCalibrationSerialNumbers">
            <summary>Retrieve list of serial numbers from camera calibration.</summary>
        </member>
        <member name="M:MoCapCore.cTake.CameraCalibration(System.UInt32)">
            <summary>Retrieve calibration object information for the given camera.</summary>
        </member>
        <member name="M:MoCapCore.cTake.HasCalibrationInfo">
            <summary>Returns true if the calibration object is valid.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ExtractCalibration(System.Boolean)">
            <summary>Extract calibration info from the cameras in the node warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cTake.UpdateAnchorConstraintGraphs">
            <summary>Create anchor marker constraint graphs for all cameras.</summary>
        </member>
        <member name="M:MoCapCore.cTake.RemoveAnchorMarkers(std.unordered_set&lt;Core.cUID,std.hash{Core.cUID},std.equal_to&lt;Core.cUID&gt;,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Remove list of anchor markers.</summary>
        </member>
        <member name="M:MoCapCore.cTake.AddAnchorMarkers(std.vector&lt;Core.cTMarker&lt;System.Single&gt;,std.allocator&lt;Core.cTMarker&lt;System.Single&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;Core.cUID,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;,std.less&lt;Core.cUID&gt;,std.allocator&lt;std.pair&lt;Core.cUID!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add list of anchor markers. Returns false if there was a marker with the same ID already 
in the anchor list--in this case it will update the position for that marker.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetAnchorMarkers(std.vector&lt;Core.cTMarker&lt;System.Single&gt;,std.allocator&lt;Core.cTMarker&lt;System.Single&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;Core.cUID,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;,std.less&lt;Core.cUID&gt;,std.allocator&lt;std.pair&lt;Core.cUID!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set list of anchor markers.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ClearAnchorMarkers">
            <summary>Clear list of anchor markers.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ClearCameraCalibration">
            <summary>Remove calibration info and set any existing cameras back to default locations.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetCameraCalibration(MoCapCore.cCameraCalibration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the calibration.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ReconstructionBounds">
Calculate the current reconstruction bounds based on values of the reconstruction properties.
</member>
        <member name="M:MoCapCore.cTake.HasAnimation">
            <summary>Returns true if there is any time-series data present.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Empty">
            <summary>Returns true if there is are no nodes, and no time-series data present.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetSharedProperties(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Replace a number of take properties with shared versions from the given provider.</summary>
        </member>
        <member name="M:MoCapCore.cTake.DataWarehouse">
            <summary>Access to the contained DataWarehouse.</summary>
        </member>
        <member name="M:MoCapCore.cTake.NodeWarehouseLock">
            <summary>Access to the contained NodeWarehouse. 
The returned value is a locking object which must be held until all node edits or queries have completed.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SessionID">
            <summary>The session ID for the session that contains this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ID">
            <summary>Unique ID.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Name">
            <summary>Get the human-readable label to use for this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ShiftAnimation(System.Int32!System.Runtime.CompilerServices.IsConst)">
            <summary>Shift all animation data by the given amount. A positive shift means resulting frame numbers will
have increased.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ClearAnimation(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>Clear all animation data over the given range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Clear">
            <summary>Clear all nodes, calibration info, etc. and reset to a default state.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the name. Since names are the same as filenames and takes are stored in session folders,
cTake names must be unique within a session. Responsibility for this is delegated to the TakeManager.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.FinishEdit">
            <summary>Finish an editing operation and send out any missed notifications.</summary>
        </member>
        <member name="M:MoCapCore.cTake.StartEdit">
            <summary>Suspend notifications so that a complex operation can be performed on the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.CopyFrom(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Copies calibration and node warehouse from the given take and replaces them on this instance.
This method may only be used to populate an empty take.</summary>
            <param name="excludeInactiveNodes">If true, inactive nodes will not be cloned in the copy</param>
        </member>
        <member name="M:MoCapCore.cTake.Clone(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStreamWarehouse*,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Creates a clone of this instance with a new unique ID. A new cIDataStreamWarehouse must also be passed
in since there is no sharing of those instances.
<param name="excludeInactiveNodes">If true, inactive nodes will not be cloned in the copy</param></summary>
        </member>
        <member name="M:MoCapCore.cTake.Initialize(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStreamWarehouse*,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,std.shared_ptr&lt;MoCapCore.cIChannelFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cINodeFactoryWarehouse&gt;,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Call to initialize and associate with an existing stream on disk. Ownership of the cIDataStreamWarehouse
instance is transferred here.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.Initialize(std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,std.shared_ptr&lt;MoCapCore.cIChannelFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cINodeFactoryWarehouse&gt;)">
            <summary>Call to initialize a new instance.</summary>
        </member>
        <member name="T:MoCapCore.cTake">
            <summary>
Owns all animation data for a take, as well as setup info for cameras (calibration, etc.).
This class supports deferred loading and serialization of a take.
</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnTakeDelete(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the take is deleted.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnOpenedChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the open state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnDirtyChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the dirty (saved) state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnDataTypesChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the types of data available have changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnReconstructionSettingsChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the reconstruction settings change.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnAnchorPointsChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the anchor points changes.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnCalibrationChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the camera calibration changes.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnTrackListChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the track list changes.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnFrameRangeChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the extents of the time range for this take change.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnSelectedChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the selection state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnNameChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the name (thus the filename) associated with the take is changed.</summary>
        </member>
        <member name="M:Core.cTimeRange.Intersects(Core.cTimeRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if the given range intersects this one. Intersection will be true even if only the
edges coincide.
</summary>
        </member>
        <member name="M:Core.cTimeRange.Contains(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Returns true if this range includes the given time.</summary>
        </member>
        <member name="M:Core.cTimeRange.Contains(Core.cTimeRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this range completely contains the given range.</summary>
        </member>
        <member name="M:Core.cTimeRange.Length">
            <summary>Returns the length (end time minus start time) of the range.</summary>
        </member>
        <member name="M:Core.cTimeRange.Center">
            <summary>Get the center point of the range.</summary>
        </member>
        <member name="M:Core.cTimeRange.End">
            <summary>Get the range start time.</summary>
        </member>
        <member name="M:Core.cTimeRange.Start">
            <summary>Get the range start time.</summary>
        </member>
        <member name="M:Core.cTimeRange.Valid">
            <summary>Returns true if both the start and end time are valid.</summary>
        </member>
        <member name="M:Core.cTimeRange.Empty">
            <summary>Returns true if the time range is empty (i.e. start time &gt; end time).</summary>
        </member>
        <member name="M:Core.cTimeRange.Intersect(Core.cTimeRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Intersects this range with the one given.</summary>
        </member>
        <member name="M:Core.cTimeRange.Clear">
            <summary>Clears the range to an empty range.</summary>
        </member>
        <member name="M:Core.cTimeRange.SetEnd(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the end time of the range. If the range was previously empty, both start and end times
will be set to the given time.
</summary>
        </member>
        <member name="M:Core.cTimeRange.SetStart(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the start time of the range. If the range was previously empty, both start and end times
will be set to the given time.
</summary>
        </member>
        <member name="T:Core.cTimeRange">
            <summary>Represents a range of time.</summary>
        </member>
        <member name="M:Core.cFilename.SetSuffixFormat(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Suffix format specifier:
[suffix root (required)][suffix value format specifier][suffix suffix (optional)]
</summary>
        </member>
        <member name="M:Core.cFilename.ConvertSeparators(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Converts path separators from the standard '/' to whatever the platform separator is.</summary>
        </member>
        <member name="M:Core.cFilename.AppendPathPart(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Appends a single path part to whatever path currently exists, without changing other contents.</summary>
        </member>
        <member name="M:Core.cFilename.AppendPath(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Appends the given path to this one. Both this and the given item must be paths.</summary>
        </member>
        <member name="M:Core.cFilename.Append(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Appends the given filename to this path. Given filename must be relative, and any existing
filename and extension will be overwritten with the incoming filename if successful.
</summary>
        </member>
        <member name="M:Core.cFilename.IsPath">
            <summary>Returns true if the contained information is just a path, not a full filename.</summary>
        </member>
        <member name="M:Core.cFilename.MakeAbsolute(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Make this path absolute, if it is relative. Absolute path is assumed to be relative to the
given path.</summary>
        </member>
        <member name="M:Core.cFilename.IsRelative">
            <summary>Returns true if the contained filename/path is relative (i.e. not absolute)</summary>
        </member>
        <member name="M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Makes this path relative to the given path. Both paths must be absolute to start.</summary>
            <returns>False if the paths are not rooted in the same volume.</returns>
        </member>
        <member name="M:Core.cFilename.IsFilename">
            <summary>Returns true if this is a filename (with extension).</summary>
        </member>
        <member name="M:Core.cFilename.Delete">
            <summary>Attempt to delete any associated real file/folder that exists on disk.</summary>
        </member>
        <member name="M:Core.cFilename.Rename(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the file was renamed.</summary>
        </member>
        <member name="M:Core.cFilename.Exists(System.Boolean)">
            <summary>Returns true if the file or folder exists on disk.</summary>
        </member>
        <member name="M:Core.cFilename.FullFilename">
            <summary>Get the full filename, including volume, path, and extension, if any.</summary>
        </member>
        <member name="M:Core.cFilename.FullName">
            <summary>Get the filename with no path information, but do include the extension, if any.</summary>
        </member>
        <member name="M:Core.cFilename.ExtensionMatches(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Compares extension with the given string and returns true if there is a match.
The passed string should not contain the period used to designate it as a file extension
</summary>
        </member>
        <member name="M:Core.cFilename.Extension">
            <summary>Get the file extension, if any.</summary>
        </member>
        <member name="M:Core.cFilename.Name">
            <summary>Base name (without any path or extension information).</summary>
        </member>
        <member name="M:Core.cFilename.FullPath">
            <summary>Get the full path with drive/volume designation, including a trailing path delimiter.</summary>
        </member>
        <member name="M:Core.cFilename.PathParts">
            <summary>Get the parts of the path as a vector of strings.</summary>
        </member>
        <member name="M:Core.cFilename.IncrementName">
            <summary>
Increments the name portion of the filename to the next incremental value using the given format
statement.
Name format:
[name][suffix root (required)][suffix value][suffix suffix (optional)]
</summary>
        </member>
        <member name="M:Core.cFilename.StripExtension">
            <summary>Strip off any extension that is present.</summary>
        </member>
        <member name="M:Core.cFilename.StripName">
            <summary>Strip off any filename and extension that are present.</summary>
        </member>
        <member name="M:Core.cFilename.StripVolume">
            <summary>Strip off any volume designation that is present.</summary>
        </member>
        <member name="M:Core.cFilename.PopPathPart">
            <summary>Pop one directory off the end of the path.</summary>
        </member>
        <member name="M:Core.cFilename.Path">
            <summary>Get the file path, excluding drive/volume designation, but with a trailing delimiter.</summary>
        </member>
        <member name="M:Core.cFilename.Volume">
            <summary>Drive/volume/server designation, excluding trailing path delimiter (e.g. "C:", "//Data")</summary>
        </member>
        <member name="M:Core.cFilename.Empty">
            <summary>Returns true if all components of the filename are empty.</summary>
        </member>
        <member name="M:Core.cFilename.Clear">
            <summary>Clears all data and resets to default values.</summary>
        </member>
        <member name="M:Core.cFilename.SetExtension(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the extension portion of the filename. Fails if the contained path is not a filename.</summary>
        </member>
        <member name="M:Core.cFilename.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>
Set just the Name portion of the filename (without extension). Passed string should have no path
separators. If renameOnDisk is true and the filename exists on disk, the file will be renamed
to match the given name. Returns false if the file could not be found or renamed when a rename
was requested.
</summary>
        </member>
        <member name="M:Core.cFilename.SetValue(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Parse a new filename.</summary>
        </member>
        <member name="T:Core.cFilename">
            <summary>Manages convenient ways to interact with filenames.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Inequality(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Non-equality operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if the set does not contain exactly one
range which is equal to the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Inequality(NMotive.FrameRangeSet,NMotive.FrameRangeSet)">
            <summary>
Non-equality operator for frame range sets.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range set.</param>
            <returns>
                <c>true</c> if the sets are not equal.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Equality(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Equality operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if the set contains one range which is 
equal to the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Equality(NMotive.FrameRangeSet,NMotive.FrameRangeSet)">
            <summary>
Equality operator for frame range sets.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range set.</param>
            <returns>
                <c>true</c> if the sets are equal.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Subtraction(NMotive.FrameRangeSet,System.Int32)">
            <summary>
Subtraction operator for frame range sets and frame indices.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame index to remove from the set.</param>
            <returns>The frame range set with the given frame range whose start and 
endpoints are the given frame index removed.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Subtraction(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Subtraction operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range to remove from the set.</param>
            <returns>The frame range set with the given frame range removed.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Addition(NMotive.FrameRangeSet,System.Int32)">
            <summary>
Addition operator for frame range sets and frame indices.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame index to add to the set.</param>
            <returns>The frame range set with the given frame range whose start and 
endpoints are the given frame index added.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Addition(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Addition operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range to add to the set.</param>
            <returns>The frame range set with the given frame range added.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.UpdateExtents(System.Int32,NMotive.FrameRange)">
            <summary>Update the extents on the range with the given index in the array.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.ConsolidateRanges">
            <summary>Consolidate overlapping ranges and sort them in ascending order.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.Range(System.Int32)">
            <summary>
Gets the frame range with a given index.
</summary>
            <param name="n">Index of the frame to get.</param>
            <returns> the n'th disjoint range in the set.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Contains(System.Int32)">
            <summary>
Tests if this frame range set contains a given frame index.
</summary>
            <param name="frameIndex">A frame index.</param>
            <returns>
                <c>true</c> if this set includes the given frame.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Contains(NMotive.FrameRange)">
            <summary>
Tests if a given frame range is contained in this set.
</summary>
            <param name="range">The range to test.</param>
            <returns>
                <c>true</c> if this set completely contains the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Extents">
            <summary>
Calculates the extents of this frame range set.
</summary>
            <returns>A frame range with the lowest and highest frames contained 
in the set of ranges.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Clear">
            <summary>Clears the list of ranges.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.Invert">
            <summary>
Inverts the range set in place. If you invert a range that does not include positive and negative
infinity, the inverted set will extend to those limits.
</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersection(NMotive.FrameRange)">
            <summary>
Returns the intersection of the given frame range with the this range set, or an empty frame range
if no intersection.
</summary>
            <param name="range">A frame range.</param>
            <returns>The frame range that is the intersection of this frame range set with the
given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersects(NMotive.FrameRangeSet)">
            <summary>Returns true if the given range set intersects this set.</summary>
            <param name="set">A frame range set.</param>
            <returns>
                <c>true</c>if any frame range intersects any range in the given set.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersects(NMotive.FrameRange)">
            <summary>Returns true if the given range intersects this set.</summary>
            <param name="range">Range to intersect.</param>
            <returns>
                <c>true</c>if any range in this set intercts the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersect(NMotive.FrameRange)">
            <summary>Sets this range set to the intersection with the given range set.</summary>
            <param name="range">The frame range to intersect.</param>
        </member>
        <member name="M:NMotive.FrameRangeSet.AddNoMerge(NMotive.FrameRange)">
            <summary>Add the given frame range into the set without merging overlapping ranges.</summary>
            <param name="range">A frame range to add.</param>
            <returns>
                <c>true</c> if the range was added. Note that the range will not be added if the
set is empty.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Add(NMotive.FrameRange)">
            <summary>Add (union) the given frame range into the set.</summary>
            <param name="range">A frame range to add.</param>
            <returns>True if the set was changed (the given range was not already included).</returns>
        </member>
        <member name="P:NMotive.FrameRangeSet.RangeCount">
            <summary>Returns the number of disjoint ranges contained in the set.</summary>
        </member>
        <member name="P:NMotive.FrameRangeSet.Empty">
            <summary>Returns true if there are no contained ranges.</summary>
        </member>
        <member name="P:NMotive.FrameRangeSet.TotalFrames">
            <summary>Calculates the total number of frames in the full set of ranges.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.#ctor(NMotive.FrameRange)">
            <summary>
Constructs a frame range set containing the given range.
</summary>
            <param name="range">A frame range.</param>
        </member>
        <member name="M:NMotive.FrameRangeSet.#ctor(System.Int32)">
            <summary>
Constructs a frame range set with as single frame range whose
start and end points are the given frame index.
</summary>
            <param name="frameIndex">A frame index.</param>
        </member>
        <member name="M:NMotive.FrameRangeSet.#ctor">
            <summary>
Constructs an empty frame range set.
</summary>
        </member>
        <member name="T:NMotive.FrameRangeSet">
            <summary>
Represents a (non-overlapping) set of frame ranges. Ranges are stored in 
strictly increasing order of frame ranges for convenience when using the class.
</summary>
        </member>
        <member name="M:NMotive.FrameRange.Decrement">
            <summary>
Shift the range down by one frame.
</summary>
            <returns>This frame range decremented.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Increment">
            <summary>
Shift the range up by one frame.
</summary>
            <returns>This frame range incremented.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Decrement">
            <summary>
Shift the range down by one frame.
</summary>
            <returns>A reference to self.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Increment">
            <summary>
Shift the range up by one frame.
</summary>
            <returns>A reference to self.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_GreaterThan(NMotive.FrameRange,System.Int32)">
            <summary>
Greater than comparison operator for a frame range and a frame index.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="frameIndex">A frame index.</param>
            <returns>
                <c>true</c>if the start of the frame range is greater than the 
frame index.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_GreaterThan(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Greater than comparison operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if start of <c>lhs</c> is greater than end of <c>rhs</c> (no range overlap).</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_LessThan(NMotive.FrameRange,System.Int32)">
            <summary>
Less than comparison operator for a frame range and a frame index.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="frameIndex">A frame index.</param>
            <returns>
                <c>true</c>if the endpoint of the frame range is less than the 
frame index.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_LessThan(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Less than comparison operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if end of <c>lhs</c> is less than start time of <c>rhs</c> (no range overlap).</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Inequality(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Non-equality operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>Two frame ranges are equal if their endpoints coincide.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Equality(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Equality operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>Two frame ranges are equal if their endpoints coincide.</returns>
        </member>
        <member name="M:NMotive.FrameRange.ToString">
            <summary>
Creates a string representation of the range.
</summary>
            <returns>A string representation of the range.</returns>
        </member>
        <member name="M:NMotive.FrameRange.GetHashCode">
            <summary>Hash code for frame range objects.</summary>
            <returns>A has code for this object.</returns>
        </member>
        <member name="M:NMotive.FrameRange.CompareTo(NMotive.FrameRange)">
            <summary>
Comparison method for ordering.
</summary>
            <param name="rhs">Object to compare self to.</param>
            <returns>
Less than zero if self is less than <c>rhs</c>,
Zero if self is equal to <c>rhs</c>,
Greater than zero if self is greater than <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.FrameRange.Equals(NMotive.FrameRange)">
            <summary>
Checks equality of ranges. Ranges are equal if their endpoints
coincide.
</summary>
            <param name="rhs">The range to compare this range to.</param>
            <returns>
                <c>true</c> if the ranges are equal.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Intersection(NMotive.FrameRange)">
            <summary>
Returns the intersection of this range with the one given.
</summary>
            <param name="range">Range to intersect with.</param>
            <returns>The intersection of the given range with this range.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Intersects(NMotive.FrameRange)">
            <summary>
Returns true if the given range intersects this one. Intersection will be true even if only the
edges coincide.
</summary>
            <param name="range">Range to check for intersection.</param>
            <returns>
                <c>true</c> if the given range intersects this range.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Contains(System.Int32)">
            <summary>
Checks if this range contains the given frame index.
</summary>
            <param name="frameIndex">Frame index to check.</param>
            <returns>
                <c>true</c> if this range contains the index.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Contains(NMotive.FrameRange)">
            <summary>
Returns true if this range includes the given time.
</summary>
            <param name="range">Range to check.</param>
            <returns>
                <c>true</c> if this range contains the given range completely.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Clear">
            <summary>
Clears the range to an empty range.
</summary>
        </member>
        <member name="M:NMotive.FrameRange.Offset(System.Int32)">
            <summary>
Offsets the range by the given amount, if the range is not empty.
</summary>
            <param name="amount">Number of frames to offset by.</param>
        </member>
        <member name="M:NMotive.FrameRange.Expand(System.Int32)">
            <summary>
Expand the range by the given number of frames at each end. Has no effect if the
range was empty to begin with, or if the given increment is negative.
</summary>
            <param name="increment">Number of frames to expand the range by.</param>
        </member>
        <member name="M:NMotive.FrameRange.Intersect(NMotive.FrameRange)">
            <summary>
Intersects self with another range.
<param name="range">Frame range to intersect.</param></summary>
        </member>
        <member name="M:NMotive.FrameRange.SetExtents(System.Int32,System.Int32)">
            <summary>
Sets both the starting and ending frame indices for the range.
</summary>
            <param name="startIndex">The starting index for the range.</param>
            <param name="endIndex">The ending index for the range.</param>
        </member>
        <member name="P:NMotive.FrameRange.Center">
            <summary>
Gets the center of the range.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.IsEmpty">
            <summary>
returns <c>true</c> if the range is empty.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.Length">
            <summary>
Gets the length of the range in frames.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.End">
            <summary>
Gets and sets the end frame of the range. If the range was previously
 empty, both start and end frames will be set to the given frame.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.Start">
            <summary>
Gets and set the start frame of the range. If the range was
previously empty, both start and end frames will be set to the given frame.
</summary>
        </member>
        <member name="M:NMotive.FrameRange.#ctor(Core.cFrameRange*)">
            <exclude />
        </member>
        <member name="M:NMotive.FrameRange.#ctor(System.Int32,System.Int32)">
            <summary>
Constructs a <c>FrameRange</c> instance with the given
start and end indices.
</summary>
            <param name="startIndex"> The ranges starting index.</param>
            <param name="endIndex">The ranges ending index.</param>
        </member>
        <member name="M:NMotive.FrameRange.#ctor">
            <summary>
Default constructor. Behavior is undefined.
</summary>
        </member>
        <member name="F:NMotive.FrameRange.Forever">
            <summary>
Constant range object representing an infinitely long range.
</summary>
        </member>
        <member name="F:NMotive.FrameRange.Empty">
            <summary>
Constant range object representing an empty range.
</summary>
        </member>
        <member name="T:NMotive.FrameRange">
            <summary>
Class representing a range of contiguous frames.
</summary>
        </member>
        <member name="T:MoCapCore.cFindGapAction">
            <summary>
Either change the label of the passed marker, or combine it with an existing marker in the scene if
one already exists.
</summary>
        </member>
        <member name="M:MoCapCore.cActionFactory.CreateInstance(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a new instance of the type. Ownership is transferred to caller.</summary>
        </member>
        <member name="M:MoCapCore.cActionFactory.TypeName">
            <summary>The type name of the class that will be created by this factory.</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.CanUndo">
            <summary>
Some actions should not participate in the undo system. Those actions should override this
method and return false. ** Internal Use Only **
</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.IsInternalAction">
            <summary>
Actions that should not be directly executed by users(e.g. actions that require valid properties).
</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.Properties">
            <summary>Retrieves a reference to the properties for this action.</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.HasProperties">
            <summary>
Many actions will not have properties associated with them. For the ones that do,
this method will return true.
</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.Activate(MoCapCore.cIProgressIndicator*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Executes the action logic.</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.Description">
            <summary>User-friendly information about what this action is and how to use it.</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.Title">
            <summary>User-facing title to use for this action.</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.Category">
            <summary>The grouping category for this action.</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.ID">
            <summary>
The string identifier for this action, which must be unique among all actions,
and should never change.
</summary>
        </member>
        <member name="T:NMotive.NMotiveUtils">
            <exclude />
        </member>
        <member name="T:NMotive.NMotiveRunMode">
            <exclude />
        </member>
        <member name="T:NMotive.VideoModeValue">
            <summary>
Enumeration of Motive video mode value options.
</summary>
        </member>
        <member name="T:NMotive.Axis">
            <summary>
Enumeration of Motive axis value options.
</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_NegativeZ">
            <summary>The negative z-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_PositiveZ">
            <summary>The positive z-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_NegativeY">
            <summary>The negative y-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_PositiveY">
            <summary>The positive y-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_NegativeX">
            <summary>The negative x-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_PositiveX">
            <summary>The positive x-axis.</summary>
        </member>
        <member name="T:NMotive.LengthUnits">
            <summary>
Enumeration of units of length.
</summary>
        </member>
        <member name="F:NMotive.LengthUnits.Units_Millimeters">
            <summary>Millimeters.</summary>
        </member>
        <member name="F:NMotive.LengthUnits.Units_Centimeters">
            <summary>Centimeters.</summary>
        </member>
        <member name="F:NMotive.LengthUnits.Units_Meters">
            <summary>Meters.</summary>
        </member>
        <member name="T:NMotive.CameraEnabledState">
            <summary>
Enumeration of camera enabled states.
</summary>
        </member>
        <member name="F:NMotive.CameraEnabledState.Disabled">
            <summary>Camera is disabled.</summary>
        </member>
        <member name="F:NMotive.CameraEnabledState.RecordOnly">
            <summary>Camera is enabled for recording only. </summary>
        </member>
        <member name="F:NMotive.CameraEnabledState.Enabled">
            <summary>Camera is enabled.</summary>
        </member>
        <member name="T:NMotive.FileResult">
            <summary>
Enumeration of file operation results.
</summary>
        </member>
        <member name="F:NMotive.FileResult.NotLicensed">
            <summary>
Attempted to load a file that contained elements that are not 
licensed for use in this instance.
</summary>
        </member>
        <member name="F:NMotive.FileResult.AlreadyLoaded">
            <summary>
File is already loaded into the project.
</summary>
        </member>
        <member name="F:NMotive.FileResult.OutOfMemory">
            <summary>
Insufficient memory for the operation.
</summary>
        </member>
        <member name="F:NMotive.FileResult.NoData">
            <summary>
There was no data to write.
</summary>
        </member>
        <member name="F:NMotive.FileResult.NotCompatible">
            <summary>
The file was written by a newer version of the application, or is not otherwise compatible.
</summary>
        </member>
        <member name="F:NMotive.FileResult.BadFormat">
            <summary>
File contained unexpected data fields.
</summary>
        </member>
        <member name="F:NMotive.FileResult.IncompleteFile">
            <summary>
File did not contain all expected data fields.
</summary>
        </member>
        <member name="F:NMotive.FileResult.CannotOpenFile">
            <summary>
File did not exist, could not be read, or could not be written to.
</summary>
        </member>
        <member name="F:NMotive.FileResult.ResultOK">
            <summary>
Operation successful
</summary>
        </member>
        <member name="M:NMotive.UID.Generate">
            <summary>
Generates a new ID value.
</summary>
            <returns>A new ID.</returns>
        </member>
        <member name="M:NMotive.UID.GetHashCode">
            <summary>
Hash code for this ID.
</summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:NMotive.UID.ToString">
            <summary>
String representation.
</summary>
            <returns>String representation.</returns>
        </member>
        <member name="M:NMotive.UID.CompareTo(NMotive.UID)">
            <summary>
Compare to function for ID's.
</summary>
            <param name="rhs">ID to compare to.</param>
            <returns>0 if the ID's are equal, -1 if self is less than the given
ID, and 1 otherwise.</returns>
        </member>
        <member name="M:NMotive.UID.Equals(NMotive.UID)">
            <summary>
Tests for equality of this UID to another.
</summary>
            <param name="rhs">UID to compare self to.</param>
            <returns>true if the given UID is the same as this.</returns>
        </member>
        <member name="M:NMotive.UID.SetValue(System.Int64,System.Int64)">
            <summary>
Set the value for the high and low bits.
</summary>
            <param name="highBits">High bits value.</param>
            <param name="lowBits">Low bits value.</param>
        </member>
        <member name="M:NMotive.UID.op_GreaterThanOrEqual(NMotive.UID,NMotive.UID)">
            <summary>
Greater than or equal comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is greater than or equal to <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_GreaterThan(NMotive.UID,NMotive.UID)">
            <summary>
Greater than comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is greater than <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_LessThanOrEqual(NMotive.UID,NMotive.UID)">
            <summary>
Less than or equal comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is less than or equal to <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_LessThan(NMotive.UID,NMotive.UID)">
            <summary>
Less than comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is less than <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_Inequality(NMotive.UID,NMotive.UID)">
            <summary>
Non-equality operator.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if the ID's are not equal.</returns>
        </member>
        <member name="M:NMotive.UID.op_Equality(NMotive.UID,NMotive.UID)">
            <summary>
Equality operator.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if the ID's are equal.</returns>
        </member>
        <member name="P:NMotive.UID.Valid">
            <summary>
Is the ID valid.
</summary>
        </member>
        <member name="P:NMotive.UID.HighBits">
            <summary>
Gets the high bits.
</summary>
        </member>
        <member name="P:NMotive.UID.LowBits">
            <summary>
Gets the low bits.
</summary>
        </member>
        <member name="M:NMotive.UID.#ctor(NMotive.UID)">
            <summary>
Creates a copy of another <c>UID</c> object.
</summary>
            <param name="other">The ID to copy.</param>
        </member>
        <member name="M:NMotive.UID.#ctor(System.Int64,System.Int64)">
            <summary>
Creates a <c>UID</c> object with the given high bits and low bits.
</summary>
            <param name="highBits">The ID's high bits.</param>
            <param name="lowBits">The ID's low bits.</param>
        </member>
        <member name="M:NMotive.UID.#ctor">
            <summary>
Creates a <c>UID</c> object with value 0 for both high and low bits.
</summary>
        </member>
        <member name="T:NMotive.UID">
            <summary>
Class <c>UID</c> represents a unique ID.  The ID constists of 
two 64 bit integers - the "high" bits and the "low" bits.
</summary>
        </member>
        <member name="T:NMotive.InterpolationType">
            <summary>
Enumeration type of interpolation options.
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.PatternBased">
            <summary>
Key value created from pattern based expected position.
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.Hermite">
            <summary>
Hermite interpolation. Key value follows a cubic Hermite spline 
between key n and key n+1.
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.Linear">
            <summary>
Linear interpolation. Key value proceeds in straight line from key n 
to key n+1
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.Constant">
            <summary>
Constant interpolation. Key value is fixed until next key is encountered.
</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.AnchorConstraintGraph">
            <summary>Returns the anchor marker constraint graph.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.ResetAnchorConstraintGraph">
            <summary>Resets the anchor marker constraint graph.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.CreateAnchorConstraintGraph(std.vector&lt;MoCapCore.cMarkerNode!System.Runtime.CompilerServices.IsConst**,std.allocator&lt;MoCapCore.cMarkerNode!System.Runtime.CompilerServices.IsConst**&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create contraint graph from anchor markers for bumped camera correction.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.VisibleAnchorMarkers">
            <summary>Returns IDs of anchor markers that were visible from this camera when they were created.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.ExtractCalibration">
            <summary>Extract information into a camera calibration object.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetPropertiesFromCalibration(MoCapCore.cCameraSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set properties based on information in a calibration object.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.Graphics">
            <summary>Access to the internal graphical representation of this camera. An interface class.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.PushFrame(std.shared_ptr&lt;CameraLibrary.Frame!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
            <summary>Process a new incoming frame of data.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SupportsImagerWindowing">
            <summary>Returns true for cameras that support imager windowing.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.CameraGroup">
            <summary>Tracks whether this is an object or reference camera.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetStatusRingColor(System.Int32,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Byte!System.Runtime.CompilerServices.IsConst*)">
            <summary>Set colors for all LEDs in the status ring individually</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetStatusRingColor(System.Byte,System.Byte,System.Byte)">
            <summary>Set a single color for all LEDs in the status ring</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.UpdateMoodLight(System.Boolean,System.Boolean)">
            <summary>Updates the camera mood light based on current state.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.Orientation">
            <summary>Retrieve the 2D camera orientation, in radians.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetOrientation(System.Single)">
            <summary>Sets the 2D camera orientation.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetToActualOrientation">
            <summary>Sets the camera view orientation.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.TestObject(CameraLibrary.cObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Perform a 2D centroid filter test on a 2D object. Return value of true means it's passed the
filter test (and should be kept).</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.CentroidFilter2DSettings">
            <summary>Fetch 2D centroid filter settings for this device.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetCentroidFilter2DSettings(MoCapCore.cCentroidFilter2DSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Apply 2D centroid filter settings.  This will push updated settings to the hardware.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetBlocking(System.Single,System.Single,System.Boolean,System.Int32)">
            <summary>Per-pixel blocking mask editing.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.StartBlockingVisibleMarkersInROI(System.Int32,System.Int32,std.vector&lt;Core.cBox2&lt;System.Int32&gt;,std.allocator&lt;Core.cBox2&lt;System.Int32&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Begins to block visible markers that are inside the ROI rectangles over a sequence of several frames.
</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.StartBlockingVisibleMarkers(System.Int32,System.Int32)">
            <summary>
Begins to block visible markers over a sequence of several frames. The mask will not actually
be updated until some time later (after call to FinalizeBlockingUpdate), so the blocking mask
on the camera should not be queried until after it has been updated.
</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.BlockingSurface">
            <summary>Blocking surface and bitmap.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.UpdateBitmapFromBlocking">
            <summary>Update the mask image on the camera with the current blocking mask.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.ClearBlocking">
            <summary>Immediately clears the mask image on the camera. The mask image can be queried and will
return correct results after this method is called.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.EnableState">
            <summary>Convenience function that derives an enable state from the Enabled and ReconstructionEnabled
properties.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.IsEnabledForRecording">
            <summary>True if the camera is enabled and enabled for reconstruction.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.ValidateRateDivisor(System.Int32)">
            <summary>Validate that the requestedRateDivisor is a whole divisor of the master rate.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)">
            <summary>Set the pattern depth that the 2D trajectorizer will use.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.IsVisible3D">
            <summary>True if this camera should be drawn in a 3D viewport.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.InitializePose(System.Boolean)">
            <summary>Initialize internal intrinsics to reasonable values based on the type of camera.</summary>
            <param name="preserveExtrinsics">If true, the existing default extrinsic pose of the camera will be retained.</param>
        </member>
        <member name="M:MoCapCore.cCameraNode.Pose(System.Int32)">
            <summary>Retrieve full pose information for the camera at the given frame.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetPose(Core.cPose&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>Set the pose information for the camera.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.DefaultPose">
            <summary>Retrieve full pose information for the camera. The extrinsics are channels and may be animated
over time. This method returns the default value of those channels.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetDefaultPose(Core.cPose&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the default pose information for the camera. The extrinsics are channels and may be animated
over time. This method sets the default value of those channels.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.PartitionID">
            <summary>ID of the camera group partition that this camera belongs to.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.CameraID">
            <summary>Retrieve the human-usable camera number for this device.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.TrainSolver(std.vector&lt;std.pair&lt;Core.cVector2&lt;System.Single&gt;,Core.cVector3&lt;System.Single&gt;&gt;,std.allocator&lt;std.pair&lt;Core.cVector2&lt;System.Single&gt;,Core.cVector3&lt;System.Single&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Train the camera solver using labeled data.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,System.Int32)">
            <summary>Create an offline camera given the type of camera to create.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cILiveDeviceManager*,MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a blank camera node that can later be filled. Intended only for LIVE devices.</summary>
        </member>
        <member name="T:MoCapCore.cCameraNode">
            <summary>
cCameraNode is a Node that encapsulates access to a lower level Camera object,
which is associated by ID.  It also provides IPropertyProvider and IChannel support.

sub-class this node for specific camera model type to override property settings and other behavior
</summary>
        </member>
        <member name="M:MoCapCore.cICameraNodeFactory.SetDeviceOnNode(MoCapCore.cCameraSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cINode*)">
            <summary>Set the internal device on a DeviceNode using calibration camera settings.</summary>
        </member>
        <member name="M:MoCapCore.cICameraNodeFactory.HasInternalDevice(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*)">
            <summary>Determines if the passed node is a device, and whether it has a valid CameraLibrary device attached.</summary>
        </member>
        <member name="M:MoCapCore.cICameraNodeFactory.CreateInstance(MoCapCore.cCameraSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Construct a new node based on the info given in a cCameraSettings object.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.ApplyInternalSettingsToNode(System.Boolean)">
            <summary>Update node props from internal camera.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.TryGetMaximumDeviceFrameRate(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Get the maximum supported framerate of the system</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.InternalDevice">
            <summary>Access to the internal CameraLibrary device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.SetDevice(std.shared_ptr&lt;CameraLibrary.Camera&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set associated internal device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.ModelName">
            <summary>Returns a human-friendly name for this device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.SetEnabled(System.Boolean)">
            <summary>Enable or disable the device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.MapDeviceRevisionToString(System.Int32)">
            <summary>Map an internal device revision number from the CameraLibrary into a human-readable string.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsSyncAuthority">
            <summary>True if this is a sync authority (includes tbar sync device, esync, optihub).</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsESync">
            <summary>True if this is an esync.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsHub">
            <summary>True if this is an optihub.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsWiredTag">
            <summary> True if Device is a wired active tag (Wired CinePuck) </summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsActive2">
            <summary> True if Device is uses Base Station 2 technology (Wired CinePuck, ActiveIO BaseStation) </summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsBaseStation">
            <summary> True if Device is a Base Station. </summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsUSB">
            <summary>True if this is a USB device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsVirtual">
            <summary>True if this is virtual device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.SerialNumber">
            <summary>Numeric (possibly encoded) serial number that is unique among all cameras.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.Serial">
            <summary>Convenience function to retrieve the serial number of the camera.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt32,System.Int32)">
            <summary>Create an offline device given the type of device to create.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cILiveDeviceManager*)">
            <summary>Creates a blank device node that can later be filled. Intended only for LIVE devices.</summary>
        </member>
        <member name="T:MoCapCore.cDeviceNode">
            <summary>
cDeviceNode is a Node that encapsulates access to a lower level CameraLibrary device object,
which is associated by serial number.  It also provides IPropertyProvider and IChannel support.

sub-class this node for specific device model type to override property settings and other behavior
</summary>
        </member>
        <member name="M:Core.ComputeBlockHash(Core.cSerializer*,SHA1*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,HL_SHA1_CTX*)">
            <summary>Compute hash for a given individual data block of a serializer.</summary>
        </member>
        <member name="M:Core.ComputeHashTag(Core.cSerializer*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Compute a SHA1 hash for the given serializer's data.</summary>
        </member>
        <member name="M:SHA1.SHA1Result(HL_SHA1_CTX*,System.Byte*)">
  @brief 	This ends the sha operation, zeroizing the context
  		and returning the computed hash.

  @param	context The context to get the hash from
  @param	Message_Digest This is an OUT parameter which
  		contains the hash after the menberfunction returns
  @return	0 on succes, an error-code otherwise

</member>
        <member name="M:SHA1.SHA1Input(HL_SHA1_CTX*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
  @brief 	Data input.

  		This memberfunction add data to the specified
  		context.

  @param	context The context to add data to
  @param	message_array The data to add
  @param	length The length of the data to add

</member>
        <member name="M:SHA1.SHA1Reset(HL_SHA1_CTX*)">
@brief 	Resets the sha1 context and starts a new
		hashprocess
@param	context The context to reset
@return	0 on succes an error number otherwise

</member>
        <member name="M:SHA1.SHA1ProcessMessageBlock(HL_SHA1_CTX*)">
  @brief      This member-function will process the next 512 bits of the
  		message stored in the Message_Block array.

      	Many of the variable names in this code, especially the
      	single character names, were used because those were the
      	names used in the publication.

  @param	context The context to process

</member>
        <member name="M:SHA1.SHA1PadMessage(HL_SHA1_CTX*)">
  @brief 	Internal method to padd the message

      	According to the standard, the message must
      	be padded to an even 512 bits. The first
      	padding bit must be a '1'.  The last 64	bits
      	represent the length of the original message.
      	All bits in between should be 0.
      	This function will pad the message according
      	to those rules by filling the Message_Block array
      	accordingly.  It will also call the
      	ProcessMessageBlock function provided appropriately.
      	When it returns, it can be assumed that the message
      	digest has been computed.

  @param	context The context to padd


</member>
        <member name="T:SHA1">
  @brief 	This class represents the implementation of
   		the sha1 algorithm.

   		Basically the class provides three public member-functions
   		to create a hash:  SHA1Reset(), SHA1Input() and SHA1Result().
   		If you want to create a hash based on a string or file quickly
   		you should use the sha1wrapper class instead of SHA1.

</member>
        <member name="F:HL_SHA1_CTX.Corrupted">
Is the message digest corrupted? 
</member>
        <member name="F:HL_SHA1_CTX.Computed">
Is the digest computed? 
</member>
        <member name="F:HL_SHA1_CTX.Message_Block">
512-bit message blocks 
</member>
        <member name="F:HL_SHA1_CTX.Message_Block_Index">
Index into message block array 
</member>
        <member name="F:HL_SHA1_CTX.Length_High">
Message length in bits 
</member>
        <member name="F:HL_SHA1_CTX.Length_Low">
Message length in bits 
</member>
        <member name="F:HL_SHA1_CTX.Intermediate_Hash">
Message Digest 
</member>
        <member name="T:HL_SHA1_CTX">
@brief this struct represents a SHA1-hash context.

</member>
        <member name="D:hl_uint64">
at least 8 Byte

</member>
        <member name="D:hl_uint32">
at least 4 Byte

</member>
        <member name="D:hl_uint16">
at least 2 Byte

</member>
        <member name="D:hl_uint8">
exactly 1 Byte


@file 	hl_sha1.h
@brief	This file contains the declaration of the SHA1 class
@date 	Mo 17 Sep 2007

exactly 1 Byte

</member>
        <member name="T:Core.cSerializer">
            <summary>
Implementation of a serializer for reading and writing to/from a memory buffer, including the
ability to save and load the memory buffer to/from a file.
</summary>
        </member>
        <member name="M:Core.cISerializer.WriteData(Core.cISerializer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>To Be Deprecated - Write the full contents of the given serializer into this one.</summary>
        </member>
        <member name="T:Core.cISerializer">
            <summary>
The base class for serializers that wish to implement both read and write functionality.
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.FileResultToString(MoCapCore.cFileHelpers.eFileResult,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Map a file result code to human-readable strings that describe the type of error.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.ComposeUniqueFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Given a filename, compose a filename that will be unique at the location the filename specifies.
The returned filename will be unique without regard for the file extension specified (i.e. if a file on
disk shares the same base filename as the one given, a new unique filename will be generated).
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.EnumerateFilenames(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.list&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <summary>Get all filenames in specified folder with specified extension. Path must include trailing slash.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.IsVolume(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if the given string is valid syntax for a volume on the host environment.
Does not test whether the volume exists.
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.PathSeparator">
            <summary>Get the path separator used on this platform.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.MakeDirectory(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create a folder at the given path.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.DirectoryExists(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given folder exists on disk.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.FileSize(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the size (in bytes) of the given file.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.FileIsReadOnly(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the file is read-only.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.FileExists(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given file exists on disk.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.IsValidFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns false if the file name contains invalid characters.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.MakeValidFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Scrubs the given string and replaces any invalid filename characters with an underscore.
The given string should not be a full path, but just the filename with or without a file
extension.
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.Delete(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Deletes a file on disk, if it exists and can be deleted.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.Copy(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Copy the file or folder at the given path to the given target path.</summary>
            <param name="overwrite">If true and a file of the same name exists at the target location, it will be overwritten.</param>
        </member>
        <member name="M:MoCapCore.cFileHelpers.Move(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Move the file or folder at the given path and name to the target path.</summary>
        </member>
        <member name="T:MoCapCore.cFileHelpers">
            <summary>A collection of platform-neutral file and folder management routines.</summary>
        </member>
        <member name="M:Core.cIWriter.WriteData(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
            <summary>
Write the given buffer.
</summary>
            <param name="buffer">The data buffer.</param>
            <param name="bufferSize">The size of the data buffer.</param>
            <returns />
        </member>
        <member name="T:Core.cIWriter">
            <summary>
An interface class for writing to a stream, buffer, or file.
</summary>
        </member>
        <member name="T:Core.cIReader">
            <summary>
An interface class for reading from a stream, buffer, or file.
</summary>
        </member>
        <member name="M:Core.cIBasicStream.Size">
            <summary>Reports the total current size of the stream.</summary>
        </member>
        <member name="M:Core.cIBasicStream.Seek(System.UInt64)">
            <summary>Seek to the requested (absolute) position in the stream.</summary>
        </member>
        <member name="M:Core.cIBasicStream.Tell">
            <summary>Returns the current position in the file stream.</summary>
        </member>
        <member name="T:Core.cIBasicStream">
            <summary>
Interface base class for any object that wishes to implement stream read/write operations.
</summary>
        </member>
        <member name="M:Core.cTime.CurrentDateTime">
            <summary>Current local time.</summary>
        </member>
        <member name="M:Core.cTime.TimeString(System.Boolean,System.Char)">
            <summary>Generate a string that contains this date and time in human-readable format.</summary>
        </member>
        <member name="M:Core.cTime.DateTimeString(System.Boolean,System.Char)">
            <summary>Generate a string that contains this date and time in human-readable format.</summary>
        </member>
        <member name="M:Core.cTime.DateString">
            <summary>Generate a string that contains this date in human-readable format.</summary>
        </member>
        <member name="M:Core.cTime.DateTime(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert the internal time value to individual time components.</summary>
        </member>
        <member name="M:Core.cTime.Valid">
            <summary>Returns true if the contained time is valid (not invalid).</summary>
        </member>
        <member name="M:Core.cTime.Average(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Calculate the average time between this and the given time.</summary>
        </member>
        <member name="M:Core.cTime.InSeconds">
            <summary>Time in seconds only (i.e. hours, minutes, etc. all converted into seconds)</summary>
        </member>
        <member name="M:Core.cTime.SetHoursMinutesSeconds(System.Double,System.Double,System.Double)">
            <summary>Set the time based on real time measures.</summary>
        </member>
        <member name="M:Core.cTime.SetInSeconds(System.Double)">
            <summary>Set the full time based on a number of seconds.</summary>
        </member>
        <member name="T:Core.cTime">
            <summary>Represents a relative time.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouseLock.Apply(System.Int32,std.function&lt;(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given function to a filtered set of nodes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HashCode">
            <summary>Returns a hash code that changes anytime data in the node warehouse changes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HashCodeOfType(System.Int32)">
            <summary>Returns a hash code that will remain the same until the list of the queried type changes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindConstraintByLabel(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a constraint from its label. Returns non-null only for nodes that have a valid label.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodesByName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Finds all nodes that match the given node path and appends them to the
given array.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodesByExactName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Finds all nodes that match the given node name and appends them to the
given array.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodeByExactName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a node by name. Only the
first matching instance will be returned.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodeByName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a node by name, which can include partial and/or full path information. Only the
first matching instance will be returned.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodeByID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a node by ID.</summary>
            <returns>The requested node, or NULL if not found.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasKeyedNodesOfType(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if nodes of the requested type exist.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasNodesOfType(System.Int32)">
            <summary>Returns true if nodes of the requested type exist.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.NodeOfTypeByName(System.Int32,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the (first) typed node with the requested name in the array of nodes of that type, or NULL if
the requested name is not found.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.NodeCountOfType(System.Int32)">
            <summary>Returns the number of nodes of the requested type that currently exist.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasSelectedNodesOfType(System.Int32)">
            <summary>Return true if any nodes in the typed node list are selected.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.PrimarySelectedNodeOfType(System.Int32)">
            <summary>Retrieve the primary selected node of a given type.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.SetPrimarySelectedNodeOfType(System.Int32,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the given node as the primary selected node of the requested filter type. If the node is not already selected,
it is first selected.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.PrimarySelectedNode">
            <summary>Returns the primary selected node, if any.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.SetPrimarySelectedNode(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets (and selects if not already selected) the master primary selected node.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.SelectedNodeCountOfType(System.Int32)">
            <summary>Retrieve the number of selected nodes of a requested type.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasSelectedNodes">
            <summary>Return true if any nodes are selected.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AllSelectedNodes(std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the list of all selected nodes in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AllNodesOfType(System.Int32,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Request the full list of objects of the requested type.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AllNodes(std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the list of all nodes in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Empty">
            <summary>Returns true if no nodes are present.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FullFrameRange">
            <summary>Calculate the full frame range for all nodes in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearSelectionOfType(System.Int32)">
            <summary>Deselect all items that are of the given type.</summary>
            <returns>True if any selection state was changed.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearSelection">
            <summary>Deselect all items in the scene.</summary>
            <returns>True if any selection state was changed.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.SelectNodes(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Select the list of named nodes. Node naming can include full and/or partial path
information.</summary>
            <returns>The number of nodes whose selection state was changed.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasAnimation">
            <summary>Returns true if animation exists on any nodes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearAnimationOfType(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Removes all animation data for all nodes of requested type within the given time range.</summary>
            <param name="range">Range to operate over.</param>
            <param name="removeEmptyNodes">If true, any nodes that do not have animation on them after clearing the requested
data range will be deleted.</param>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearAnimation(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Removes all animation data for all nodes within the given time range.</summary>
            <param name="range">Range to operate over.</param>
            <param name="deleteEmptyNodes">If true, any nodes that do not have animation on them after clearing the requested
data range will be deleted.</param>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearOfType(System.Int32)">
            <summary>Removes all nodes that pass the given filter.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Clear(System.Boolean)">
            <summary>Removes all nodes.</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Apply(System.Int32,std.function&lt;(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given function to a filtered set of nodes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Apply(std.function&lt;(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given function to all nodes in the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.RemoveNodes(std.unordered_set&lt;Core.cUID,std.hash{Core.cUID},std.equal_to&lt;Core.cUID&gt;,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Efficiently remove a set of nodes from the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.RemoveNode(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Removes the node with the given ID. Also removes any other child hierarchy attached to the given node.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.NodePassesFilter(System.Int32,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Locates the requested filter and tests the given node against it to determine if it passes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearAllNodeFilters">
            <summary>Clears and deletes all node filters. Since this is a static, class-wide resource, instances
created after this call will have no filters available unless filters are re-added.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindFilterID(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to find the ID of a filter with the given name. Returns 0 if not found.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AddNodeFilter(std.unique_ptr&lt;MoCapCore.cINodeFilter,std.default_delete&lt;MoCapCore.cINodeFilter&gt;&gt;)">
            <summary>Add a node filter. This will create a cached list of nodes that pass the filter, and will maintain it
as nodes are added to or removed from the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.CreateAndAddNode(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create and add a node of the requested type. This is a convenience wrapper around the
node factory warehouse. Returns the created node.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AddNode(std.unique_ptr&lt;MoCapCore.cINode,std.default_delete&lt;MoCapCore.cINode&gt;&gt;,System.Boolean)">
            <summary>Add a node to the scene.
The scene takes ownership of the node at this point. Node ID's must be unique within a scene,
so attempts to add multiple nodes with the same ID will fail.</summary>
            <returns>True if the node was added to the scene.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
De-serialize this object from the given reader.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Serialize this object to the given writer.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.IsEditing">
Check to see if the scene is being edited.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.FinishEdit">
Finish an editing operation and send out any missed notifications.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.StartEdit">
Suspend notifications so that a complex operation can be performed on the take.
</member>
        <member name="T:MoCapCore.cNodeWarehouse">
            <summary>Manages all nodes in the scene. It owns all items in the scene and is responsible for their deletion.</summary>
        </member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeChannelListChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when a node's channel List changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnVisibilityChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when node's visibility changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeNameChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when a node's name changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeDataChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the channel data of any node change.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnFrameRangeChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the animation extents of any node change.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeHierarchyChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the scene hierarchy changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnSelectionChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when selection state for one or more items in the scene changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeListChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when one or more nodes is added or removed.
</member>
        <member name="T:MoCapCore.cINodeWarehouseObserver">
            <summary>Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.PropertyNames">
            <summary>Returns the property name predicates with the names of the property warehouse properties that
this node uses.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SetVisible(System.Boolean)">
            <summary>True if the asset is visible (active).</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.AttachedBones(std.vector&lt;MoCapCore.cBoneNode!System.Runtime.CompilerServices.IsConst**,std.allocator&lt;MoCapCore.cBoneNode!System.Runtime.CompilerServices.IsConst**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Gather the list of bones that are descendants of this skeleton. Bones are returned ordered
from the root outward in a depth-first traversal.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.DOFDefinitions(std.vector&lt;Core.cDOFDefinition,std.allocator&lt;Core.cDOFDefinition&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Retrieve the full list of degrees-of-freedom definitions. If empty, DOF definitions are assumed to
be a one-to-one mapping to all channels on the asset, with a weight of 1.0 for each.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.AssetIsRoot">
            <summary>Whether the asset itself is treated as a root transform (else its direct children are roots).</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.ClearDOFDefinitions">
            <summary>Remove all degree-of-freedom definitions.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.RemoveDOFDefinition(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Remove a degree-of-freedom definition.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.MergeDOFDefinitions(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Merge a second dof definition with a first.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.AddDOFElement(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cDOFElement.eChannel,System.Single)">
            <summary>Add a degree-of-freedom element to existing definition.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.AddDOFDefinition(Core.cDOFDefinition!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a degree-of-freedom definition.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.TrainAddBoneLinks(System.Double!System.Runtime.CompilerServices.IsConst,System.Boolean!System.Runtime.CompilerServices.IsConst,System.Boolean!System.Runtime.CompilerServices.IsConst)">
            <summary>Add bone links (AKA joints) using the model matrix.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.TrainRefineBones(std.vector&lt;std.pair&lt;Core.cUID,Core.cVector3&lt;System.Single&gt;&gt;,std.allocator&lt;std.pair&lt;Core.cUID,Core.cVector3&lt;System.Single&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Refine bones using tracking data.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.TrainAddBoneTopology(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary>Add automatically-detected bones using the model matrix.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.TrainModelMatrix(std.vector&lt;std.pair&lt;Core.cUID,Core.cVector3&lt;System.Single&gt;&gt;,std.allocator&lt;std.pair&lt;Core.cUID,Core.cVector3&lt;System.Single&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Single)">
            <summary>Train the model matrix using labelled data.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.ConstraintGraph">
            <summary>Retrieve the constraint graph.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SetConstraintGraph(std.shared_ptr&lt;MoCapCore.cConstraintGraph!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the set of constraint edges to use for the boot model.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.ConstraintIDFromLabel(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Conversion of cLabel to constraint UID, ultimately for the elimination of cLabel.
</summary>
            <param name="label">Legacy cLabel object.</param>
            <returns>Constraint UID or kInvalid if the label does not match a constraint.</returns>
        </member>
        <member name="M:MoCapCore.cAssetNode.ConstraintIDFromMemberID(System.UInt32)">
            <summary>
Conversion of memberID to constraint UID, ultimately for the elimination of memberID.
</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.RemoveAllConstraints(MoCapCore.cNodeWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Removes all constraints by type.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.RemoveConstraint(MoCapCore.cNodeWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>Removes the constraint with the given memberID. Returns false if no such member.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.NextMemberID(System.UInt32)">
            <summary>The next unused MemberID greater than memberID</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.AddNewConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.Single,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create and add a constraint.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.AddConstraint(MoCapCore.cConstraintNode*)">
            <summary>Add a constraint.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.ConstraintCountForBone(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Return constraint count for the given bone</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.ConstraintsForBone(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;MoCapCore.cConstraintNode!System.Runtime.CompilerServices.IsConst**,std.allocator&lt;MoCapCore.cConstraintNode!System.Runtime.CompilerServices.IsConst**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve all constraints for the bone.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.AllConstraints">
            <summary>Retrieve all constraints currently associated with this skeleton.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.TransformBoneAttachments(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cSimpleTransform&lt;System.Single&gt;,System.Boolean)">
            <summary>Transform all constraints attached to a bone on this asset.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.TransformConstraints(Core.cSimpleTransform&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Transform all constraints attached to this asset.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SetConstraintOffsets(System.UInt32,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cQuaternion&lt;System.Single,true&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>Set the model marker's offsets.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SetConstraintActiveID(System.UInt32,System.UInt32)">
            <summary>Set the model marker's activeID.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.ConstraintPosition(System.UInt32)">
            <summary>Get the model marker's local offset.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.ConstraintCount">
            <summary>Number of constraints associated with this asset.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SelectedConstraints">
            <summary>Retrieve all selected constraints.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SelectedConstraintCount">
            <summary>Query for the number of selected constraints (markers).</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.IsConstraintSelected(System.UInt32)">
            <summary>Query for the selection state of a member marker.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SelectAllConstraints(System.Boolean)">
            <summary>Set the selection state of all member constraints.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.SelectConstraint(System.UInt32,System.Boolean)">
            <summary>Set the selection state of a member constraint.</summary>
        </member>
        <member name="M:MoCapCore.cAssetNode.FullClone(System.Boolean)">
            <summary>Clones the asset node and all hierarchy underneath, except children of constraints which are markers.</summary>
        </member>
        <member name="F:MoCapCore.cAssetNodeData.mAssetIsRoot">
Whether the asset itself is treated as a root transform (else its direct children are roots).
</member>
        <member name="T:MoCapCore.cAssetNodeData">
cAssetNodeData contains members of cAssetNode that aren't stored as properties and so need special treatment for undo, etc.
</member>
        <member name="M:MoCapCore.cIAssetNodeObserver.OnAssetNodeChanged(MoCapCore.cAssetNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The Asset node changed.</summary>
        </member>
        <member name="M:MoCapCore.CreateConstraintGraph(Core.cUMatrix&lt;Core.cUID,Core.sIndexDataPair&lt;MoCapCore.cStats&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary>create a graph of constraints with backward-linking edges and their mean distances and inverse variances
the constraint graph contains only "back edges", ie edges to previously added nodes
the ordering of constraints is chosen to maximise the number of back edges
</summary>
        </member>
        <member name="M:MoCapCore.GetDrawableEdges(std.set&lt;std.pair&lt;Core.cUID,Core.cUID&gt;,std.less&lt;std.pair&lt;Core.cUID,Core.cUID&gt;&gt;,std.allocator&lt;std.pair&lt;Core.cUID,Core.cUID&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUMatrix&lt;Core.cUID,Core.sIndexDataPair&lt;MoCapCore.cStats&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> extract from a matrix a set of oriented edges between pairs of marker IDs.</summary>
        </member>
        <member name="M:MoCapCore.UpdateStatsMatrix(Core.cUMatrix&lt;Core.cUID,Core.sIndexDataPair&lt;MoCapCore.cStats&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.map&lt;Core.cUID,std.set&lt;Core.cUID,std.less&lt;Core.cUID&gt;,std.allocator&lt;Core.cUID&gt;&gt;,std.less&lt;Core.cUID&gt;,std.allocator&lt;std.pair&lt;Core.cUID!System.Runtime.CompilerServices.IsConst,std.set&lt;Core.cUID,std.less&lt;Core.cUID&gt;,std.allocator&lt;Core.cUID&gt;&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVec&lt;std.pair&lt;Core.cUID,Core.cVector3&lt;System.Single&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary>
update a cSparseStatsMatrix with a new frame of marker IDs and positions.
preserve the number of edges, and keep the highest-scoring candidates.
</summary>
        </member>
        <member name="T:MoCapCore.cJointMatrix">
            <summary> Learns and represents the transform of a joint connecting two animating bones </summary>
        </member>
        <member name="M:MoCapCore.cSphereSolver.Solve(Core.cVector3&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> solve for origin = (a,b,c) and radius = r such that: (x - a)^2 + (y - b)^2 + (z - c)^2 = r^2 </summary>
        </member>
        <member name="M:MoCapCore.cSphereSolver.Add(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> add the point to the solver </summary>
        </member>
        <member name="M:MoCapCore.cRTSolver.Solve(MoCapCore.cRTf*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> solve for rigid transform </summary>
        </member>
        <member name="M:MoCapCore.cRTSolver.AddW(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst)">
            <summary> add the point to the solver with a weighting </summary>
        </member>
        <member name="M:MoCapCore.cRTSolver.Add(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> add the point to the solver </summary>
        </member>
        <member name="M:MoCapCore.cQCamera.Position">
            <summary> the position of the camera </summary>
        </member>
        <member name="M:MoCapCore.cQCamera.UpdateP(System.Double*)">
            <summary> given a target projection matrix, update mK and mRT to match. preserve the signs of mFx and mFy </summary>
        </member>
        <member name="M:MoCapCore.cQCamera.CopyToPose(Core.cPose&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Convert the camera to cPose. NOTE the pose must have its ImagerResolution set before calling this. the pose additionally has an ImagerSize (not used).
</summary>
        </member>
        <member name="T:MoCapCore.cQCamera">
            <summary> represents a camera </summary>
        </member>
        <member name="M:MoCapCore.cQIntrinsics.Project(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Projects a 3D point and applies lens distortion, returns pixel coordinate </summary>
        </member>
        <member name="M:MoCapCore.cQIntrinsics.ProjectNoDistort(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Projects a 3D point without applying lens distortion, returns unitless coordinate </summary>
        </member>
        <member name="M:MoCapCore.cQIntrinsics.Distort(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Applies lens distortion to a projected point, converting to pixels </summary>
        </member>
        <member name="M:MoCapCore.cQIntrinsics.Undistort(Core.cVector2&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Removes the effect of lens distortion on the detection, converting from pixels to unitless. The return value is a "metric ray" (px,py,-1) </summary>
        </member>
        <member name="T:MoCapCore.cQIntrinsics">
            <summary> Represents the intrinsic lens matrix [mFx 0 -mOx; 0 mFy -mOy; 0 0 -1] and distortion parameters.
after multiplying, projection is achieved by dividing the vector by its z coordinate.
so, this represents a camera looking down the negative z-axis. x is right and y is up.
if projection happens *before* multiplying the matrix, it should divide the negative z-coordinate.
the transform then becomes simply (mFx * x + mOx, mFy * y + mOy).
this space, before multiplying, is a unitless space called screen space.
screen space coordinates have an implicit -1 in the z-coordinate.
its origin is at the lens centre. this is the space in which the lens distortion is properly applied.
lens distortion uses a five-parameter model, radial: mK1_Inv, mK2_Inv, mK3_Inv and tangential: mTx_Inv, mTy_Inv.
Compared to Motive, mFy = -FocalLengthY (because Motive pixels are measured from the top-left,
whereas the y-axis is up in the world). Also: mTx_Inv = Tangential1*(2*ks), mTy_Inv = Tangential0*(-2*ks), 
mK1_Inv = Coefficient0*(ks*ks), mK2_Inv = Coefficient1*(ks*ks*ks*ks), (where ks = mFx/ImagerPixelWidth).
mFx = FocalLengthX, mOx = PrincipalX, mOy = PrincipalY are unchanged.
Note that Motive's lens distortion parameters are for *undistorting* the lens.
This class inverts those lens undistortion parameters to produce lens distortion parameters.
The Distort method performs the conversion from screen space to pixels, and the Undistort method
reverses this.
</summary>
        </member>
        <member name="T:MoCapCore.cRTf">
            <summary> cRTf is a cMatrix34 type that only represents rotations and translations (no scale or skew). </summary>
        </member>
        <member name="M:MoCapCore.Hash(Core.cVector2&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
            <summary> a locality hashing function. takes a 2D point and computes a 10-bit integer. points close together
get related hash values.
</summary>
        </member>
        <member name="M:MoCapCore.Hash(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
            <summary> a locality hashing function. takes a 3D point and computes a 12-bit integer. points close together
get related hash values.
</summary>
        </member>
        <member name="T:MoCapCore.sEdgeStats">
            <summary> sEdgeStats holds statistics for an edge
</summary>
        </member>
        <member name="M:MoCapCore.cCameraSolver.Add(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> accumulate two geometric constraints per point </summary>
        </member>
        <member name="M:MoCapCore.cCameraSolver.Add(MoCapCore.cQCamera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector2&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> accumulate two geometric constraints per point </summary>
        </member>
        <member name="M:MoCapCore.cCameraSolver.Solve(MoCapCore.cQCamera*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> coerce the smallest eigenvector into a 3x4 matrix </summary>
        </member>
        <member name="M:MoCapCore.cLensSolver.Add(MoCapCore.cQIntrinsics!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector2&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector2&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> d is a detection (pixels, distorted), p is a projection (without distortion) </summary>
        </member>
        <member name="M:MoCapCore.cLensSolver.Add(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> add equations to solve for the function to undistort from d to p </summary>
        </member>
        <member name="M:MoCapCore.cLensSolver.Add(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> accumulate the equation: x0 * mK1 + x1 * mK2 + x2 * mK3 + x3 * mTx + x4 * mTy = y0 </summary>
        </member>
        <member name="M:MoCapCore.cBundleSolver.Add(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> accumulate two constraints of the form E0 x + E1 y + E2 z = E3 </summary>
        </member>
        <member name="M:MoCapCore.cBundleSolver.AddMetricRay(MoCapCore.cQCamera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> accumulate two geometric constraints per ray </summary>
        </member>
        <member name="M:MoCapCore.cBundleSolver.AddDetection(MoCapCore.cQCamera!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector2&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> accumulate two geometric constraints per ray </summary>
        </member>
        <member name="M:MoCapCore.cBundleSolver.Solve">
            <summary> solve Mx = m for x </summary>
        </member>
        <member name="T:MoCapCore.cStats">
            <summary>Maintains a running estimate of Mean and Mean-square of a sequence of float values
</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelFromLabelName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Look up a label given a label name.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelOrder(System.UInt32,System.Int32,System.Boolean)">
            <summary>Set the named label to be at the given index in label ordering.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelColor(System.UInt32)">
            <summary>Retrieve the color of a label given the member ID.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelColors(std.vector&lt;Core.cVector3&lt;System.Single&gt;,std.allocator&lt;Core.cVector3&lt;System.Single&gt;&gt;&gt;*)">
            <summary>Retrieve the list of label colors associated with this source, by current label order.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelColor(System.UInt32,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Override the default label color with the given one.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.ClearLabelSticks">
            <summary>Clear all label sticks.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelSticks(std.vector&lt;Core.cMarkerStick,std.allocator&lt;Core.cMarkerStick&gt;&gt;*)">
            <summary>Retrieve the list of label sticks associated with this source.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelStick(Core.cMarkerStick!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create or replace a label stick.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.IsLabelName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given name matches a name in the label list.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.OriginalLabelNames(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <returns>A vector of all original label names, by current label order. This method should be
removed at some point when label source templates are fully implemented.</returns>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelNames(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <returns>A vector of all label names, by current label order.</returns>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelName(System.UInt32)">
            <summary>Retrieve the label with the given member ID.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelName(System.UInt32,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Assign a new name to replace the existing name of a label.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.ConstraintOrder">
            <summary>Retrieve a vector of label member ID's, in current label order.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelCount">
            <summary>Number of labels provided by this label source.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.EntityName">
            <summary>The unique name of this label source among any active label sources.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.EntityID">
            <summary>The unique ID of this label source.</summary>
        </member>
        <member name="T:MoCapCore.cILabelSource">
            <summary>Interface class for any element that provides marker labels.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSourceObserver.OnLabelColorChanged(MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever a label's color changes.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSourceObserver.OnLabelChanged(MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever the available labels list changes.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSourceObserver.OnLabelListChanged(MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever the available labels list changes.</summary>
        </member>
        <member name="M:MoCapCore.cBoneNode.SetChannel(std.unique_ptr&lt;MoCapCore.cIChannel,std.default_delete&lt;MoCapCore.cIChannel&gt;&gt;)">
cIChannelProvider
</member>
        <member name="M:MoCapCore.cBoneNode.RotationOrder">
            <summary>Convenience method for accessing the rotation order.</summary>
        </member>
        <member name="M:MoCapCore.cBoneNode.SetRotationOrder(MoCapCore.cBoneDefinition.eRotationOrder)">
            <summary>Set the rotation order.</summary>
        </member>
        <member name="M:MoCapCore.cBoneNode.SetVisible(System.Boolean)">
            <summary>Convenience methods for quick access to "Visible" property.</summary>
        </member>
        <member name="M:MoCapCore.cBoneNode.DegreesOfFreedom">
            <summary>Retrieve a bitfield of the current DOF's. Defined in cBoneDefinition::eBoneDOF</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.UpdateExtents(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Update the extents on the range with the given index in the array.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.SortRanges">
            <summary>Sort ranges in ascending order.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.ConsolidateRanges">
            <summary>Consolidate overlapping ranges and sort them in ascending order.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.TotalFrames">
            <summary>Calculates the total number of frames in the full set of ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Range(System.Int32)">
            <summary>Returns the n'th disjoint range in the set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.RangeCount">
            <summary>Returns the number of disjoint ranges contained in the set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Contains(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this set includes the given frame.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Contains(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if one of the ranges in the set completely contains the given range.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Extents">
            <summary>Returns a frame range with the lowest and highest frames contained in the set of ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Empty">
            <summary>Returns true if there are no contained ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Clear">
            <summary>Clears the list of ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Invert">
            <summary>
Inverts the range set in place. If you invert a range that does not include positive and negative
infinity, the inverted set will extend to those limits.
</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersection(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns the intersection of the given frame range with the this range set, or an empty frame range
if no intersection.
</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersects(Core.cFrameRangeSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given range set intersects this set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersects(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given range intersects this set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersect(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets this range set to the intersection with the given frame range.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Subtract(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Subtract the given range from the set, if it is included.</summary>
            <returns>True if the set was changed as a result (i.e. the set did include all or part of the given range.</returns>
        </member>
        <member name="M:Core.cFrameRangeSet.AddNoMerge(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add the given frame range into the set without merging overlapping ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Add(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add (union) the given frame range into the set.</summary>
            <returns>True if the set was changed (the given range was not already included).</returns>
        </member>
        <member name="M:Core.cFrameRangeSet.op_Assign(std.vector&lt;Core.cFrameRange,std.allocator&lt;Core.cFrameRange&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The passed set of frame ranges is assumed to be in non-overlapping, always-increasing order.</summary>
        </member>
        <member name="T:MoCapCore.cTransformNode">
            <summary>Concrete implementation of a class that supports translation/rotation transform hierarchies.</summary>
        </member>
        <member name="M:MoCapCore.cBoneDefinition.GlobalTransform">
            <summary>World-space base transform.</summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.Hash">
            <summary>Returns a hash that is unique to this instance of this type of data bundle. Uniqueness is not
guaranteed between different types of bundles.</summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.Empty">
            <summary>Returns true if there are no rays in the bundle.</summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.Clear">
            <summary>Clears all data and prepares this instance to be reused. This is useful for reusing memory
that has been previously allocated </summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.TypeID">
            <summary>Return the type ID of the type that is bundled. This should be unchanged over time, and is an
arbitrary value that just needs to be unique among bundle types. Used as an identifier when using multiple
generic bundle pointers to retrieve the desired bundle type.</summary>
        </member>
        <member name="T:Core.cIDataTypeBundle">
            <summary>
The base class for all pipeline data bundle types.
</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.CopyTo(Core.cTMarker&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>Copy the marker definition and translation data at the given frame into the given marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.Size">
            <summary>Get the physical size of the marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.SetSize(System.Single)">
            <summary>Set the absolute physical size of this marker, replacing any sampled average size.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.AnchorVisibility">
            <summary>For anchor markers, returns the vector of camera serials that contributed to their reconstruction.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.AnchorVisible(System.Int32)">
            <summary>Returns true if this anchor marker was initially visible from the specified camera when created.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.SetAnchorVisibility(std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the anchor marker visibility from the cameras.</summary>
            <param name="visibility">List of camera serial numbers that contributed to the anchor marker reconstruction when it was initially created.</param>
        </member>
        <member name="M:MoCapCore.cMarkerNode.IsAnchorMarker">
            <summary>True if this is an anchor marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.IsMeasurement">
            <summary>True if this is a measurement point.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.ActiveID">
            <summary>Returns the activeID (overridden by the constraint), or zero if the marker is passive.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.IsActiveMarker">
            <summary>Returns true if this was recorded from an active marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.IsLabeled">
            <summary>Returns true if this marker has a valid label.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.LabelEntity">
            <summary>Search for the node entity that matches the entity ID of the current label.</summary>
            <returns>Null if there is no label or if no existing entity can be found for the entityID.</returns>
        </member>
        <member name="M:MoCapCore.cMarkerNode.ConstraintLabel">
            <summary>Return the label currently in use by this marker, if any.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.SetLegacyLabel(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Just store a value on the marker node.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.Constraint">
            <summary>Yield the assigned constraint (or nullptr).</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.SetConstraint(MoCapCore.cConstraintNode*)">
            <summary>Assigns this marker to that constraint. Pass nullptr to unassign a marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.FullName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>Returns the "full" name of the marker, which is the EntityName_MarkerName for labeled markers,
and simply the name for unlabeled markers.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,System.Boolean)">
            <summary>Create a new instance with an assigned ID.</summary>
        </member>
        <member name="M:MoCapCore.cIMarkerNodeObserver.OnLabelChanged(MoCapCore.cMarkerNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the node's name has changed.</summary>
        </member>
        <member name="T:MoCapCore.cIMarkerNodeObserver">
            <summary>
Observer class for marker node object types. Derive from this type in order to be notified of changes
to any markers that you attach to as an observer.
</summary>
        </member>
        <member name="T:MoCapCore.cTranslationNodeFactory">
            <summary>Factory class for cNode</summary>
        </member>
        <member name="T:MoCapCore.cTranslationNode">
            <summary>
Concrete implementation of a class that supports translation/rotation transform hierarchies.
</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.WorldTransform(System.Int32)">
            <summary>Returns the world-space transform at the given frame.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.Transform(System.Int32)">
            <summary>Get the full (local) transform at the given time.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.Rotation(System.Int32)">
            <summary>Get the local position at the given time.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.Translation(System.Int32)">
            <summary>Get the local position at the given time.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.SetRotation(System.Int32,Core.cQuaternion&lt;System.Single,true&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>A convenience method for setting local rotation. The default rotation will be set if no animation
channel exists.</summary>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:MoCapCore.cITransformSource.SetTranslation(System.Int32,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>A convenience method for setting local translation. The default translation value will be set if no
animation channel exists.</summary>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="T:MoCapCore.cITransformSource">
            <summary>
Abstract base class for all nodes in a scene.
</summary>
        </member>
        <member name="T:MoCapCore.cNodeFactory">
            <summary>Factory class for cNode</summary>
        </member>
        <member name="T:MoCapCore.cNode">
            <summary>Concrete implementation of the INode interface class. Nodes own channel instances and are channel providers.
 They are also property providers through the cPropertyCollection class.</summary>
        </member>
        <member name="T:MoCapCore.cPropertyCollection">
            <summary>A list of Properties.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.SetPropertiesToDefaultValues(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Convenience method to set all properties to their default values.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Property(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Access to properties by name.</summary>
            <returns>The property, if found. A null value otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Apply(std.function&lt;(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given functional to each of the properties in this provider.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Apply(std.function&lt;(MoCapCore.cProperty*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cProperty*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given functional to each of the properties in this provider.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Properties(std.vector&lt;std.shared_ptr&lt;MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst&gt;&gt;&gt;*)">
            <summary>Retrieve the full properties list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.PropertyCount">
            <summary>Retrieve the number of properties in this collection. Depending on the storage method for the
contained properties, this method could result in an O(n) operation to enumerate the properties, so
take care not to call it within inside loops.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.RemoveProperty(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Remove a named property from the collection of properties owned by this object.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.AddProperties(std.vector&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;,std.allocator&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add an array of properties at once. This may allow for economizing on notifications, array sizing, etc.
The unique_ptr version has a concrete implementation to accommodate the script interfaces.
</member>
        <member name="M:MoCapCore.cIPropertyProvider.AddProperty(std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a property instance to this collection. Ownership of the property instance transfers
to this object with this call. Added properties must have unique names.</summary>
            <returns>True if the property was successfully added to the collection.</returns>
The unique_ptr version has a concrete implementation to accommodate the script interfaces.
</member>
        <member name="T:MoCapCore.cIPropertyProvider">
            <summary>A list of Properties.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProviderObserver.OnPropertyAttributesChanged(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>Callback that gets called when any attributes on the property change.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProviderObserver.OnPropertyValueChanged(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when the value of the property changes.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProviderObserver.OnPropertyListChanged(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when properties are added or removed.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SemanticType">
            <summary>Get the semantic type, if any of this definition.</summary>
            <returns>Reference to the semantic if any. If the definition has no
semantic type the returned ref will be null (!SemanticType() will evaluate to true).</returns>
        </member>
        <member name="M:MoCapCore.cProperty.SetToConstraintValue(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the property value to the value of the named constraint from the constraint list.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetToConstraintValue(System.UInt32,System.Boolean)">
            <summary>Set the property value to the value of the constraint at the given index in the constraint list.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintsAreMandatory">
            <summary>
Returns true if the constraints are mandatory, false if it is possible
to set custom value as well.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintsAreRange">
            <summary>
Returns true if the constraints should be considered a range. In this case,
exactly two constraints should exist, a max and a min.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.DefaultConstraintIndex(System.Boolean)">
            <summary>Returns the index of the constraint that is the property's default value, or -1 if there
are either no active constraints, or the value does not match any of the constraints.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ActiveConstraintIndex">
            <summary>Returns the index of the constraint that is the property's current value, or -1 if there
are either no active constraints, or the value does not match any of the constraints.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintName(System.UInt32)">
            <summary>Get the name of the constraint at the given index, if any.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Constraint(System.UInt32)">
            <summary>Get the constraint at the given index.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintCount(System.Boolean)">
            <summary>Find out how many value constraints are active.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetDefaultValueFromString(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the default value from a string representation.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Serializable">
            <summary>Returns true if this property should be serialized (saved).</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetSerializable(System.Boolean)">
            <summary>Sets the serializable flag on the underlying definition.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Advanced">
            <summary>Returns true if this property should be considered "advanced".</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetAdvanced(System.Boolean,System.Boolean)">
            <summary>Set the advanced flag. This sets the value on the underlying definition.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Hidden">
            <summary>True if this property is (or should be) hidden.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetHidden(System.Boolean,System.Boolean)">
            <summary>Set the hidden flag. This is an override.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ReadOnly">
            <summary>Returns true if this property is read-only.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetReadOnly(System.Boolean,System.Boolean)">
            <summary>Set the read-only flag.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.EndEditAttributes">
            <summary>
Finish a grouped edit of attributes. Any callbacks associated with attribute editing that
were held by calling BeginEditAttributes will be called once this method is called.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.BeginEditAttributes">
            <summary>
Begin an edit operation on attributes. This must be matched with a call to
<code>EndEditAttributes()</code>. Calls to <code>BeginEditAttributes()</code> and
<code>EndEditAttributes()</code> should not be nested.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ClearMacro(System.Boolean)">
            <summary>Clear any active macro.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetToMacro(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>Activate the named macro.</summary>
            <returns>True if the macro was found and set as active.</returns>
        </member>
        <member name="M:MoCapCore.cProperty.ActiveMacro(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the name of the currently active macro, if any.</summary>
            <returns>True if a macro is currently active.</returns>
        </member>
        <member name="M:MoCapCore.cProperty.AvailableMacros(std.vector&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**,std.allocator&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the array of available macros for use with this property.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.HasMacros">
            <summary>Returns true if there are macros available for this property.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetValueFromString(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>
Set the value of the property from a string, if possible. The string must be formatted
identically to the formatting used by ValueAsString().
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ValueAsString">
            <summary>
Retrieve the value of the property as a string. Each value type will have its own
representation of what the returned string should look like.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.op_Equality(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Equality comparison operator. Compares values.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Copy(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copy the value and attributes of the given property into our own, if possible.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.IsSame(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given property was created by the same ParameterDefinition as this one.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.IsDefaultAttributes">
            <summary>Returns true if property attributes agree with the corresponding ones from its definition.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.IsDefaultValue(System.Boolean)">
            <summary>Returns true if a default value exists for the property, and the current value is set to it. Property
default values are override-able from the definition. 
If <c>definition</c> is true the property's
value will be checked against its default value from the definition. If false the property's value will
be checked it's local default value. If the property has not overridden its default value this parameter
has no effect.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetToDefaultValue(System.Boolean,System.Boolean)">
            <summary>Sets the value of this property to its default value, if it has one.</summary>
            <param name="respectReadOnly">If true, the read-only status is respected.</param>
            <returns>True if a default value exists and the property value was set to it.</returns>
        </member>
        <member name="M:MoCapCore.cProperty.ValueIsValid(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given property has a value and it satisfies any current constraints
and custom validators.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ValueIsValid">
            <summary>Returns true if the property has a value and it satisfies any current constraints.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.BoolValue">
            <summary>
Retrieve the property value based on the underlying type. The method called must match
the type of the underlying cIPropertyValue.
</summary>
            <returns />
        </member>
        <member name="M:MoCapCore.cProperty.SetValue(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Set the property value. The correct type for the underlying cIPropertyValue
must be used when calling this method.
</summary>
            <returns>True if the value is set successfully.</returns>
        </member>
        <member name="M:MoCapCore.cProperty.FindConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Find constraint. Will either be from definition or instance-specific (overridden).</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ClearConstraintOverrides(System.Boolean)">
            <summary>Removes any existing constraint overrides. Non-templated function that can be called on any property.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.HasConstraintOverrides">
            <summary> true if property has custom (overridden) set of constraints.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetConstraintOverrides(std.vector&lt;std.pair&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,MoCapCore.cIPropertyValue**&gt;,std.allocator&lt;std.pair&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,MoCapCore.cIPropertyValue**&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set constraint overrides on this property instance. This will also do property value validation
and set the property value to the nearest constraint, by value. It replaces any existing constraint
overrides.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.GroupLabel">
            <summary>A user-facing group label that the UI may use to group parameters. Should be localized.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Description">
            <summary>A brief description of this property. Should be localized.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Label">
            <summary>The user-facing label to display for this property. Should be localized.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Name">
            <summary>The internal name of this property, used for lookups. Should not be changed with localization</summary>
        </member>
        <member name="T:MoCapCore.cProperty">
            <summary>
A generic property class that provides storage and management for a generic type of data, determined
by the derived type of cIPropertyValue stored. Properties should only be instantiated from a property
definition.
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyObserver.OnPropertyAttributesChanged(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>Callback that gets called when any attributes on the property change.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyObserver.OnPropertyValueChanged(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when the value of the property changes.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.ConstraintsAreMandatory">
            <summary>Returns true if the constraints are mandatory, false if it is possible to set custom value.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.SetConstraintsAreMandatory(System.Boolean)">
            <summary>If set, if constraints are mandatory or only predefined values with option to set own value.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.ConstraintsAreRange">
            <summary>Returns true if the constraints should be interpreted as a value range.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.SetConstraintsAreRange(System.Boolean)">
            <summary>If set, there should be exactly two constraints and they represent a value range (min, max).</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.ConstraintName(System.UInt32)">
            <summary>Get the name of the constraint at the given index, if any.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.FindConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to find the constraint value by name.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.Constraint(System.UInt32)">
            <summary>Get the constraint at the given index.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.RemoveAllConstraints">
            <summary>
Remove any constraints associated with this definition.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.AddConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create and add a named constraint with a specified value. The name must be unique among all constraints
attached to this object. If the a constraint with name does not already exist for this object, it is
added along with the specified value.
</summary>
            <param name="name">Constraint name. Must be unique within this definition.</param>
            <param name="val">Constraint value.</param>
            <returns>false if there is already a constraint with this name and the constraint
was not added, true otherwise</returns>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.AddConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create and add a named constraint. The name must be unique among all constraints attached to this
object. Ownership of the returned pointer remains with this object.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.FindMacro(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Finds and returns a named macro, or NULL if it was not found.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.DefaultMacro">
            <summary>Returns the default macro, or NULL if none.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.AvailableMacros(std.vector&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**,std.allocator&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the list of macros compatible with this parameter definition.</summary>
            <returns>True if some items were added to the results array.</returns>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.HasMacros">
            <summary>Returns true if there are available macros.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.Units">
            <summary>The internal units of the property value.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.#ctor(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoC">
            <summary>Construct a new parameter definition.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.IsIndeterminate(MoCapCore.cIPropertyValue.eAxisMask)">
            <summary>
Method for determining if a property's value is indeterminate.
</summary>
            <returns>true if indeterminate and false if well defined.</returns>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.TypeInfoHashCode">
            <summary>Get the std::type_info.hash_code() value for the underlying type.</summary>
            <returns>Type info hash code.</returns>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.SetValueFromString(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the value from a string.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.ValueAsString">
            <summary>
Retrieve the value of the property as a string, useful for text serialization or presentation in a UI.
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.IsEqual(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIPropertyValue.eAxisMask)">
            <summary>Equality comparison function.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.IsLessThan(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Less-than comparison function.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.CopyFrom(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Copy the contents of the given object into this one. We use this instead of an assignment
operator to ensure that all derived classes define it.
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.Clone">
            <summary>
Create a new object that is a duplicate of this one. The caller assumes ownership of the
returned object.
</summary>
        </member>
        <member name="T:MoCapCore.cIPropertyValue">
            <summary>
Interface base class for parameter value storage. Parameters contain an instance of cIPropertyValue.
</summary>
        </member>
        <member name="M:MoCapCore.cISemanticType.Clone">
            <summary>Creates a new object that is a copy of this one.</summary>
        </member>
        <member name="T:MoCapCore.cISemanticType">
            <summary>
Base class for all semantic types. These are very simple class derivations that provide
a heuristic way to deal with parameters that may have the same data type, but may differ
substantially in their meaning. For example, you may have two parameters that are both
Vector3f's, but one may be an unbounded position while the other is an RGB color. UI's
can use semantic types to assign appropriate controls to a parameter.

Use dynamic_cast to determine whether a type is of a requested type
<code>
if( dynamic_cast&lt;ISemanticTypeColor*&gt;( semanticType ) != NULL )
{
    // This is the type wanted
}
</code>

Because they are class types, semantic types can be arranged in a hierarchy so that base types
can share UI implementations (if the UI chooses to do that).
</summary>
        </member>
        <member name="F:MoCapCore.cUndoStack.kDefaultMaxMemSize">
            <summary>The default maximum memory size for the undo buffer before serialization starts to engage.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.HasItemsForTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>Returns true if any cUndoItem exists for the take.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.SetCurrentTakeID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set ID of current take.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Enabled">
            <summary>True if the undo stack is enabled (i.e. will accept new undo items).</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.SetEnabled(System.Boolean)">
            <summary>Enable or disable acceptance of new undo items.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Editing">
            <summary>True if an edit operation is active.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.FinishEdit(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Finishes and commits the changes to a usable undo list.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.CancelEdit">
            <summary>Cancels any current edit operation and undoes any items on the current edit stack.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.AddItem(MoCapCore.cIUndoItem*)">
            <summary>Add an item to the currently active edit list. Takes ownership of the item.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.StartEdit">
            <summary>Start a new edit operation if one is not already active.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.RedoCaption">
            <summary>Returns the current redo caption, or empty string if none.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.UndoCaption">
            <summary>Returns the current undo caption, or empty string if none.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.InUndoRedo">
            <summary>Returns true if an undo or redo is currently being executed.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.CanRedo">
            <summary>Returns true if there is an available redo.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.CanUndo">
            <summary>Returns true if there is an available undo.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Clear(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Clears the undo/redo stack for a given take.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Clear">
            <summary>Clears the undo/redo stack completely and with extreme prejudice.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Redo">
            <summary>Redo the top group of items in the list that was previously undone.</summary>
            <returns>True if there was a list to redo and redo was successful.</returns>
        </member>
        <member name="M:MoCapCore.cUndoStack.Undo">
            <summary>Undo the top group of items in the list.</summary>
            <returns>True if there was a list to undo and undo was successful.</returns>
        </member>
        <member name="M:MoCapCore.cUndoStack.SetMaxMemSize(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Set a hint for how much memory usage is acceptable before serialization of items in the list
should start to occur.
</summary>
        </member>
        <member name="T:MoCapCore.cUndoStack">
            <summary>
Manages an undo stack composed of grouped undo items. Each undo/redo may affect a long list of edits
that occurred, so individual undo items are grouped into lists that can be undone/redone as a unit.
If a disk cache file is set, undo items will be cached to disk when the max mem size for the undo
stack is exceeded.
</summary>
        </member>
        <member name="M:MoCapCore.cUndoList.MemorySize">
            <summary>
Cumulative size (in memory) of all items in the list. Will be a small number if the list items
have been serialized to disk.
</summary>
        </member>
        <member name="M:MoCapCore.cUndoList.SetCaption(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the caption to use for this set of operations.</summary>
        </member>
        <member name="M:MoCapCore.cUndoList.AddItem(MoCapCore.cIUndoItem*)">
            <summary>Add an item to the list. Takes ownership of the item.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.IsValid">
            <summary>Checks if the undo item can still be executed.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.IsSame(MoCapCore.cIUndoItem!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Return true if this undo item can be considered to be the same as the given one. This is used
to replace existing undo items with more recent versions. Any undo items that store incremental values
should return false.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.MemorySize">
            <summary>The (approximate) size of this item in memory when not serialized.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.Redo">
            <summary>Redo any previously undone data edits that are part of this item.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.Undo">
            <summary>Undo any data edits that are part of this item.</summary>
        </member>
        <member name="T:MoCapCore.cIUndoItem">
            <summary>
Derive from this interface to create units of undo-able data edits. Multiple undo items can be pushed
onto the stack between UndoStack::StartEdit()/UndoStack::FinishEdit() calls and they will be collected
into a single undoable operation.
When implementing Redo(), remember that Undo() will have been called first on your undo item, so any
state information in the UndoItem should represent what the original state was, and how to Redo the
edit.
</summary>
        </member>
        <member name="M:Core.CoreCount">
            <summary>Query the number of cores available on this machine.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFilter.TestNode(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*)">
            <summary>Returns true if the given node passes this filter.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFilter.TypeID">
            <summary>Return the type ID for this filter. This is an arbitrary value, but needs to be unique among filter types.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFilter.Name">
            <summary>Returns the name for this filter. It can be any arbitrary value, but should be unique among filter types.</summary>
        </member>
        <member name="M:Core.cLabel.op_Equality(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Comparison operators.</summary>
        </member>
        <member name="M:Core.cLabel.LegacyDecodeUID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.eEntityType*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Legacy method to help with encoding and decoding the previous definition of a label.</summary>
            <returns>True if the passed ID was a legacy label that could be decoded.</returns>
        </member>
        <member name="M:Core.cLabel.Valid">
            <summary>True if the label has a non-null entity ID. Does not attempt to ensure that the entity ID
is valid or that it belongs to an asset that has associated markers for labeling.</summary>
        </member>
        <member name="M:Core.cLabel.MemberID">
            <summary>The label ID within the entity.</summary>
        </member>
        <member name="M:Core.cLabel.EntityID">
            <summary>The node ID for the entity that this label belongs to.</summary>
        </member>
        <member name="T:Core.cLabel">
            <summary>A class that represents a marker label. Marker labels consist of two parts: The entity that the marker
is associated with (e.g. skeleton, rigid body, etc.), and the (one-based) index into the label list for that entity.
</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactory.CreateInstance(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a new instance of the type. Ownership is transferred to caller.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactory.TypeName">
            <summary>The type name of the class that will be created by this factory.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Visible">
            <summary>Get the current selection state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SetVisible(System.Boolean)">
            <summary>Set the visibility state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SetSelectedRecursive(System.Boolean)">
            <summary>Set the selection state of itself and all its descendant nodes.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SelectedRecursive">
            <summary>Get the current selection state of itself or any child nodes.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Selected">
            <summary>Get the current selection state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SetSelected(System.Boolean)">
            <summary>Set the selection state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Name">
            <summary>Get the internal identifier string.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the internal identifier string used for this node.</summary>
            <returns>False if the name cannot be set (e.g. is read-only).</returns>
        </member>
        <member name="M:MoCapCore.cINode.AttachedNodes(std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Gather the list of nodes that are descendants of this one.</summary>
        </member>
        <member name="M:MoCapCore.cINode.RootNode">
            <summary>Get the root node of this node.</summary>
        </member>
        <member name="M:MoCapCore.cINode.FindByID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempts to find a node with the given ID in the hierarchy of this node, including
this node.</summary>
        </member>
        <member name="M:MoCapCore.cINode.FindByName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempts to find a node with the given name in the hierarchy of this node, including
this node.</summary>
        </member>
        <member name="M:MoCapCore.cINode.PreviousSibling">
            <summary>Get the previous sibling to this node, if any.</summary>
        </member>
        <member name="M:MoCapCore.cINode.NextSibling">
            <summary>Get the next sibling to this node, if any.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Parent">
            <summary>Get the current parent of this node.</summary>
            <returns>Pointer to current parent, or NULL if none.</returns>
        </member>
        <member name="M:MoCapCore.cINode.FirstChild">
            <summary>Retrieve the child at the given index.</summary>
        </member>
        <member name="M:MoCapCore.cINode.ChildCount">
            <summary>Counts and returns our number of children.</summary>
        </member>
        <member name="M:MoCapCore.cINode.HasChildren">
            <summary>Returns true if this node has children.</summary>
        </member>
        <member name="M:MoCapCore.cINode.RemoveChild(MoCapCore.cINode*)">
            <summary>Removes the given child from the child list for this node.</summary>
            <returns>True if the child was removed. False if the child cannot be removed, or is not a child.</returns>
        </member>
        <member name="M:MoCapCore.cINode.AddChild(MoCapCore.cINode*)">
            <summary>Add the given node as a child to this one. The given node will be removed from
any node hierarchy that it is presently part of. Certain node types may only be
added as descendants or children of certain other node types.</summary>
            <returns>True if the child was added. False if the child was previously added or cannot be.</returns>
        </member>
        <member name="M:MoCapCore.cINode.FinalizeChannelData(System.Int32,MoCapCore.cIChannel*)">
            <summary>Update channel data after loading take file.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>De-serialize this object from the given reader.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize this object to the given writer.</summary>
        </member>
        <member name="M:MoCapCore.cINode.GenerateNewID">
            <summary>Generate a new ID for this node. Typically only used by the framework as node ID's should
not normally be changed.</summary>
        </member>
        <member name="M:MoCapCore.cINode.ID">
            <summary>A unique ID among the universe.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Clone">
            <summary>Make a deep copy. The new copy will have the same ID as the original. This is typically
used to make copies of things like skeletons or other asset types when creating new takes from
existing ones.</summary>
        </member>
        <member name="M:MoCapCore.cINode.TypeName">
            <summary>Returns a class-specific type name that does not change over time. This is an internal
identifying name, not for display.</summary>
        </member>
        <member name="T:MoCapCore.cINode">
            <summary>Abstract base class for all nodes in a scene.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnNodeDelete(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the node is being deleted.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnChannelListChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called on channel list change.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnHierarchyChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when either this node's parent is switched or the hierarchy underneath
it is changed.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnSelectedChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the node's selection state has changed.</summary>
        </member>
        <member name="T:MoCapCore.cINodeObserver">
            <summary>
Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.KeyCount">
            <summary>Returns the number of the keys on the channel</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.KeyFrameRange">
            <summary>Returns the frame range extents of all keys on all channels.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.IsKeyed(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if any channel keys exist in the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.IsKeyed(System.Int32)">
            <summary>Returns true if any channel key exists at the given frame.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Channel(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the channel with the given name, or a dummy channel if there is no match.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Apply(std.function&lt;(MoCapCore.cIChannel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cIChannel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Apply the given functional to each of the channels in this provider.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.LiveChannels(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst&gt;&gt;&gt;*)">
            <summary>Retrieve the full live channel list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.LiveChannels(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;&gt;&gt;*)">
            <summary>Retrieve the full live channel list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Channels(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst&gt;&gt;&gt;*)">
            <summary>Retrieve the full channel list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Channels(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;&gt;&gt;*)">
            <summary>Retrieve the full channel list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.ChannelCount">
            <summary>Returns the number of channels available. Depending on the container type used to store the
channel list, this method could result in an O(n) count, so be careful not to use it in tight loops.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.HasChannel(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if a channel of the given type exists on this node.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.SetChannel(std.unique_ptr&lt;MoCapCore.cIChannel,std.default_delete&lt;MoCapCore.cIChannel&gt;&gt;)">
            <summary>Set one of the animation channels. Which channel gets set is governed by the Name()
of the given channel. If the name is not recognized as a pre-defined channel slot, the channel is still added as
a channel for the node.</summary>
            <returns>True if the given channel was a match for this node and was set as a channel.</returns>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Clear(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Clear all animation data over the given range if selectedKeysOnly is false. Otherwise, only clears
selected keys within the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.FinishEdit">
            <summary>Finish a started undo-able edit operation.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.StartEdit">
            <summary>Start an undo-able edit operation.</summary>
        </member>
        <member name="T:MoCapCore.cIChannelProvider">
            <summary>Abstract base class for all nodes in a scene.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProviderObserver.OnChannelDataChanged(MoCapCore.cIChannelProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The animation data of the channel changed.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProviderObserver.OnFrameRangeChanged(MoCapCore.cIChannelProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The animation range of the channel changed.</summary>
        </member>
        <member name="T:MoCapCore.cIChannelProviderObserver">
            <summary>Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelFactory.CreateInstance(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a new channel of the type specified by this factory.</summary>
            <param name="channelName">A name for the channel, such as Rotation or Translation. This name designates a role
that the channel fills when attached to a node.</param>
        </member>
        <member name="M:MoCapCore.cIChannelFactory.TypeName">
            <summary>Human-readable type name for the object type that this factory creates.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load the object from the given serialization source.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize to the given writer.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SetSamplesPerFrame(System.Int32)">
            <summary>Set the number of value samples stored per frame.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SamplesPerFrame">
            <summary>Retrieve the number of value samples stored per frame.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyIndexRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.pair&lt;System.UInt32,System.UInt32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Get the key index range that falls within or on the edges of the given frame range.</summary>
            <param name="timeRange">The frame range to search across.</param>
            <param name="idxRange">The start and end indices of the keys that fall within or on the
frame range boundaries. Only valid if true is returned from the method.</param>
            <returns>True if a valid key index range was found.</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.FindKeyIndex(System.Int32,System.Boolean)">
            <summary>
Finds the key index for the requested frame, searching forward or back to find it if the requested frame
does not lie at a key. Returns a value less than 0 if there are no keys or no keys exist at the requested time
or beyond when traveling in the search direction.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyIndex(System.Int32)">
            <summary>
Returns the key index at the given frame, if it corresponds to a key. Frames that do not
correspond to a key will return a negative value. That value is the number of frames since the last
key, or FrameConstants::NegativeInfinity if there are no keys or the requested frame is before any keys.
For example, if the value returned for a given requested frame is -8, then the previous valid key in time
occurred 8 frames ago in time.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyFrameRange">
            <summary>Get the frame range covered by all keys.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyFrameDistance(System.Int32)">
            <summary>
Calculate the distance, in frames, from the given frame to the nearest key in the key array. Distance
will always be non-negative.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyFrame(System.UInt32)">
            <summary>Determine the frame corresponding to the key at the given index.</summary>
            <returns>The frame number if a valid key index is given. FrameIndex::Invalid otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.IsKey(System.Int32)">
            <summary>Determine if a key is set at the given time</summary>
            <param name="tm">FrameIndex at which to search</param>
            <returns>True if a key exists, false otherwise</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyCount">
            <summary>Returns the number of keys present.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.FillGaps(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIChannel.eInterpolationType,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fills any gaps that exist within the given frame range whose length is less than or equal to 
the given max gap width. The frame range must completely contain the gap(s) to be filled, except
in the case of filling gaps before the first key or after the last key. In that case, the gap
will be filled to the extents of the requested range as int as the range includes a key.
</summary>
            <returns>The number of gaps filled.</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range. If there
are no keys, an infinite range will be returned.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range or there are no gaps
less than or equal to the requested max gap size that lie within the given full range.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Segments(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve a list of ranges that have continuous data (i.e. no gaps) for the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.GapRange(System.Int32)">
            <summary>
Returns the full gap range of the gap that the requested frame lies within, or an empty range if
the frame is not in a gap.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Gaps(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieve a frame range set of gaps that lie within a given range. Any gaps that lie on the boundary
of the requested range will be clipped to lie within the requested range.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.HasGaps(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if there are any frame gaps between the first key and the last. To test for gaps beyond
the first and last keys, you should pass in the full take frame range that you want to test against.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.HasKeys(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if keys exist within the given the time range, including endpoints.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.HasKeys">
            <summary>Returns true if keys exist.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.ScaleAndOffsetTime(System.Double,System.Double,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Scale and offset the time component of all keys on the channels by the given amounts.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.ShiftKeys(System.Int32!System.Runtime.CompilerServices.IsConst)">
            <summary>Shift any existing keys by the number of frames indicated. Positive frame shift will result in
higher frame numbers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.ClearSelected(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Deletes any selected keys in the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Clear">
            <summary>Clear all keys.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Clear(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Deletes any keys within or on the edges of the given time range. To clear all, just pass cFrameRange::Forever</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SelectedKeys">
            <summary>Retrieve a list of selected keys.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.HasSelectedKeys">
            <summary>Determine if there are any currently selected keys on the channel.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SelectAllKeys(System.Boolean)">
            <summary>Set the selection state of all keys.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SelectKeys(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the selection state of the keys that fall within (or on the edges of) the given time range.</summary>
            <returns>The number of keys whose selection state was altered.</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.SelectKey(System.UInt32,System.Boolean)">
            <summary>Set the selection state of the key at the given key index.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.FinishEdit">
            <summary>Finishes an edit operation and issues any needed change notifications.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.StartEdit">
            <summary>
Begins an edit operation on this channel. All notifications are delayed until the edit
operation is completed with a matching call to FinishEdit().
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.CopyFrom(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copy the contents from the given channel into this one. This is a replacement for attempting
to override the assignment operator, which is messy to virtualize.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
            <summary>Sets name used to identify what role this channel plays, usually in a node.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Name">
            <summary>A name used to identify what role this channel plays, usually in a node.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.TypeName">
            <summary>The channel type that this channel applies to within a node.</summary>
        </member>
        <member name="T:MoCapCore.cIChannel.eInterpolationType">
            <summary>Key interpolation types.</summary>
        </member>
        <member name="T:MoCapCore.cIChannel">
            <summary>Pure virtual base class for animation track types</summary>
        </member>
        <member name="M:MoCapCore.cIChannelObserver.OnKeySelectionChanged(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the selection state of any keys change.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelObserver.OnKeyRangeChanged(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the overall frame range for the key array changes.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelObserver.OnSetKeys(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever new keys have been created, or existing keys have been edited or deleted.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelObserver.OnSetDefaultValue(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever new keys have been created, or existing keys have been edited or deleted.</summary>
        </member>
        <member name="M:Core.cFrameRange.op_Decrement">
            <summary>Shift the range down by one frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.op_Increment">
            <summary>Shift the range up by one frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.Intersects(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if the given range intersects this one. Intersection will be true even if only the
edges coincide.
</summary>
        </member>
        <member name="M:Core.cFrameRange.Contains(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this range includes the given time.</summary>
        </member>
        <member name="M:Core.cFrameRange.Contains(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this range completely contains the given range.</summary>
        </member>
        <member name="M:Core.cFrameRange.Length">
            <summary>Returns the length (end time minus start time) of the range.</summary>
        </member>
        <member name="M:Core.cFrameRange.Center">
            <summary>Get the center point of the range.</summary>
        </member>
        <member name="M:Core.cFrameRange.End">
            <summary>Get the range end frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.Start">
            <summary>Get the range start frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.Empty">
            <summary>Returns true if the frame range is empty (i.e. start frame &gt; end frame).</summary>
        </member>
        <member name="M:Core.cFrameRange.Clear">
            <summary>Clears the range to an empty range.</summary>
        </member>
        <member name="M:Core.cFrameRange.Offset(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Offsets the range by the given amount, if the range is not empty.</summary>
        </member>
        <member name="M:Core.cFrameRange.Intersection(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the intersection of this range with the one given.</summary>
        </member>
        <member name="M:Core.cFrameRange.ExpandBy(System.Int32)">
            <summary>
Expand the range by the given number of frames at each end. Has no effect if the
range was empty to begin with, or if the given increment is negative.
</summary>
        </member>
        <member name="M:Core.cFrameRange.Include(System.Int32)">
            <summary>Expand the range, if necessary, to include the given frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.Intersect(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Intersects this range with the one given.</summary>
        </member>
        <member name="M:Core.cFrameRange.SetExtents(System.Int32,System.Int32)">
            <summary>Set both start and end of the range.</summary>
        </member>
        <member name="M:Core.cFrameRange.SetEnd(System.Int32)">
            <summary>
Set the end frame of the range. If the range was previously empty, both start and end frames
will be set to the given frame.
</summary>
        </member>
        <member name="M:Core.cFrameRange.SetStart(System.Int32)">
            <summary>
Set the start frame of the range. If the range was previously empty, both start and end frames
will be set to the given frame.
</summary>
        </member>
        <member name="T:Core.cFrameRange">
            <summary>Represents a range of time.</summary>
        </member>
        <member name="M:Core.cICameraFrameFactory.CreateInstance">
            <summary>Create a new instance of a camera frame.</summary>
        </member>
        <member name="T:Core.cICameraFrameFactory">
            <summary>
The base class for all camera frame factories.
</summary>
        </member>
        <member name="T:Core.cICameraFrame">
            <summary>
An interface class representing a single frame of data from one camera or device.
</summary>
        </member>
        <member name="T:Core.cFrameConstants">
            <summary>
Commonly-used frame constant values.
</summary>
        </member>
        <member name="M:Core.cTimer.Elapsed">
            <summary>Get the current value of the timer (in secs).</summary>
        </member>
        <member name="M:Core.cTimer.CatchUp">
            <summary>Restarts the timer and returns the time (in secs) it had before the restart.</summary>
        </member>
        <member name="T:Core.cTimer">
            <summary>
A high-precision timer class for calculating elapsed times
Usage :
  cTimer timer;
  ...
  double elapsed = timer.Elapsed();
</summary>
        </member>
        <member name="M:Core.cThreadLock.Unlock">
            <summary>
Release the lock. The lock must have been previously acquired with a call to Lock() or a
successful call to TryLock(). Declared const so it can be used in const methods.
</summary>
        </member>
        <member name="M:Core.cThreadLock.Lock">
            <summary>Acquire a lock. Declared const so it can be used in const methods.</summary>
        </member>
        <member name="M:Core.cThreadLock.TryLock">
            <summary>Try to acquire a lock. Declared const so it can be used in const methods.</summary>
            <returns>True if the lock was engaged.</returns>
        </member>
        <member name="T:Core.cThreadLock">
            <summary> A thin wrapper around std::recursive_mutex, without actually using recursive_mutex.
That's because NMotive uses clr and can't compile code using std::recursive_mutex directly.
Ensure single-thread entry into blocks of code surrounded by Lock()/TryLock() and Unlock() pairs.
Every call to Lock()/TryLock() must be matched with a call to Unlock()
</summary>
        </member>
        <member name="T:Core.cDebugSystem">
            <summary>
A collection of static methods for debug output, failure detection, and logging.
</summary>
        </member>
        <member name="M:Core.cAtomicLong.SetValue(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Performs an atomic set value.</summary>
        </member>
        <member name="M:Core.cAtomicLong.SetIfEqual(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Sets the variable to the given value if its current value matches compareVal.</summary>
        </member>
        <member name="M:Core.cAtomicLong.Decrement">
            <summary>Performs an atomic decrement.</summary>
        </member>
        <member name="M:Core.cAtomicLong.Increment">
            <summary>Performs an atomic increment.</summary>
        </member>
        <member name="M:Core.cAtomicLong.op_Assign(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Performs an atomic assignment.</summary>
        </member>
        <member name="T:Core.cAtomicLong">
            <summary>
A class that is thread-safe and lock-free by using atomic operations for manipulating a single
long integer value.
</summary>
        </member>
        <member name="M:Core.cUID.Generate">
            <summary>Generate a new UID value.</summary>
        </member>
        <member name="M:Core.cUID.Valid">
            <summary>Returns true if the ID is valid (i.e. not equal to kInvalid).</summary>
        </member>
        <member name="M:Core.cUID.HighBits">
            <summary>Get the high 64 bits of the UID.</summary>
        </member>
        <member name="M:Core.cUID.LowBits">
            <summary>Get the low 64 bits of the UID.</summary>
        </member>
        <member name="M:Core.cUID.SetValue(System.UInt64,System.UInt64)">
            <summary>
Set the value of the UID from two long integer values. It is up to the caller to ensure that
the resulting UID is unique.
</summary>
        </member>
        <member name="M:Core.cUID.#ctor">
            <summary>
Create a default UID. In order to create a UID that has a valid unique identifier you
must call Generate().
</summary>
        </member>
        <member name="T:Core.cUID">
            <summary>
A platform-neutral 128-bit universal identifier. It is essentially guaranteed to never
generate the same ID twice.
</summary>
        </member>
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLNode.Accept(tinyxml2wc.XMLVisitor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntText(System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.Print(tinyxml2wc.XMLPrinter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.NewDeclaration(System.Char!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLHandle'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLPrinter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cMultiDeviceTrack.DataTypes'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLNode.Accept(tinyxml2wc.XMLVisitor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntText(System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.Print(tinyxml2wc.XMLPrinter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.NewDeclaration(System.Char!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLHandle'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLPrinter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLNode.Accept(tinyxml2wc.XMLVisitor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntText(System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.Print(tinyxml2wc.XMLPrinter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.NewDeclaration(System.Char!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLHandle'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLPrinter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLNode.Accept(tinyxml2wc.XMLVisitor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntText(System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.Print(tinyxml2wc.XMLPrinter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.NewDeclaration(System.Char!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLHandle'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLPrinter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLNode.Accept(tinyxml2wc.XMLVisitor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntText(System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.Print(tinyxml2wc.XMLPrinter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.NewDeclaration(System.Char!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLHandle'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLPrinter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLNode.Accept(tinyxml2wc.XMLVisitor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntText(System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.Print(tinyxml2wc.XMLPrinter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.NewDeclaration(System.Char!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLHandle'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLPrinter'. -->
        <!-- Discarding badly formed XML document comment for member 'T:MotiveCore.cAudioCaptureProperties'. -->
    </members>
</doc>